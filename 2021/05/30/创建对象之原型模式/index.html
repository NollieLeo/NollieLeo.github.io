<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>创建对象之原型模式 - 翁先森的博客</title>

  
    <meta name="description" content="原型模式每一个函数都会创建一个prototype的属性 原型方式 12345678910111213function Person()&amp;#123;&amp;#125;Person.prototype.name &#x3D; &amp;#x27;weng&amp;#x27;;Person.prototype.age &#x3D; 23;Person.sayName &#x3D; function()&amp;#123;    console.log(this.">
<meta property="og:type" content="article">
<meta property="og:title" content="创建对象之原型模式">
<meta property="og:url" content="https://github.com/NollieLeo/2021/05/30/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="翁先森的博客">
<meta property="og:description" content="原型模式每一个函数都会创建一个prototype的属性 原型方式 12345678910111213function Person()&amp;#123;&amp;#125;Person.prototype.name &#x3D; &amp;#x27;weng&amp;#x27;;Person.prototype.age &#x3D; 23;Person.sayName &#x3D; function()&amp;#123;    console.log(this.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/.com//image-20210530153200440.png">
<meta property="og:image" content="https://github.com/.com//image-20210530163634192.png">
<meta property="article:published_time" content="2021-05-30T05:42:33.000Z">
<meta property="article:modified_time" content="2023-01-28T09:23:36.898Z">
<meta property="article:author" content="翁先森">
<meta property="article:tag" content="Javascript">
<meta property="article:tag" content="面试题">
<meta property="article:tag" content="原型模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/.com//image-20210530153200440.png">
  
  

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="翁先森的博客" type="application/atom+xml">
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="/assets/avatar.png">
  

  

  


  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/assets/avatar.png" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">翁先森的博客</div><div class="sub cap">乌拉</div></a></div>

<nav class="menu dis-select"><a class="nav-item active" href="/">博客</a><a class="nav-item" href="/wiki/">项目</a><a class="nav-item" href="/notes/">笔记</a><a class="nav-item" href="/more/">更多</a></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/blog/" placeholder="文章搜索"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


<widget class="widget-wrapper toc single" id="data-toc"><div class="widget-header cap dis-select"><span class="name">创建对象之原型模式</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-text">1.与构造函数的不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B"><span class="toc-text">2. 理解原型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A3%80%E6%9F%A5%E5%AE%9E%E4%BE%8B%E5%8E%9F%E5%9E%8B"><span class="toc-text">3. 检查实例原型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-instanceof"><span class="toc-text">1. instanceof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-isPrototypeOf"><span class="toc-text">2. isPrototypeOf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Object-getPrototypeOf"><span class="toc-text">3. Object.getPrototypeOf()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Object-setPrototypeOf"><span class="toc-text">4. *Object.setPrototypeOf()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%B1%82%E7%BA%A7"><span class="toc-text">4.原型的层级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%A0%E9%99%A4%E5%AE%9E%E4%BE%8B%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">1.删除实例中的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%A4%E6%96%AD%E5%B1%9E%E6%80%A7%E5%9C%A8%E5%8E%9F%E5%9E%8B%E4%B8%8A%E8%BF%98%E6%98%AF%E5%9C%A8%E5%AE%9E%E4%BE%8B%E4%B8%8A"><span class="toc-text">2. 判断属性在原型上还是在实例上</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-hasOwnProperty"><span class="toc-text">1. hasOwnProperty()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-in"><span class="toc-text">2. in</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%A1%AE%E5%AE%9A%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%9F%90%E4%B8%AA%E5%B1%9E%E6%80%A7%E4%B8%8D%E5%9C%A8%E5%AE%9E%E4%BE%8B%E4%B8%8A%EF%BC%8C%E5%8F%AA%E5%9C%A8%E5%8E%9F%E5%9E%8B%E4%B8%8A"><span class="toc-text">3. 确定实例的某个属性不在实例上，只在原型上</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%8E%B7%E5%8F%96%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">4. 获取实例的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Object-keys-%E8%8E%B7%E5%8F%96%E5%AE%9E%E4%BE%8B%E4%B8%8A%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%88%E4%BB%85%E4%BB%85%E6%98%AF%E5%AE%9E%E4%BE%8B%E4%B8%8A%E5%8F%AF%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7%EF%BC%89"><span class="toc-text">1. Object.keys()获取实例上的属性（仅仅是实例上可枚举属性）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-for-in%E9%81%8D%E5%8E%86%E5%AE%9E%E4%BE%8B%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%8E%9F%E5%9E%8B%E4%B8%8A%E7%9A%84%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7%EF%BC%88%E4%BB%85%E4%BB%85%E6%98%AF%E5%8F%AF%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7%EF%BC%89"><span class="toc-text">2. for-in遍历实例以及其原型上的所有属性（仅仅是可枚举属性）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Object-getOwnPropertyNames-%E8%8E%B7%E5%8F%96%E4%BB%85%E4%BB%85%E6%98%AF%E5%AE%9E%E4%BE%8B%E4%B8%8A%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%88%E6%98%AF%E5%90%A6%E5%8F%AF%E6%9E%9A%E4%B8%BE%E9%83%BD%E8%83%BD%E8%8E%B7%E5%8F%96%EF%BC%89"><span class="toc-text">3.Object.getOwnPropertyNames()获取仅仅是实例上的属性（是否可枚举都能获取）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Object-getOwnPropertySymbols-%E4%BB%85%E4%BB%85%E9%92%88%E5%AF%B9%E7%AC%A6%E5%8F%B7%E9%92%88%E5%AF%B9%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%EF%BC%88%E6%98%AF%E5%90%A6%E6%9E%9A%E4%B8%BE%E9%83%BD%E5%8F%AF%E4%BB%A5%EF%BC%89"><span class="toc-text">4. Object.getOwnPropertySymbols() 仅仅针对符号针对实例属性（是否枚举都可以）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%B1%9E%E6%80%A7%E7%9A%84%E6%9E%9A%E4%B8%BE%E9%A1%BA%E5%BA%8F"><span class="toc-text">5. 属性的枚举顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%8E%9F%E5%9E%8B%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">6. 原型中存在的问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AC%E7%AF%87%E6%96%87%E7%AB%A0%E4%B8%AD%E7%95%99%E4%B8%8B%E6%9D%A5%E7%9A%84%E7%96%91%E9%97%AE"><span class="toc-text">本篇文章中留下来的疑问</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-constructor%E6%89%8B%E5%8A%A8%E8%B5%8B%E5%80%BC%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">1. constructor手动赋值的情况</span></a></li></ol></li></ol></div></div></widget>




</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/NollieLeo" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/logo-github.svg"/></a></div></footer>

    </aside>
    <div class='l_main'>
      

      


<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/Javascript/">Javascript</a></div><div id="post-meta">发布于&nbsp;<time datetime="2021-05-30T05:42:33.000Z">2021-05-30</time></div></div>

<article class='md-text content post'>
<h1 class="article-title"><span>创建对象之原型模式</span></h1>
<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p><strong>每一个函数都会创建一个prototype的属性</strong></p>
<p>原型方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;weng&#x27;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">23</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> per1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">ler per2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">per1.<span class="title function_">sayName</span>(); <span class="comment">// weng</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="1-与构造函数的不同"><a href="#1-与构造函数的不同" class="headerlink" title="1.与构造函数的不同"></a>1.与构造函数的不同</h2><p>原型模式是直接再构造函数的prototype属性上加对象和相应的属性（也就是再构造函数的原型对象上面加属性）</p>
<p>与构造函数不同的是，使用这种原型模式定义的属性和方法，之后创建出来的实例，都是一起共享这些属性的，因此</p>
<p>上述的per1和per2的sayName()函数指向的是同一个指针, 他们的原型也同样都是Person构造函数指向的原型对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per1.<span class="property">sayName</span> = per2.<span class="property">sayName</span>);</span><br></pre></td></tr></table></figure>



<h2 id="2-理解原型"><a href="#2-理解原型" class="headerlink" title="2. 理解原型"></a>2. 理解原型</h2><p>自定义构造函数的时候，原型对象，也就是构造函数的原型对象（prototype指向的对象），会自动获得一个constructor的属性，这个属性是重新指向自定义的构造函数，如果没有父类的话，其他的所有方法都是继承于js内部的Object对象的所有方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Person</span>; <span class="comment">// true;</span></span><br></pre></td></tr></table></figure>



<p>例如，根据上述的Person自定义构造函数创建一个实例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> per1 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br></pre></td></tr></table></figure>

<p>这个过程是这样的</p>
<ol>
<li>per1实例（对象）内部的[[Prototype]]指针就会被赋值为Person构造函数的原型对象（也就是Person.prototype）</li>
<li>per1可以访问Person的原型上所有属性</li>
</ol>
<blockquote>
<p>js脚本中是没有访问[[Prototype]]特性的标准方式，但是谷歌浏览器火狐还有safari会在每一个对象上暴露<code>__proto__</code>属性，这个属性可以直接访问构造函数的原型也就是这个实例的原型</p>
</blockquote>
<blockquote>
<p>但是，实例是和构造函数没有直接的联系的，只和构造函数的原型又关联</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> === per1.<span class="property">__proto__</span>); <span class="comment">// true;</span></span><br></pre></td></tr></table></figure>



<p><strong>Object的原型的原型是null</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Object</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>.<span class="property">__proto__</span> === <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/.com//image-20210530153200440.png" alt="1"></p>
<p>如图可以看出实例，构造函数，构造函数的原型之间的关系</p>
<p>这里比较<strong>重要</strong>的点在于</p>
<ol>
<li>构造函数的原型（Person.prototype）的constructor属性是指回Person构造函数的</li>
<li>实例和构造函数之间没有直接联系</li>
<li>所有通过同一个构造函数构建出来的实例，其中<code>[[Prototype]]</code>指针是指向构造函数的原型。</li>
</ol>
<h2 id="3-检查实例原型"><a href="#3-检查实例原型" class="headerlink" title="3. 检查实例原型"></a>3. 检查实例原型</h2><h3 id="1-instanceof"><a href="#1-instanceof" class="headerlink" title="1. instanceof"></a>1. instanceof</h3><p>由实例直接调用，去判断实例的原型链中是否有<strong>某个构造函数的原型</strong></p>
<blockquote>
<p>这里一定要注意，是判断某个构造函数的原型</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true;</span></span><br></pre></td></tr></table></figure>

<p>如第二大点的图1可以看清这样的继承关系，继承关系另一篇文章再说</p>
<h3 id="2-isPrototypeOf"><a href="#2-isPrototypeOf" class="headerlink" title="2. isPrototypeOf"></a>2. isPrototypeOf</h3><p>这个方法是为了确定两个对象之间原型的关系</p>
<p>因为如第2大点所说，不是所有的实现都对外暴露的<code>[[Prototype]]</code>的指针</p>
<p>所以可以直接在原型上去调用这个方法检测某个对象是否的<code>[[Prototype]]</code>的指针是否指向它，因此也能够检测出两个对象之间的关系</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(per1)); <span class="comment">// true;</span></span><br></pre></td></tr></table></figure>



<h3 id="3-Object-getPrototypeOf"><a href="#3-Object-getPrototypeOf" class="headerlink" title="3. Object.getPrototypeOf()"></a>3. Object.getPrototypeOf()</h3><p>这个方法会返回参数的内部<code>[[Prototype]]</code>的指针（这个<code>[[Prototype]]</code>也其实就是参数的特性，可以去一篇叫做对象的属性特性详解的文章查看）</p>
<p>这个函数传入一个 实例， 返回这个实例的原型对象，也就是它的构造函数的原型对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(per1)===<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(per1).<span class="property">name</span>; <span class="comment">// weng</span></span><br></pre></td></tr></table></figure>



<h3 id="4-Object-setPrototypeOf"><a href="#4-Object-setPrototypeOf" class="headerlink" title="4. *Object.setPrototypeOf()"></a>4. *Object.setPrototypeOf()</h3><p>这个方法可以给实例的<code>[[Prototype]]</code>指针写入一个新的值，这样可以重写一个实例的原型继承关系</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;weng&#x27;</span>;</span><br><span class="line">    <span class="attr">age</span>:<span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;kaimin&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeof</span>(b, a);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">name</span>) <span class="comment">// kaimin</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">age</span>) <span class="comment">// 23</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(b) === a); <span class="comment">// true;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里不推荐使用这种覆盖实例原型指向的方式改变原型继承的关系，会严重的影响代码的性能。</p>
<p>Mozilla文档中说的“在所有浏览器和js的引擎中，修改继承关系的影响都是微妙而且深远的。这种影响并不是执行以上这个代码那么简单，而是会涉及到所有访问了那些修改过 [[Prototype]]指向的实例的代码”</p>
</blockquote>
<p>因为有上述的弊端，可以看另外一篇文章，继承之原型式继承 中讲到的创建新对象的形式，也就是类似于<code>Object.create()</code>来创建一个新对象，同时给他指定一个原型，这块继承会在继承文章中详细解释</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;weng&#x27;</span>;</span><br><span class="line">    <span class="attr">age</span>:<span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Object</span>.<span class="title function_">create</span>(a);</span><br><span class="line">b.<span class="property">name</span> = <span class="string">&#x27;kaimin&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">name</span>) <span class="comment">// kaimin</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">age</span>) <span class="comment">// 23</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(b)) <span class="comment">// a</span></span><br></pre></td></tr></table></figure>

<p>Object.create这种形式其实是以匿名构造函数的形式，指定这个匿名函数的原型为你想要的那个实例，因为这里咱们只是在乎这个新创建的实例（这里指的是b）他的<code>[[Prototype]]</code>的指向是否是指向所需对象（这里指的是a）的，完全可以跳过显示创建构造函数的形式，使用这个方法不仅仅不会改变原来实例（这里指的是a）的<code>[[Prototype]]</code>指向，而且又让新实例的原型指向了a，就很棒，这里具体还是去继承那边文章看</p>
<h2 id="4-原型的层级"><a href="#4-原型的层级" class="headerlink" title="4.原型的层级"></a>4.原型的层级</h2><p>例如以下代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">BasePerson</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">country</span> = <span class="string">&#x27;China&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">23</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;weng&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">BasePersn</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> per1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">per1.<span class="property">address</span> = <span class="string">&#x27;fujian&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per1.<span class="property">age</span>) <span class="comment">// 23</span></span><br></pre></td></tr></table></figure>



<p>以上代码的各个关系如下图所示；</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/.com//image-20210530163634192.png" alt="image-20210530163634192"></p>
<p>这里比较重要的是<code>Person.prototype</code>，这里手动给他赋值给了new BasePerson()构造出来的实例，后面又手动的给把他的constructor属性赋值给了Person，这里为什么呢？本文最后会说明</p>
<p>之后呢，Person的原型对象中有了BasePerson构造函数内部初始化的时候的一些参数</p>
<p>按照这上面的层级关系</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">per1.<span class="property">name</span>; <span class="comment">// weng</span></span><br><span class="line">per1.<span class="property">address</span>; <span class="comment">// fujian</span></span><br><span class="line">per1.<span class="property">age</span>; <span class="comment">// 23</span></span><br></pre></td></tr></table></figure>

<p>这里其实都是可以访问到的</p>
<p>在通过实例访问属性的时候，会按这个属性的名称开始搜索，一层层往上走，一开始搜索实例本身是否有这些属性</p>
<p>，如果有就返回，如果没有继续通过 <code>[[Prototype]]</code>的指针向上搜索原型。</p>
<blockquote>
<p>constructor只存在于原型对象上面，其实也可以通过访问实例的原型指针来访问这个constructor</p>
</blockquote>
<p>如果有存在同名属性的话，实力上创建的会覆盖原型上的，但不至于改变原型上的同名属性，只是给他盖住看不见了</p>
<h3 id="1-删除实例中的属性"><a href="#1-删除实例中的属性" class="headerlink" title="1.删除实例中的属性"></a>1.删除实例中的属性</h3><p>delete操作符号可以删除实例上面定义的属性值，调用时候，这个实例的原型上的值不会被删除</p>
<p>要删除的话得直接在原型上做操作</p>
<p>例如上面的代码构建的实例per1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> per1.<span class="property">address</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per1.<span class="property">address</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>通过删除实例上的属性，可能会暴露出原型上的同名属性，这里的话具体而论，那怎么判断这个属性是在原型上还是在实例上的呢？</p>
<h3 id="2-判断属性在原型上还是在实例上"><a href="#2-判断属性在原型上还是在实例上" class="headerlink" title="2. 判断属性在原型上还是在实例上"></a>2. 判断属性在原型上还是在实例上</h3><h4 id="1-hasOwnProperty"><a href="#1-hasOwnProperty" class="headerlink" title="1. hasOwnProperty()"></a>1. hasOwnProperty()</h4><p>这个方法可以用来判断某个属性是否在实例上面（这个函数不进入实例的原型中去搜索指定属性）</p>
<p>这个方法直接在实例上调用，继承至Object构造函数的原型对象，如果害怕实例的中有同名方法的话可以使用Object.prototype.hasOwnProperty.call(this)来调用</p>
<p>比如上面的per1实例在没有删除addrss的情况下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">per1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;address&#x27;</span>); <span class="comment">// true;</span></span><br><span class="line">per1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// true;</span></span><br><span class="line"></span><br><span class="line">per1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;age&#x27;</span>); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure>

<p>per1.age实际上返回的是这个实例原型上的age，hasOwnProperty是访问不到的</p>
<p>那如果要确定是否原型上有这个值呢？不用per1[‘….’]来判断</p>
<h4 id="2-in"><a href="#2-in" class="headerlink" title="2. in"></a>2. in</h4><p>in操作符有两种使用方式</p>
<ol>
<li>在for-in中使用</li>
<li>单独使用</li>
</ol>
<p>这里先说说单独使用in，下面得第5点说for-in</p>
<p>in操作符号可以通过对象访问指定属性时候返回true，<strong>无论是在原型上还是在实例上面，都可以访问的到</strong></p>
<p>例如上面的per1对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> per1); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;address&#x27;</span> <span class="keyword">in</span> per1); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;age&#x27;</span> <span class="keyword">in</span> per1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h3 id="3-确定实例的某个属性不在实例上，只在原型上"><a href="#3-确定实例的某个属性不在实例上，只在原型上" class="headerlink" title="3. 确定实例的某个属性不在实例上，只在原型上"></a>3. 确定实例的某个属性不在实例上，只在原型上</h3><p>结合第4大点的第二小点的两个操作符，可以确定一个函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hasPrototypeProperty</span>(<span class="params">object,name</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> !object.<span class="title function_">hasOwnProperty</span>(name) &amp;&amp; (name <span class="keyword">in</span> object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-获取实例的属性"><a href="#4-获取实例的属性" class="headerlink" title="4. 获取实例的属性"></a>4. 获取实例的属性</h3><h4 id="1-Object-keys-获取实例上的属性（仅仅是实例上可枚举属性）"><a href="#1-Object-keys-获取实例上的属性（仅仅是实例上可枚举属性）" class="headerlink" title="1. Object.keys()获取实例上的属性（仅仅是实例上可枚举属性）"></a>1. Object.keys()获取实例上的属性（仅仅是实例上可枚举属性）</h4><h4 id="2-for-in遍历实例以及其原型上的所有属性（仅仅是可枚举属性）"><a href="#2-for-in遍历实例以及其原型上的所有属性（仅仅是可枚举属性）" class="headerlink" title="2. for-in遍历实例以及其原型上的所有属性（仅仅是可枚举属性）"></a>2. for-in遍历实例以及其原型上的所有属性（仅仅是可枚举属性）</h4><h4 id="3-Object-getOwnPropertyNames-获取仅仅是实例上的属性（是否可枚举都能获取）"><a href="#3-Object-getOwnPropertyNames-获取仅仅是实例上的属性（是否可枚举都能获取）" class="headerlink" title="3.Object.getOwnPropertyNames()获取仅仅是实例上的属性（是否可枚举都能获取）"></a>3.Object.getOwnPropertyNames()获取仅仅是实例上的属性（是否可枚举都能获取）</h4><p>例如：</p>
<p>正常来说，一个实例的原型对象上的constructor属性都是不可以枚举的，是不能够通过1，2两个方法获取的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(keys); <span class="comment">// [...., &#x27;constructor&#x27;]</span></span><br></pre></td></tr></table></figure>



<h4 id="4-Object-getOwnPropertySymbols-仅仅针对符号针对实例属性（是否枚举都可以）"><a href="#4-Object-getOwnPropertySymbols-仅仅针对符号针对实例属性（是否枚举都可以）" class="headerlink" title="4. Object.getOwnPropertySymbols() 仅仅针对符号针对实例属性（是否枚举都可以）"></a>4. Object.getOwnPropertySymbols() 仅仅针对符号针对实例属性（是否枚举都可以）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> k1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;k1&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    [k1]: <span class="string">&#x27;helloworld&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o);</span><br><span class="line"><span class="comment">// [Symbol(k1)]</span></span><br></pre></td></tr></table></figure>





<h2 id="5-属性的枚举顺序"><a href="#5-属性的枚举顺序" class="headerlink" title="5. 属性的枚举顺序"></a>5. 属性的枚举顺序</h2><p>以上可以总结几种获取实例或者实例原型上的一些属性的方法</p>
<ol>
<li>for-in</li>
<li>Object.keys()</li>
<li>Object.getOwnPropertyNames()</li>
<li>Object.getOwnPropertySymbols();</li>
</ol>
<p>这里涉及到获取属性的顺序，还有一个Object.assign这类浅层复制对象的方式</p>
<p><strong>for-in以及Object.keys()获取到的属性值的顺序是确定的</strong>，取决于js的引擎</p>
<p>Object.getOwnPropertyNames()，Object.getOwnPropertySymbols(); 以及Object.assign得出来的属性的枚举顺序都是确定的。</p>
<p>按照以下规则：</p>
<ol>
<li>先升序枚举数值键</li>
<li>以插入顺序枚举字符串和符号键</li>
<li>对象字面量中定义的键，以逗号分隔的顺序插入</li>
</ol>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> k1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;k1&#x27;</span>), k2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;k2&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">first</span>:<span class="string">&#x27;first&#x27;</span>,</span><br><span class="line">    [k1]:<span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">    <span class="attr">second</span>:<span class="string">&#x27;second&#x27;</span>,</span><br><span class="line">    <span class="number">0</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">o[k2] = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">o[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">o.<span class="property">third</span> = <span class="string">&#x27;third&#x27;</span>;</span><br><span class="line">o[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="number">0</span>));</span><br><span class="line"><span class="comment">// [&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;first&quot;,&quot;second&quot;,&quot;third&quot;];</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(o));</span><br><span class="line"><span class="comment">// [Symbol(k1),Symbol(k2)];</span></span><br></pre></td></tr></table></figure>


<h2 id="6-原型中存在的问题"><a href="#6-原型中存在的问题" class="headerlink" title="6. 原型中存在的问题"></a>6. 原型中存在的问题</h2><ol>
<li>弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值</li>
<li>原型上引用值属性的问题</li>
</ol>
<p>第一点是显而易见的</p>
<p>第二点中举个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">arr</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> per1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> per2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">per1.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per2.<span class="property">arr</span>) <span class="comment">// [1,2,3,4, 5];</span></span><br></pre></td></tr></table></figure>

<p>引用类型的arr定义在原型上，这时候对per1上的arr属性进行修改，因为per1实例上不存在arr的属性，那么会找到原型中的arr，这时候通过arr.push是直接作用在原型中的arr的，所以，引用类型属性之间的共享特性导致per2.arr访问的也是原型上的arr，意思就是引用类型访问的都是一个指针，就特么和对象一样。</p>
<h1 id="本篇文章中留下来的疑问"><a href="#本篇文章中留下来的疑问" class="headerlink" title="本篇文章中留下来的疑问"></a>本篇文章中留下来的疑问</h1><h2 id="1-constructor手动赋值的情况"><a href="#1-constructor手动赋值的情况" class="headerlink" title="1. constructor手动赋值的情况"></a>1. constructor手动赋值的情况</h2><p>以上第4大点中的层级关系代码中，手动将原型中的constructor赋值给了Person</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">BasePerson</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">country</span> = <span class="string">&#x27;China&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">23</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;weng&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">BasePersn</span>();</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> per1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">per1.<span class="property">address</span> = <span class="string">&#x27;fujian&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per1.<span class="property">age</span>) <span class="comment">// 23</span></span><br></pre></td></tr></table></figure>

<p>因为在这个例子中，Person.prototype被手动设置为一个BasePerson构建函数构建出来的新实例，这个过程相当于重写了Person构造函数的原型，这样重写之后，Person.prototype就不再指向自身的Person，由本文开头说的一样，函数构建的时候会默认创建原型，也就是prototype对象，也会自动给原型的contructor赋值，这个写法完全覆盖了默认的prototype，造成了constructor不再指向自身的构造函数，而是指向了Object构造函数Object(){}</p>
<p>这个时候就不在能够通过constructor属性来识别是什么类型了，还是得用instanceof</p>
<p>再比如下面的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;weng&#x27;</span>,</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">sayName</span>(); <span class="comment">// 报错，sayName is not a function</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是为什么呢？</p>
<p>由于f实例是在重写Person原型之前就已经构建出来了的，它的[[Prototype]]指针指向的原型对象是一开始Person构造函数所指向的，那本身就不存在sayName这个方法，这时候Person的原型被覆盖了，和f一点关系都没有；</p>
<p>这就解释了为什么不能用实例访问constructor来判断类型标识了得用intanceof</p>
<p>那这时候来解决上面手动赋值constructor的问题</p>
<p>如果constructor的值很重要，可以在上述代码中加入</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: <span class="title class_">Person</span>,</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;weng&#x27;</span>,</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可</p>
<p>但是又存在个问题</p>
<p>咱们知道原型上的constructor的属性是不可枚举的，也就是constructor本身这个属性的特性<code>[[Enumberable]]</code>特性是false，但是这样定义的constructor属性是可以枚举的，那这个时候可以看看 那篇 对象属性特性的文章，然后定义这个属性</p>


<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2021/05/30/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">算法之滑动窗口</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2021/05/28/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F/">创建对象之构造函数模式</a></div></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本站由 <a href="/">@anonymity</a> 使用 <a href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.18.5';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
