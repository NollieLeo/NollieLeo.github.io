---
title: 防抖动和节流
date: 2020-05-03 14:27:27
tags:
- 防抖动
- 节流
- js
categories: 
- js
---
**场景：**

在页面中很多的事件是会频繁执行的、如：

1. window的resize，scroll事件
2. 拖拽过程中的 mousemove事件
3. 文字输入过程中的keyup等事件

这些事件一旦触发会频繁执行、但是实际上我们可能只需要在特定的时候去执行绑定了这些事件的函数

例如：我需要检测一次拖拉浏览器，移动过程中都算是一次，知道最后鼠标抬起来了，才算是完成了一次拉伸窗口；有比如，我们输入搜索框内的文字的时候，需要发ajax 到后台去请求数据，实际上我们并不需要每一次的输入都发送一个请求，而是在用户已经输完了一整段话或者是几个文字之后再去发送一个ajax，这样会节省很多的资源开销 。等等的这些问题都需要函数防抖动或者函数节流来解决

## 防抖（debounce）

> 当我们调用一个动作的时候，会设置在n毫秒后才执行，而在这n毫秒内，如果这个动作再次被调用的话则将重新在计算n毫秒，采取执行这个东西。 

例如：

```html
<body>
  <style>
    #container {
      width: 200px;
      height: 300px;
      background-color: aquamarine;
    }
  </style>
  <div id="container">

  </div>
  <script>
    var count = 1;
    var containerDom = document.getElementById('container');
    function addNumber() {
      containerDom.innerHTML = count++;
    }
    containerDom.onmousemove = addNumber;

  </script>
</body>

```

鼠标只要移动那么就会频繁的去触发addNumber的函数

 ![debounce](debounce.gif) 

这个时候我们对他进行防抖动

先写我们的第一版函数

```javascript
function debounce(fun, wait) {
  var time;
  return function () {
    clearTimeout(time);
    time = setTimeout(fun, wait);
  }
}
```

之后包裹住这个addnumber的函数

现在随你怎么移动，反正你移动完 1000ms 内不再触发，我才执行事件。看看使用效果：

 ![debounce 第一版](debounce-1.gif) 

 顿时就从 165 次降低成了 1 次! 

之后我们对他优化

### this指向优化

如果我们再addNumber函数中加入`console.log(this)`，没有再addNumber外层包裹debounce的时候this指向是

```html
<div id="container"></div>
```

但是包裹了debounce之后this就会指向windows对象

所以需要对它进行修改

```javascript
var count = 0;
var containerDom = document.getElementById('container');
function addNumber() {
  containerDom.innerHTML = `<div>
  值为${++count}
  </div>`;
  console.log(this);
}
function debounce(fun, wait) {
  var time;
  return function () {
    var that = this;
    clearTimeout(time);
    time = setTimeout(function () {
      fun.apply(that);
    }, wait);
  }
}
containerDom.onmousemove = debounce(addNumber, 1000);
```

但是这里又有一个问题，就是这样包裹debounce的时候，onmousemove自带的事件对象event就会丢失，没有将参数传进去，故我们需要修改一哈，这样再我们需要用到event对象的时候就能拿得到

![](image-20200503153245577.png)

```javascript
var count = 0;
var containerDom = document.getElementById('container');
function addNumber(e) {
  containerDom.innerHTML = `<div>
  值为${++count}
  </div>`;
  console.log(this);
  console.log(e);
}
function debounce(fun, wait) {
  var time;
  return function () {
    var that = this, args = arguments;
    clearTimeout(time);
    time = setTimeout(function () {
      fun.apply(that, args);
    }, wait);
  }
}
containerDom.onmousemove = debounce(addNumber, 1000);
```

这个时候我们函数就非常的完善了。

### 第一次立刻执行

我不希望非要等到事件停止触发之后才执行，我希望立刻执行函数，然后再等到N秒之后再重新触发执行

这时候我们可以用一个immediate字段来标识是否需要第一次立刻执行

```javascript
function debounce(fun, wait, immediate) {
  var time;
  return function () {
    var that = this, args = arguments;
    if (time) clearTimeout(time);
    if (immediate) {
      // 如果已经执行过，不再执行
      var callNow = !time;
      time = setTimeout(function () {
        time = null
      }, wait);
      if (callNow) fun.apply(that, args);
    } else {
      time = setTimeout(function () {
        fun.apply(that, args);
      }, wait);
    }
  }
}
```

 ![debounce 第四版](https://github.com/mqyqingfeng/Blog/raw/master/Images/debounce/debounce-4.gif) 



## 节流

> 如果一个事件被频繁触发多次，节流函数可以按照固定频率去执行对应的事件处理方法。 函数节流保证一个事件一定时间内只执行一次。

以下有两种方法

### 使用时间戳

 使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。 

```javascript
let a = 0;
function addNumber(e) {
  document.getElementById('container').innerHTML = a++;
}

function throttle(func, wait) {
  var previous = 0;
  var context, args;
  return function () {
    var now = new Date();
    context = this;
    args = arguments;
    if (now - previous > wait) {
      func.apply(this, args);
      previous = now;
    }
  }
}

document.getElementById('container').onmousemove = throttle(addNumber, 1000);
```

 ![使用时间戳](throttle1.gif) 

我们可以看到：当鼠标移入的时候，事件立刻执行，每过 1s 会执行一次，如果在 4.2s 停止触发，以后不会再执行事件。



### 定时器

当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。

```javascript
function throttle2(func, wait) {
  var timeout = 0;
  var context, args;
  return function () {
    context = this;
    args = arguments;
    if (!timeout) {
      timeout = setTimeout(() => {
        timeout = null;
        func.apply(context, arguments);
      }, wait);
    }
  }
}
```



 ![使用定时器](throttle2.gif) 

我们可以看到：当鼠标移入的时候，事件不会立刻执行，晃了 3s 后终于执行了一次，此后每 3s 执行一次，当数字显示为 3 的时候，立刻移出鼠标，相当于大约 9.2s 的时候停止触发，但是依然会在第 12s 的时候执行一次事件。

所以比较两个方法：

1. 第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行
2. 第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件



### 两者结合

 鼠标移入能立刻执行，停止触发的时候还能再执行一次 

```javascript
function throttle3(func, wait) {
  var timeout, context, args, result;
  var previous = 0;

  var later = function () {
    previous = new Date();
    timeout = null;
    func.apply(context, args);
  }

  var throttled = function () {
    var now = new Date();
    // 下次触发func剩余的时间
    var remaining = wait - (now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      func.apply(context, args);
    } else if (!timeout) {
      timeout = setTimeout(later, remaining);
    }
  };
  return throttled;
}
```

 ![throttle3](throttle3.gif) 

我们可以看到：鼠标移入，事件立刻执行，晃了 3s，事件再一次执行，当数字变成 3 的时候，也就是 6s 后，我们立刻移出鼠标，停止触发事件，9s 的时候，依然会再执行一次事件。

### 优化

但是我有时也希望无头有尾，或者有头无尾，这个咋办？

那我们设置个 options 作为第三个参数，然后根据传的值判断到底哪种效果，我们约定:

leading：false 表示禁用第一次执行
trailing: false 表示禁用停止触发的回调

我们来改一下代码：

```javascript
// 第四版
function throttle(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};

    var later = function() {
        previous = options.leading === false ? 0 : new Date().getTime();
        timeout = null;
        func.apply(context, args);
        if (!timeout) context = args = null;
    };

    var throttled = function() {
        var now = new Date().getTime();
        if (!previous && options.leading === false) previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = now;
            func.apply(context, args);
            if (!timeout) context = args = null;
        } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
        }
    };
    return throttled;
}
```