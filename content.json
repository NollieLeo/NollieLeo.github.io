[{"title":"diff算法原理和总结","date":"2023-01-28T05:45:24.000Z","path":"2023/01/28/diff算法原理和总结/","text":"","tags":[{"name":"diff","slug":"diff","permalink":"https://github.com/NollieLeo/tags/diff/"},{"name":"vue","slug":"vue","permalink":"https://github.com/NollieLeo/tags/vue/"}]},{"title":"vue3渲染器设计与总结","date":"2022-12-03T11:39:37.000Z","path":"2022/12/03/vue3渲染器设计与总结/","text":"前置概念虚拟 domvdom，虚拟 dom 就是用来表示真实的 dom 元素的属性或者特点的一套数据结构，和真实 dom 一样具有树形结构，具有许多树形节点 vnode 可以简要的表示 const vnode = { type: &quot;h1&quot;, children: [ { type: &quot;h2&quot;, children: &quot;我是h2&quot;, }, ], }; 渲染器渲染器的基本作用就是把虚拟 dom 渲染为平台上面的真实 元素，浏览器上就是真实的 dom 元素。 挂载mounted，意思就是渲染器读取解析 vnode/vdom 属性之后，使用真实的 dom 形式并且表现在页面上/或者是具体的页面某个位置上 实现渲染器简单的渲染原理renderer: 渲染函数 就是通过 innerHTML 的形式将第一个参数 domString 插入到对应容器当中 function renderer(domString, container) { container.innerHTML = domString; } renderer(&quot;&lt;h1&gt;vue3 renderer&lt;/h1&gt;&quot;, document.getElementById(&quot;app&quot;)); 结合 reactivity引入 vue3 的 reactivity 包，他会在全局暴露一个 VueReactivity 变量 cdn 地址 &lt;script src=&quot;https://cdn.jsdelivr.net/npm/@vue/reactivity@3.2.45/dist/reactivity.global.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;module&quot;&gt; import { renderer } from &quot;./render.js&quot;; const { effect, ref } = VueReactivity; const count = ref(1); effect(() =&gt; { renderer( `&lt;h1&gt;vue3 renderer times: ${count.value}&lt;/h1&gt;`, document.getElementById(&quot;app&quot;) ); }); setTimeout(() =&gt; { count.value++; }, 2000); &lt;/script&gt; 通过引入 vue3 的 reactivity，我们能够实现一个动态渲染的基本逻辑 自定义渲染器 vue3 中的渲染器，是设计为通用可配置的，即可实现渲染到任意目标的平台上，我们目前说的目标平台，先指定浏览器；后续可以将一些可抽象的 API 抽离，使得渲染器的核心不依赖与浏览器的 api 这也就是 vue 的核心之一，将相关浏览器的 api 封装到了runtime-dom的一个包，提供了很多针对浏览器的 dom api，属性以及事件处理 工厂函数首先我们创建一个 createRenderer 的工厂函数用于创建一个渲染器, 并且抛出许多的方法 /** 创建一个渲染器 */ function createRenderer() { const render = (vnode, container) =&gt; { // ... }; // 后续会有各种方法 return { render }; } 之后进行相关的渲染调用 const renderer = createRenderer(); renderer.render(vNode, document.getElementById(&quot;app&quot;)); 加入更新的概念第一次调用 renderer.render(vNode, document.getElementById(&quot;app&quot;)); 第二次调用渲染的时候还是在同一个 container 上调用的 renderer.render(newVNode, document.getElementById(&quot;app&quot;)); 由于首次的渲染已经将对应的 dom 渲染到了 container 内部了，所以再次调用 render 函数的时候，渲染一个新的虚拟 dom，就单单是做一个简单的挂载的动作了，而是要进行更新对比，找出变动的节点，这个过程就叫做 - 打补丁（更新） 因此我们可以相关的改造一下代码： 引入一个更新的概念处理的逻辑 /** 创建一个渲染器 */ function createRenderer() { const render = (vnode, container) =&gt; { if (vnode) { // 新的node存在的情况，将其旧的vnode一起传递给patch函数进行补丁的更新 patch(container._vnode, vnode, container); } else { if (container._vnode) { // 旧的vnode存在，新的vnode不存在的情况，说明是一个 unmount（卸载）的操作 // 这里只需要将container内dom清空就可以, 目前暂时这样清空 container.innerHTML = &quot;&quot;; } } // 每一次都需要保存上一次的vnode，存储在container下 container._vnode = vnode; // 暂时使用这段代码清空，后续会完善 }; return { render }; } patch 简单实现其中 patch 的函数，是最最重要的一个渲染器的核心，主要是做初始化和相关的 diff 操作 目前进行简单实现，后续着重说 /** 更新对比 */ function patch(n1, n2, container) { // 如果不存在 if (!n1) { mountElement(n2, container); } else { // n1存在的情况下面，我们进行更新（打补丁） } } n1: 老的 vnode n2: 新的 vnode container: 容器 如果不存在旧的 vnode 的情况下，说明只是需要进行元素的挂载即可 实现 mountElement 挂载/** 挂载 */ function mountElement(vnode, container) { // 创建dom元素 const el = document.createElement(vnode.type); //处理子节点, 如果子节点是字符串，代表元素具有文本节点 if (typeof vnode.children === &quot;string&quot;) { // 只需要设置元素的textContent的属性即可 el.textContent = vnode.children; } // 将元素添加到容器中 container.appendChild(el); } 通过 vnode 的 type 标签名称创建一个新的 dom 元素，接着处理 children，如果是字符串的类型，说明是文本的 child 节点，直接设置 textContent 就可以了，之后 appendChild 插入容器当中 配置项形式抽离因为我们要设计一个相当于是不依赖于平台的一个通用渲染器，所以，需要将上述所用到的所有依赖于浏览器的 api 都给抽离出来，实现独立封装的配置项 例如，我们抽离mountElement函数使用到的一些浏览器方法 /** 浏览器端的相关api */ const BROWSER_APIS = { // 用于创建元素 createElement(tag) { return document.createElement(tag); }, /** 用于设置元素的文本节点 */ setElementText(el, text) { el.textContent = text; }, /** 给特定的parent下添加指定的元素 */ insert(el, parent, anchor = null) { parent.insertBefore(el, anchor); }, }; export default BROWSER_APIS; 之后我们改造createRenderer函数 将相关的 api 以 options 的形式传入 /** 创建一个渲染器 */ function createRenderer(options) { const { createElement, insert, setElementText } = options; /** 挂载 */ function mountElement(vnode, container) { // ... } /** 更新对比 */ function patch(n1, n2, container) { // ... } /** 渲染方法 */ const render = (vnode, container) =&gt; { // ... }; return { render }; } export { createRenderer }; 之后我们就可以通过传递进来的可配置的 apis 去实现相关的渲染器操作 例如，我们可以改造mountElement并且使用到相关的 apis /** 挂载 */ function mountElement(vnode, container) { // 创建dom元素 const el = createElement(vnode.type); // ➕ //处理子节点, 如果子节点是字符串，代表元素具有文本节点 if (typeof vnode.children === &quot;string&quot;) { // 只需要设置元素的textContent的属性即可 setElementText(e, vnode.children); // ➕ } // 将元素添加到容器中 insert(el, container); // ➕ } 通过了以上配置之后，渲染器将不仅仅可以在浏览器端进行使用，我们也可以根据不同的平台，传入不同的自定义的相关 api 参数 挂载和更新子节点挂载上述我们只考虑到了一个 vnode 的 children 为 string 的情况下的挂载，使用 setElementText 对元素进行挂载，但是 children 可能存在多个 vnode 非 string 类型的情况 例如：以下的 vnode，有两个子节点 const vNode = { type: &quot;div&quot;, children: [ { type: &quot;p&quot;, children: &quot;111&quot;, }, { type: &quot;p&quot;, children: &quot;222&quot;, }, ], }; 因此需要改造挂载函数，使其具有挂载子节点的能力。这里加入一层 children 节点的判断 /** 挂载函数调用 */ function mountElement(vnode, container) { // 创建dom元素 const el = createElement(vnode.type); //处理子节点, 如果子节点是字符串，代表元素具有文本节点 if (typeof vnode.children === &quot;string&quot;) { // 只需要设置元素的textContent的属性即可 setElementText(el, vnode.children); } else if (Array.isArray(vnode.children)) { // ➕ // 如果children是数组，则便遍历每一个字节点，然后调用patch的方法 vnode.children.forEach((child) =&gt; { patch(null, child, el); }); } // 将元素添加到容器中 insert(el, container); } 挂载节点的属性一个元素可以用多个属性来进行描述，当然映射到虚拟 dom 上的话，用一个 props 的属性进行表示。 const vNode = { type: &quot;div&quot;, props: { id: &quot;foo&quot;, }, children: [ { type: &quot;p&quot;, children: &quot;111&quot;, }, { type: &quot;p&quot;, children: &quot;222&quot;, }, ], }; 因此我们在挂载元素的时候，也需要将这些属性值渲染到对应的元素上面 改造挂载函数 /** 挂载函数调用 */ function mountElement(vnode, container) { // 创建dom元素 const el = createElement(vnode.type); //处理子节点, 如果子节点是字符串，代表元素具有文本节点 if (typeof vnode.children === &quot;string&quot;) { // 只需要设置元素的textContent的属性即可 setElementText(el, vnode.children); } else if (Array.isArray(vnode.children)) { // 如果children是数组，则便遍历每一个字节点，然后调用patch的方法 vnode.children.forEach((child) =&gt; { patch(null, child, el); }); } // 处理props, 存在的情况下进行处理 if (vnode.props) { // ➕ // 遍历 for (const key in vnode.props) { if (key in el) { const prop = vnode.props[key]; // 调用setAttribute将属性设置到元素上 el.setAttribute(key, prop); // 🌟 } } } // 将元素添加到容器中 insert(el, container); } 在标记“🌟“的地方，也可以使用 el[key] = vnode.props[key]，但是由于这都是属于直接操作 dom 对象的行为，所以都会存在缺陷，因此，我们需要想办法如何的正确设置元素的属性 🌟HTML attribute 和 DOM properties 区别HTML attribute 指的就是定义在 HMTL 标签上的属性 &lt;input id=&quot;my-input&quot; type=&quot;text&quot; value=&quot;foo&quot; /&gt; document 文档解析之后，会生成一个与之相符的 dom 元素对象，这个对象上面包含了很多的属性 {% image /Users/leo/Library/Application%20Support/marktext/images/2022-12-05-00-37-36-image.png '' '' %} 这些就是所谓的 dom property。 两者的区分大致如下 很多的 HTMl attribute 在 DOM 对象上面都有与之同名的 DOM properties，但是命名规则却不一样 例如：HTML attribute 的 class 对应的 dom property 就是 className 两者存在关联：例如上述设置了 HTML attribute 的 id 为‘foo’，那么对应的 DOM properties 当中存在相同属性名称为 id 也为 foo，两者可以当作直接映射的关系 并不是都存在直接直接映射关系：例如 value 属性，上述 input 设置了 value 值，但是在 DOM properties 对应的值不仅仅是 value，还有 defaultValue 值；如果后续在 input 框中输入了其他的 value 值 bar 然后我们再去读取其相关的 HTML Attribute 和 DOM properties 会发现 其实 HTML Attribute 只是做了一个初始值的赋值，但是却是对其他的 DOM property 也有相关影响 非法属性值会被浏览器校验处理掉：例如我们在 input 的 HTML attribute 上面设置了一个 type 等于一个‘foo‘的属性，那么会被浏览器自动处理掉。最终我们读取 DOM property 的时候，是被矫正之后的值 ‘text’ HTMl Atrribute 的作用就是设置与之对应的 DOM properties 的初始值 所以按照上述的 HTML attribute 和 DOM props 的区别，我们可以改造相关的 mountElement 的操作 /** 挂载函数调用 */ function mountElement(vnode, container) { // 创建dom元素 const el = createElement(vnode.type); console.log(el); //处理子节点, 如果子节点是字符串，代表元素具有文本节点 if (typeof vnode.children === &quot;string&quot;) { // 只需要设置元素的textContent的属性即可 setElementText(el, vnode.children); } else if (Array.isArray(vnode.children)) { // 如果children是数组，则便遍历每一个字节点，然后调用patch的方法 vnode.children.forEach((child) =&gt; { patch(null, child, el); }); } // 处理props, 存在的情况下进行处理 if (vnode.props) { // 遍历 for (const key in vnode.props) { const value = vnode.props[key]; // 获取props对应key的value // dom properties存在的情况 if (key in el) { el[key] = value; } else { // 设置的属性没有对应的DOM properties的情况，调用setAttribute将属性设置到元素上 el.setAttribute(key, value); } } } // 将元素添加到容器中 insert(el, container); } 正确的设置节点的属性浏览器会自动为我们解析 HTML 文件中的 dom 元素，以及相关的 props 的属性设置操作。 但是在 vue 中，因为用到了自身的模板文件，所以在解析相关的节点的时候需要自身处理这些属性的挂载操作 布尔类型属性处理例如下面这段 html 代码： &lt;button disabled /&gt; 在浏览器中会将其属性 disabled 自动矫正为 disabled=true 在目前的我们渲染器中，类似与等价于如下 vnode const vNode = { type: &quot;button&quot;, props: { disabled: &quot;&quot;, }, }; 最终在挂载的时候，会调用设置方法将空字符串 设置到 dom 属性上面。 类似于：el.disabled=&#39;&#39; 但是由于浏览器的自动矫正功能，会将我们的空字符串，自动矫正为 false，这就不符合用户的本意了。 因此我们要对这种 DOM attribute 布尔类型的属性，在赋值的时候加入一层判断 /** 挂载函数调用 */ function mountElement(vnode, container) { // 创建dom元素 // ... 省略代码 // 处理props, 存在的情况下进行处理 if (vnode.props) { // 遍历 for (const key in vnode.props) { const value = vnode.props[key]; // 获取props对应key的value // dom properties存在的情况 if (key in el) { // 获取这个DOM properties元素的属性类型 const type = typeof el[key]; // ➕ // 如果原生属性类型为布尔类型，并且value是空的字符串的话，给他值矫正为true if (type === &quot;boolean&quot; &amp;&amp; value === &quot;&quot;) { // ➕ el[key] = true; } else { // 其他情况 el[key] = value; } } else { // 设置的属性没有对应的DOM properties的情况，调用setAttribute将属性设置到元素上 el.setAttribute(key, value); } } } // 将元素添加到容器中 insert(el, container); } 只读类型属性处理DOM properties 当中还存在很多只读的属性，例如：form 如下例子： &lt;form id=&quot;form1&quot;&gt;&lt;/form&gt; &lt;input form=&quot;form1&quot; /&gt; 类似 form 这种 DOM properties 在所有的 form 控件上都是，只读的属性的，我们只能通过 setAttribute来设置他的属性，所以这时候还得要修改我们的逻辑，判断当前的属性在浏览器中是否是只读的，如果是匹配上这种只读的情况的属性，使用setAttribute来进行赋值 // 判断是否应该作为DOM properties的设置 function shouldSetAsProps(el, key, value) { // 对特殊只读属性的处理 if (key === &quot;form&quot; &amp;&amp; el.tagName === &quot;INPUT&quot;) return false; return key in el; } /** 挂载函数调用 */ function mountElement(vnode, container) { // 创建dom元素 // ... 省略代码 // 处理props, 存在的情况下进行处理 if (vnode.props) { // 遍历 for (const key in vnode.props) { const value = vnode.props[key]; // 获取props对应key的value // dom properties存在的情况 if (shouldSetAsProps(el, key, value)) { // 获取这个DOM properties元素的属性类型 const type = typeof el[key]; // 如果原生属性类型为布尔类型，并且value是空的字符串的话，给他值矫正为true if (type === &quot;boolean&quot; &amp;&amp; value === &quot;&quot;) { el[key] = true; } else { el[key] = value; } } else { // 设置的属性没有对应的DOM properties的情况，调用setAttribute将属性设置到元素上 el.setAttribute(key, value); } } } // 将元素添加到容器中 insert(el, container); } 提取平台无关代码我们将遍历 props 时候的 判断设值的代码，提取到 BROWSE_APIS 当中，作为浏览器端的方法，取名为patchProps /** 将属性设置相关的操作封装到patchProps的函数中，并作为渲染器选项传递 */ patchProps(el, key, preValue, nextValue) { // 判断是否应该作为DOM properties的设置 function shouldSetAsProps(el, key, value) { // 对特殊只读属性的处理 if (key === &quot;form&quot; &amp;&amp; el.tagName === &quot;INPUT&quot;) return false; // ...还有更多特殊处理情况todo return Object.hasOwnProperty.call(vnode.props, key); } // dom properties存在的情况 if (shouldSetAsProps(el, key, nextValue)) { // 获取这个DOM properties元素的属性类型 const type = typeof el[key]; // 如果原生属性类型为布尔类型，并且value是空的字符串的话，给他值矫正为true if (type === &quot;boolean&quot; &amp;&amp; nextValue === &quot;&quot;) { el[key] = true; } else { el[key] = nextValue; } } else { // 设置的属性没有对应的DOM properties的情况，调用setAttribute将属性设置到元素上 el.setAttribute(key, nextValue); } }, 最终在 mountElement 中就这样调用 /** 挂载函数调用 */ function mountElement(vnode, container) { // 创建dom元素 const el = createElement(vnode.type); console.log(el); //处理子节点, 如果子节点是字符串，代表元素具有文本节点 if (typeof vnode.children === &quot;string&quot;) { // 只需要设置元素的textContent的属性即可 setElementText(el, vnode.children); } else if (Array.isArray(vnode.children)) { // 如果children是数组，则便遍历每一个字节点，然后调用patch的方法 vnode.children.forEach((child) =&gt; { patch(null, child, el); }); } // 处理props, 存在的情况下进行处理 if (vnode.props) { // 遍历 for (const key in vnode.props) { patchProps(el, key, null, vnode.props[key]); // ➕ } } // 将元素添加到容器中 insert(el, container); } class 和 style 的处理在 vue 中，我们可以用 3 种方式去传递一个 class 的值 字符串 &lt;p class=&quot;foo bar&quot;&gt;&lt;/p&gt; 对象 &lt;p :class=&quot;{ foo:true, bar:false }&quot;&gt;&lt;/p&gt; 数组 &lt;p :class=&quot;[&#39;foo bar&#39;, {foo:true, bar:false }]&quot;&gt;&lt;/p&gt; 无论是何种结构，我们最终转化到 vNode 上面都是要成为一个字符串的 const vNode = { type: &quot;p&quot;, props: { class: &quot;foo bar&quot;, }, }; 因此在生成 vnode 的过程，我们需要调用 normalizeClass 的方法去转换 class const vNode = { type: &quot;p&quot;, props: { class: normalizeClass([ &quot;foo&quot;, { foo: false, bar: true, }, ]), }, }; 实现 normalizeClassnormalizeClass /** 格式化class */ function normalizeClass(value) { let res = &quot;&quot;; if (isString(value)) { res = value; } else if (isArray(value)) { // 类似数组 join(&#39; &#39;) for (let i = 0; i &lt; value.length; i++) { const normalized = normalizeClass(value[i]); if (normalized) { res += normalized + &quot; &quot;; } } } else if (isObject(value)) { for (const name in value) { if (value[name]) { res += name + &quot; &quot;; } } } return res.trim(); } 设置 class设置 dom class 属性的方式有多种，setAttribute, el.className, el.classList 其中el.className的性能最好因此我们改之我们的patchProps方法 /** 将属性设置相关的操作封装到patchProps的函数中，并作为渲染器选项传递 */ patchProps(el, key, preValue, nextValue) { // 判断是否应该作为DOM properties的设置 function shouldSetAsProps(el, key, value) { // ... } if (key === &quot;class&quot;) { // ➕ el.className = nextValue || &quot;&quot;; // ➕ } else if (shouldSetAsProps(el, key, nextValue)) { // ... } else { // ... } }, 当然 style 也是类似的处理方案，只不过在 vue 中调用的是normalizeStyle的方法 卸载操作上述说到，我们在 render 函数中使用了 container.innerHTML = &#39;&#39;的方式去清空卸载; /** 渲染方法 */ const render = (vnode, container) =&gt; { if (vnode) { // 新的node存在的情况，将其旧的vnode一起传递给patch函数进行补丁的更新 patch(container._vnode, vnode, container); } else { if (container._vnode) { // 旧的vnode存在，新的vnode不存在的情况，说明是一个 unmount（卸载）的操作 // 这里只需要将container内dom清空就可以 container.innerHTML = &quot;&quot;; // ✨ } } // 每一次都需要保存上一次的vnode，存储在container下 container._vnode = vnode; }; 这么做不严谨，原因如下： 容器的内容可能是某个组件或者多个渲染的，在卸载的时候应该去触发组件相关的卸载生命周期函数 自定义指令，没办法正确执行 dom 身上绑定的一些事件，不会进行移除 正确的卸载方式： 根据 vnode 对象获取其关联的真实 dom 元素 使用原生的 dom 移除操作将其移除 建立 dom 与 vnode 联系要想根据 vnode 对象获取其关联的真实 dom 元素，首先必须要先建立联系 在挂载阶段我们利用 createElement创建了真实的 dom，之后将其绑定在 vnode 上，这样就可以将 vNode 和真实 dom 之间的联系建立起来 /** 挂载函数调用 */ function mountElement(vnode, container) { // 创建dom元素 const el = createElement(vnode.type); console.log(el); vnode.el = el; // 将其创建出来的dom添加到vnode上，建立联系 ➕ //处理子节点, 如果子节点是字符串，代表元素具有文本节点 if (typeof vnode.children === &quot;string&quot;) { // ... } else if (Array.isArray(vnode.children)) { // ... } // 处理props, 存在的情况下进行处理 if (vnode.props) { // ... } // 将元素添加到容器中 insert(el, container); } 改造 render 函数/** 渲染方法 */ const render = (vnode, container) =&gt; { if (vnode) { // 新的node存在的情况，将其旧的vnode一起传递给patch函数进行补丁的更新 patch(container._vnode, vnode, container); } else { if (container._vnode) { // 旧的vnode存在，新的vnode不存在的情况，说明是一个 unmount（卸载）的操作 // 根据vnode获取要卸载的真实dom元素 const el = container._vnode.el; // ➕ // 获取el的父级元素 const parent = el.parentNode; // ➕ // 调用removeChild删除元素 if (parent) parent.removeChild(el); // ➕ } } // 每一次都需要保存上一次的vnode，存储在container下 container._vnode = vnode; }; 其中的 container._vnode 代表的就是旧的 vnode（即将要被卸载的），由于我们之前绑定上了相关的 dom 在 vnode 上，就可以调用其父级的移除元素的操作 封装 unmount将上述的卸载操作封装成一个 unmount 的函数，方便后续功能增加 unmount /** 卸载操作 */ function unmount(vnode) { // 根据vnode获取要卸载的真实dom元素 // 获取el的父级元素 const parent = vnode.el.parentNode; if (parent) { parent.removeChild(vnode.el); } } render const render = (vnode, container) =&gt; { if (vnode) { // 新的node存在的情况，将其旧的vnode一起传递给patch函数进行补丁的更新 patch(container._vnode, vnode, container); } else { if (container._vnode) { // 旧的vnode存在，新的vnode不存在的情况，说明是一个 unmount（卸载）的操作 unmount(container._vnode); // ➕ } } // 每一次都需要保存上一次的vnode，存储在container下 container._vnode = vnode; }; 区分 vnode 类型在 render 函数中，vnode 存在的情况下，会将老的 vnode 和新的 vnode 都传递给 patch 函数去做一个更新，当然是我们的 node 的类型都是相同的情况下，我们才有去做比较的意义。 比如： const vnode = { type: &quot;p&quot; }; //第一次渲染： const vnode = { type: &quot;input&quot; }; // 第二次渲染 这种情况就没有对比更新的一个必要了。 这种情况下： 先去卸载 p 元素 再将 input 挂载到容器中 因此我们需要改造 patch 的代码 /** 更新对比, 并且做挂载相关的功能 */ function patch(n1, n2, container) { // n1老节点存在，对比n1和n2的类型 if (n1 &amp;&amp; n1.type !== n2.type) { // ➕ // 如果新旧vnode的类型不同，则直接将旧的vnode卸载 unmount(n1); // ➕ n1 = null; // ➕ } // 如果不存在 if (!n1) { mountElement(n2, container); } else { // n1存在的情况下面，我们进行更新（打补丁） } } 这种情况都是 vnode 为普通标签元素的类型情况下，我们也可以稍微改造一些对组件类型等等的支持 /** 更新对比, 并且做挂载相关的功能 */ function patch(n1, n2, container) { // n1老节点存在，对比n1和n2的类型 if (n1 &amp;&amp; n1.type !== n2.type) { // 如果新旧vnode的类型不同，则直接将旧的vnode卸载 unmount(n1); n1 = null; } const { type } = n2; if (typeof type === &quot;string&quot;) { // 说明是普通的标签元素 if (!n1) { // 如果不存在, 就进行挂载 mountElement(n2, container); } else { // n1存在的情况下面，我们进行更新（打补丁） patchElement(n1, n2); } } else if (typeof type === &quot;object&quot;) { // 组件 } else { // 其他 } } 事件处理首先我们要在 vnode 中去描述事件，假定一个规则，以字符串 on 开头的都视作事件 const vnode = { type: &quot;p&quot;, props: { onClick: () =&gt; {}, }, children: &quot;text&quot;, }; 绑定事件和更新事件绑定和更新我们就需要在 patchProps 函数中做相关的处理 /** 将属性设置相关的操作封装到patchProps的函数中，并作为渲染器选项传递 */ patchProps(el, key, preValue, nextValue) { // 匹配事件，以on开头 if (/^on/.test(key)) { // ➕ // 根据属性名称得到对应的事件名称 const name = key.slice(2).toLowerCase(); // ➕ // 移除上一次绑定的事件处理函数 prevValue &amp;&amp; el.removeEventListener(name, prevValue); // ➕ // 绑定事件, nextvalue为事件函数 el.addEventListener(name, nextValue); // ➕ } else if (key === &quot;class&quot;) { // ... } else if (shouldSetAsProps(el, key, nextValue)) { // ... } else { // ... } } 按如上的逻辑，就是相当于每次更新都要去移除之前绑定的函数，然后再对新的值重新进行监听。但是这么做性能并不是最优的。 我们可以绑定一个伪造的事件处理函数 invoker，然后把真正的事件处理函数设置为 invoker.value，后续更新值的时候，我们只需要更新 invoker.value 值就可以 /** 将属性设置相关的操作封装到patchProps的函数中，并作为渲染器选项传递 */ function patchProps(el, key, prevValue, nextValue) { // 匹配事件，以on开头 if (/^on/.test(key)) { // 定义el.vei为一个对象，存在事件名称到事件处理函数的映射 const invokers = el._vei || (el._vei = {}); // 获取该元素伪造的事件处理函数, 根据key let invoker = invokers[key]; // 根据属性名称得到对应的事件名称 const name = key.slice(2).toLowerCase(); if (nextValue) { if (!invoker) { // 如果没有invoker，为首次监听，则去伪造一个缓存到el.vei中 invoker = el._vei[key] = (e) =&gt; { // 如果invoker是数组的情况，需要遍历执行 if (Array.isArray(invoker.value)) { invoker.value.forEach((fn) =&gt; fn(e)); } else { // 这里才是处理真正的事件函数 invoker.value(e); } }; // 赋值事件处理函数到invoker的value上 invoker.value = nextValue; // 绑定invoker el.addEventListener(name, invoker); } else { // 存在invoker说明是更新，只需要更新invoker.value值就行 invoker.value = nextValue; } } else if (invoker) { // 新的事件函数不存在，需要销毁invoker el.removeEventListener(name, invoker); } } else if (key === &quot;class&quot;) { // ... } else if (shouldSetAsProps(el, key, nextValue)) { // .... } else { // ... } } invokers：存事件名称与对应函数的映射 el._vei：vue event invoker，在 el 上缓存 invoker 更新属性以及子节点 更新必定涉及到整个 vnode 上面的属性的变化，包括节点的属性以及节点的子节点的变化 元素的挂载是由 mountElement 触发的 /** 挂载函数调用 */ function mountElement(vnode, container) { // 创建dom元素 const el = createElement(vnode.type); console.log(el); vnode.el = el; // 将其创建出来的dom添加到vnode上，建立联系 //处理子节点, 如果子节点是字符串，代表元素具有文本节点 if (typeof vnode.children === &quot;string&quot;) { // 只需要设置元素的textContent的属性即可 setElementText(el, vnode.children); } else if (Array.isArray(vnode.children)) { // 如果children是数组，则便遍历每一个字节点，然后调用patch的方法 vnode.children.forEach((child) =&gt; { patch(null, child, el); }); } // 处理props, 存在的情况下进行处理 if (vnode.props) { // 遍历 for (const key in vnode.props) { patchProps(el, key, null, vnode.props[key]); } } // 将元素添加到容器中 insert(el, container); } 在挂载子节点的时候，首先有两种的类型的区分 字符串：具有文本的子节点 数组：多个子节点 总的来说，子节点分为 3 种类型： 没有子节点的情况 vnode = { type: &quot;div&quot;, children: null, }; 字符串的情况 vnode = { type: &quot;div&quot;, children: &quot;222&quot;, }; 数组的情况 vnode = { type: &quot;div&quot;, children: [&quot;111&quot;, { type: &quot;p&quot; }], }; 对应到更新的时候，我们对应的新旧节点都分别是 3 种情况 接下来我们去实现 patchElement函数 n1: 旧 vnode n2: 新 vnode 实现步骤 首先我们去更新他们的 props 的变化，调用之前封装好的 patchProps 函数做更新变化 之后去更新他们的 children，这里要对以上 9 种的情况进行覆盖。 实现 props 变化更新实现 props 的更新 从新的 props 参数中找出旧的 props 中与之对应的 key value，调用 pacthProps 方法对 dom 元素进行对比更新 从旧的 props 中找出不存在新 props 中的属性，调用 pacthProps 的方法进行 dom 属性的卸载 /** 更新子节点 */ function pacthElement(n1, n2) { n2.el = n1.el; const el = n2.el; const { props: oldProps } = n1; const { props: newProps } = n2; // step 1 更新props for (const key in newProps) { if (newProps[key] !== oldProps[key]) { patchProps(el, key, oldProps[key], newProps[key]); } } for (const key in oldProps) { if (!(key in newProps)) { patchProps(el, key, oldProps[key], null); } } // step 2：更新children pacthChildren(n1, n2, el); } 顺手改造 patchProps 函数我们依据 patchProps 的各个分支，去相对应封装我们的更新方法 最终的改造如下 // 比对props做更新 const patchProp = (el, key, prevValue, nextValue) =&gt; { if (key === &quot;class&quot;) { // class的处理 patchClass(el, nextValue); } else if (key === &quot;style&quot;) { // style的处理 patchStyle(el, prevValue, nextValue); } else if (/^on[^a-z]/.test(key)) { // 事件的处理 patchEvent(el, key, nextValue); } else { // 其他属性的处理 patchAttr(el, key, nextValue); } }; 操作 class 更新/** 比对class属性 */ function patchClass(el, value) { // 根据最新值设置类名 if (value == null) { el.removeAttribute(&quot;class&quot;); } else { el.className = value; } } 操作样式的更新/** 比对class属性 */ function patchStyle(el, prev, next) { // 更新style const style = el.style; for (const key in next) { // 用最新的直接覆盖 style[key] = next[key]; } if (prev) { for (const key in prev) { // 老的有新的没有删除 if (next[key] == null) { style[key] = null; } } } } 操作事件的更新/** 创建一个invoker */ function createInvoker(initialValue) { const invoker = (e) =&gt; invoker.value(e); invoker.value = initialValue; return invoker; } /** 比对事件更新 */ function patchEvent(el, rawName, nextValue) { // 更新事件 const invokers = el._vei || (el._vei = {}); const exisitingInvoker = invokers[rawName]; // 是否缓存过 if (nextValue &amp;&amp; exisitingInvoker) { exisitingInvoker.value = nextValue; } else { const name = rawName.slice(2).toLowerCase(); // 转化事件是小写的 if (nextValue) { // 缓存函数 const invoker = (invokers[rawName] = createInvoker(nextValue)); el.addEventListener(name, invoker); } else if (exisitingInvoker) { el.removeEventListener(name, exisitingInvoker); invokers[rawName] = undefined; } } } 操作属性的更新/** 比对dom properties或者是html attributes */ function patchAttr(el, key, value) { // 更新属性 if (value == null) { // 如果值不存在，说明是卸载props的操作 el.removeAttribute(key); } else { if (shouldSetAsProps(el, key, nextValue)) { // dom properties存在的情况 // 获取这个DOM properties元素的属性类型 const type = typeof el[key]; // 如果原生属性类型为布尔类型，并且value是空的字符串的话，给他值矫正为true if (type === &quot;boolean&quot; &amp;&amp; nextValue === &quot;&quot;) { el[key] = true; } else { el[key] = nextValue; } } else { el.setAttribute(key, value); } } } 更新 children 节点对照以上 3*3 的节点情况 1. 新子节点是文本节点/** 更新children */ function pacthChildren(n1, n2, container) { // 判断新子节点的类型是否是文本节点 if (typeof n2.children === &quot;string&quot;) { // 当新节点为文本节点的时候，如果旧节点是一组子的节点，我们需要逐个去卸载，其他情况啥也不做 if (Array.isArray(n1.children)) { n1.children.forEach((node) =&gt; unmount(node)); } // 最后设置新的节点内容 setElementText(container, n2.children); } } 2. 新子节点是一组/** 更新children */ function pacthChildren(n1, n2, container) { // 判断新子节点的类型是否是文本节点 if (typeof n2.children === &quot;string&quot;) { // ... } else if (Array.isArray(n2.children)) { // 当新的子节点是一组 // 我们判断旧的子节点是否也是一组 if (Array.isArray(n1.children)) { // diff算法 todo } else { // 到这里，存在两种情况，要么是文本节点要么无 // 什么情况下都去清空，然后将一组新的子节点添加进来 setElementText(container, &quot;&quot;); n2.children.forEach((node) =&gt; patch(null, node, container)); } } } diff 算法，目前先用傻瓜逻辑实现，全部卸载然后再全部挂载 n1.children.forEach((node) =&gt; unmount(node)); n2.children.forEach((node) =&gt; patch(null, node, container)); 3. 新子节点啥也没有/** 更新children */ function pacthChildren(n1, n2, container) { // 判断新子节点的类型是否是文本节点 if (typeof n2.children === &quot;string&quot;) { // 当新节点为文本节点的时候，如果旧节点是一组子的节点，我们需要逐个去卸载，其他情况啥也不做 if (Array.isArray(n1.children)) { n1.children.forEach((node) =&gt; unmount(node)); } // 最后设置新的节点内容 setElementText(container, n2.children); } else if (Array.isArray(n2.children)) { // .... } else { // 到这里，说明新的子节点不存在 // 如果旧的节点是一组子节点，只需要逐个卸载就可以 if (Array.isArray(n1.children)) { n1.children.forEach((node) =&gt; unmount(node)); } else if (typeof n1.children === &quot;string&quot;) { // 旧节点是文本，清空 setElementText(container, &quot;&quot;); } // 其他情况不用管 } } 特殊节点类型一般我们用 vnode 描述节点，都是用 type 去描述节点类型 但是 像 文本节点 注释节点 以及 vue3 的 fragment，都较为特殊 &lt;Fragment&gt; &lt;!-- 注释节点 --&gt; 文本节点 &lt;/Fragment&gt; 文本节点和注释节点处理这两者对于普通标签节点来说，不具备标签名称，所以需要框架认为的去创造一些唯一的标识，并且将其作为注释节点和文本节点的 type 描述文本和注释节点： // 加入人为的文本节点标识 const Text = Symbol(); const newVnode = { type: Text, children: &quot;文本节点&quot;, }; // 加入人为的注释节点标识 const Comment = Symbol(); const newVnode = { type: Comment, children: &quot;注释的节点&quot;, }; 加入两者之后，我们需要在 patch 中去做相关的改造 /** 更新对比, 并且做挂载相关的功能 */ function patch(n1, n2, container) { // n1老节点存在，对比n1和n2的类型 if (n1 &amp;&amp; n1.type !== n2.type) { // 如果新旧vnode的类型不同，则直接将旧的vnode卸载 unmount(n1); n1 = null; } const { type } = n2; if (typeof type === &quot;string&quot;) { // .... } else if (typeof type === &quot;object&quot;) { // 组件 } else if (type === Text) { // 文本标签 if (!n1) { // 使用原生createTextNode去创建文本节点 const el = (n2.el = document.createTextNode(n2.children)); // 将文本节点插入到容器中 insert(el, container); } else { // 如果旧的vnode存在，只需要使用心得文本节点的文本内容更新旧文本节点就可以了 const el = (n2.el = n1.el); if (n2.children !== n1.children) { el.nodeValue = n2.children; } } } 当然上述用到了相关浏览器的 api 我们需要给他提取出来document.createTextNode以及el.nodeValue /** 浏览器端的相关api */ const BROWSER_APIS = { // 用于创建元素 createElement(tag) { // ... }, /** 用于设置元素的文本节点 */ setElementText(el, text) { // ... }, /** 给特定的parent下添加指定的元素 */ insert(el, parent, anchor = null) { // ... }, /** 创建文本节点 */ createText(text) { // ➕ return document.createTextNode(text); }, /** 设置文本值 */ setText(el, text) { // ➕ el.nodeValue = text; }, /** 将属性设置相关的操作封装到patchProps的函数中，并作为渲染器选项传递 */ patchProps(el, key, prevValue, nextValue) { // ... }, }; 处理注释的节点和其类似，调用原生的 document.createComment函数来创建即可 FragmentFragment 和 tex 以及注释类似，type 也需要人为加入标识 const Fragment = Symbol(); 在项目中经常会有类似这样的 vNode， const vNode = { type: &quot;ul&quot;, children: [ { type: Fragment, children: [ { type: &quot;li&quot;, children: &quot;1&quot;, }, { type: &quot;li&quot;, children: &quot;2&quot;, }, ], }, ], }; 由于 Fragment 本身是不属于一个真正的节点的，所以在做渲染的时候，我们只需要渲染它的子节点就可以了 因此我们改造 patch 函数 /** 更新对比, 并且做挂载相关的功能 */ function patch(n1, n2, container) { // n1老节点存在，对比n1和n2的类型 if (n1 &amp;&amp; n1.type !== n2.type) { // 如果新旧vnode的类型不同，则直接将旧的vnode卸载 unmount(n1); n1 = null; } const { type } = n2; if (typeof type === &quot;string&quot;) { // ... } else if (typeof type === &quot;object&quot;) { // 组件 } else if (type === Text) { // ... } else if (type === Fragment) { // 如果是 片段节点 if (!n1) { // 如果不存在旧节点的话，只需要将Fragment的children逐个挂载就可以 n2.children.forEach((node) =&gt; patch(null, node, container)); } else { // 如果旧的vnode存在的话， 则只需要更新fragment的children就可以 pacthChildren(n1, n2, container); } } } 并且对于我们在卸载的时候，也要做相关的处理 /** 卸载操作 */ function unmount(vnode) { // 在卸载的时候，如果是卸载的vnode类型为Fragment， 则需要卸载他的children if (vnode.type === Fragment) { vnode.children.forEach((node) =&gt; unmount(node)); return; } // 根据vnode获取要卸载的真实dom元素 // 获取el的父级元素 const parent = vnode.el.parentNode; if (parent) { parent.removeChild(vnode.el); } } 后面再说 diff diff 算法// todo…. 简单的 diff 算法双端 diff 算法快速 diff 算法","tags":[{"name":"diff","slug":"diff","permalink":"https://github.com/NollieLeo/tags/diff/"},{"name":"vue","slug":"vue","permalink":"https://github.com/NollieLeo/tags/vue/"}]},{"title":"双击事件和单机事件冲突解决方案","date":"2022-11-09T06:37:20.000Z","path":"2022/11/09/双击事件和单机事件冲突解决方案/","text":"双击事件（dblclick）时，不触发单击事件(click)事件绑定中，执行双击事件(dblclick)时能触发两次单击事件(click)。即一个标签元素（如button等），如果元素同时绑定了单击事件(click)和双击事件(dblclick),那么执行单击事件(click)时，不会触发双击事件(dblclick)， 执行双击事件(dblclick)时却会触发两次单击事件(click)。 执行顺序单击(click)：mousedown，mouseout，click；双击(dblclick)：mousedown，mouseout，click ， mousedown，mouseout，click，dblclick； 在单击的时候不会执行双击，但是双击的时候会执行两次单击再执行双击事件。解决的思路：使用定时器清除掉两个单击事件，留下一个双击事件。 setTimeout code 然后现在，单击按钮打印“单击”，双击按钮打印“双击”。 关于 time=200，大家知道js的事件循环机制，点击事件会添加一个任务队列。time=0， 也会添加一个任务队列。那么time=0与time=200有什么区别呢？ 因为第一次单击事件后，主线程没有任何任务，就会立马执行这个单击事件的任务。待第二次单击的时候，假设距离第一次单击事件是150ms, 如果你的定时器小于150ms, 那么第一次的任务队列就会执行完。要想不执行第一次的任务队列，那么定时器时间间隔就必须大于两次单击的时间间隔了。所以，这个200是酌情值，大于间隔就行。 第一次单击任务不执行了，是被定时器延时，然后第二次点击的时候给清除了。那么第二次点击事件呢？在两次单击之后，会立马执行一个双击事件，双击事件的一开头就把这个第二次点击事件给清除了。 这就是双击事件的大概过程。","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"}]},{"title":"vite学习记录","date":"2022-11-03T02:37:51.000Z","path":"2022/11/03/vite学习记录/","text":"vite前置知识 no-bundle：利用浏览器原生 ES 模块的支持，实现开发阶段的 Dev Server，进行模块的按需加载，而不是先整体打包再进行加载。 import：vite中的一个 import 语句代表一个 HTTP 请求 初始化模板 这里我们采用pnpm和vite，当然需要全局安装一下。学习记录中使用的是react + ts技术栈 pnpm create vite 初始化之后的文件格式是 ├── index.html ├── package.json ├── pnpm-lock.yaml ├── src │ ├── App.css │ ├── App.tsx │ ├── favicon.svg │ ├── index.css │ ├── logo.svg │ ├── main.tsx │ └── vite-env.d.ts ├── tsconfig.json └── vite.config.ts index.html：入口文件，vite会默认把根目录下的index.html作为打包入口 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/vite.svg&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Vite + React + TS&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script type=&quot;module&quot; src=&quot;/src/main.tsx&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 这段代码代表了我们脚本文件的入口，使用type=”module”的ES模块加载的模式，当我们访问项目的时候会去通过本地的去请求main.tsx文件 &lt;script type=&quot;module&quot; src=&quot;/src/main.tsx&quot;&gt;&lt;/script&gt; main.tsx: 入口文件引用的脚本文件 修改入口文件位置 一般来说项目的入口文件，可能随着项目的变化而改动 例如我们将入口文件改到 src的根下； 要注意两个点： 相对路径 path包要注意ts类型报错 你需要通过 pnpm i @types/node -D 安装类型 tsconfig.node.json 中设置 allowSyntheticDefaultImports: true，以允许下面的 default 导入方式 // vite.config.ts // vite.config.ts import { defineConfig } from &#39;vite&#39; // 引入 path 包注意两点: // 1. 为避免类型报错，你需要通过 `pnpm i @types/node -D` 安装类型 // 2. tsconfig.node.json 中设置 `allowSyntheticDefaultImports: true`，以允许下面的 default 导入方式 import path from &#39;path&#39; import react from &#39;@vitejs/plugin-react&#39; export default defineConfig({ // 手动指定项目根目录位置 root: path.join(__dirname, &#39;src&#39;) plugins: [react()] }) // tsconfig.node.json { &quot;compilerOptions&quot;: { &quot;composite&quot;: true, &quot;module&quot;: &quot;ESNext&quot;, &quot;moduleResolution&quot;: &quot;Node&quot;, // 以允许 node相关的默认 导入方式 &quot;allowSyntheticDefaultImports&quot;: true }, &quot;include&quot;: [&quot;vite.config.ts&quot;] } 默认指令&quot;scripts&quot;: { // 开发阶段启动 Vite Dev Server &quot;dev&quot;: &quot;vite&quot;, // 生产环境打包 &quot;build&quot;: &quot;tsc &amp;&amp; vite build&quot;, // 生产环境打包完预览产物 &quot;preview&quot;: &quot;vite preview&quot; }, “dev”: 通过启动vite的Dev Server，在开发阶段实现不打包的特性 “build”: 因为当前初始化模板选用的是ts，所以在真正的使用vite打生产包的时候，要编译 TypeScript 代码并进行类型检查 此从用到的时候tsc，是TypeScript 的官方编译命令。在tsconfig.ts文件中其实有这样的配置 { &quot;compilerOptions&quot;: { // 省略其他配置 // 1. noEmit 表示只做类型检查，而不会输出产物文件 // 2. 这行配置与 tsc --noEmit 命令等效 &quot;noEmit&quot;: true, }, } 在vue的项目中，我们就得使用到 vue-tsc “preview”: 预览打包产物的执行效果。 css相关改造点样式方案的意义原生 CSS 开发的各种问题 开发体验欠佳。比如原生 CSS 不支持选择器的嵌套: // 选择器只能平铺，不能嵌套 .container .header .nav .title .text { color: blue; } .container .header .nav .box { color: blue; border: 1px solid grey; } 样式污染问题。如果出现同样的类名，很容易造成不同的样式互相覆盖和污染。 // a.css .container { color: red; } // b.css // 很有可能覆盖 a.css 的样式！ .container { color: blue; } 浏览器兼容问题。为了兼容不同的浏览器，我们需要对一些属性(如transition)加上不同的浏览器前缀，比如 -webkit-、-moz-、-ms-、-o-，意味着开发者要针对同一个样式属性写很多的冗余代码。 打包后的代码体积问题。如果不用任何的 CSS 工程化方案，所有的 CSS 代码都将打包到产物中，即使有部分样式并没有在代码中使用，导致产物体积过大。 针对如上原生 CSS 的痛点，社区中诞生了不少解决方案，常见的有 5 类。 CSS 预处理器：主流的包括Sass/Scss、Less和Stylus。这些方案各自定义了一套语法，让 CSS 也能使用嵌套规则，甚至能像编程语言一样定义变量、写条件判断和循环语句，大大增强了样式语言的灵活性，解决原生 CSS 的开发体验问题。 CSS Modules：能将 CSS 类名处理成哈希值，这样就可以避免同名的情况下样式污染的问题。 CSS 后处理器PostCSS，用来解析和处理 CSS 代码，可以实现的功能非常丰富，比如将 px 转换为 rem、根据目标浏览器情况自动加上类似于–moz–、-o-的属性前缀等等。 CSS in JS 方案，主流的包括emotion、styled-components等等，顾名思义，这类方案可以实现直接在 JS 中写样式代码，基本包含CSS 预处理器和 CSS Modules 的各项优点，非常灵活，解决了开发体验和全局样式污染的问题。 CSS 原子化框架，如Tailwind CSS、Windi CSS，通过类名来指定样式，大大简化了样式写法，提高了样式开发的效率，主要解决了原生 CSS 开发体验的问题。 不过，各种方案没有孰优孰劣，各自解决的方案有重叠的部分，但也有一定的差异 css预处理器 Vite 本身对 CSS 各种预处理器语言(Sass/Scss、Less和Stylus)做了内置支持。也就是说，即使你不经过任何的配置也可以直接使用各种 CSS 预处理器。 但是由于 Vite 底层会调用 CSS 预处理器的官方库进行编译，而 Vite 为了实现按需加载，并没有内置这些工具库，而是让用户根据需要安装 例如我们要使用 sass预处理 pnpm install sass 之后不需要任何配置就可以使用scss了 全局变量的引入比如我们在全局有许多的样式变量 $theme-color: #17c2c2; 在其他scss文件中引入的时候，常常会需要先导入这个样式变量的文件 @import &#39;./variable.scss&#39;; vite中有可配置参数，能够配置全局引入的文件 // vite.config.ts // vite.config.ts import { normalizePath } from &#39;vite&#39;; // 如果类型报错，需要安装 @types/node: pnpm i @types/node -D import path from &#39;path&#39;; // 全局 scss 文件的路径 // 用 normalizePath 解决 window 下的路径问题 const variablePath = normalizePath(path.resolve(&#39;./xxxxx&#39;)); export default defineConfig({ // css 相关的配置 css: { preprocessorOptions: { scss: { // additionalData 的内容会在每个 scss 文件的开头自动注入 additionalData: `@import &quot;${variablePath}&quot;;` } } } }) css modules CSS Modules 在 Vite 也是一个开箱即用的能力，Vite 会对后缀带有.module的样式文件自动应用 CSS Modules。 直接将相关的样式文件改为，[name].module.scss CSS Modules 配置 例如一个Header组件 改造样式文件名称为index.module.scss .page-header { display: flex; color: #fff; background-color: $theme-color; } 在tsx中引入 import { useState } from &quot;react&quot;; import style from &quot;./index.module.scss&quot;; function PageHeader() { const prefixCls = &quot;w-page-header&quot;; const [count, setCount] = useState(0); return ( &lt;div className={style[&#39;page-header&#39;]}&gt; page header &lt;button onClick={() =&gt; setCount(1)}&gt;add&lt;/button&gt; {count} &lt;/div&gt; ); } export default PageHeader; 修改配置，生成的hash import { defineConfig, normalizePath } from &#39;vite&#39; import react from &#39;@vitejs/plugin-react&#39; import path from &#39;path&#39;; const variablePath = normalizePath(path.resolve(&#39;./src/assets/style/variable.scss&#39;)); // https://vitejs.dev/config/ export default defineConfig({ root: path.join(__dirname, &#39;src&#39;), plugins: [react()], css: { modules: { // 一般我们可以通过 generateScopedName 属性来对生成的类名进行自定义 // 其中，name 表示当前文件名，local 表示类名 generateScopedName: &quot;[name]__[local]___[hash:base64:5]&quot; }, preprocessorOptions: { scss: { // additionalData 的内容会在每个 scss 文件的开头自动注入 additionalData: `@import &quot;${variablePath}&quot;;` } } } }) 就可以看到生成的类名为 postcss 一般你可以通过 postcss.config.js 来配置 postcss ，不过在 Vite 配置文件中已经提供了 PostCSS 的配置入口，我们可以直接在 Vite 配置文件中进行操作。 autoprefixer 这个插件主要用来自动为不同的目标浏览器添加样式前缀，解决的是浏览器兼容性的问题 装上这个插件（不再需要手动安装postcss了，只需要装对应插件） pnpm i autoprefixer -D 配置vite.config.ts import { defineConfig } from &#39;vite&#39; import react from &#39;@vitejs/plugin-react&#39; import autoprefixer from &#39;autoprefixer&#39;; // https://vitejs.dev/config/ export default defineConfig({ root: path.join(__dirname, &#39;src&#39;), plugins: [react()], css: { ..... postcss: { plugins: [ autoprefixer({ // 指定目标浏览器 overrideBrowserslist: [ &#39;Android 4.1&#39;, &#39;iOS 7.1&#39;, &#39;Chrome &gt; 31&#39;, &#39;ff &gt; 31&#39;, &#39;ie &gt;= 8&#39;, &#39;&gt; 1%&#39;,] }) ] } } }) 之后打包生成的文件中就能自动添加前缀了 其他插件 推荐一个站点：www.postcss.parts/ postcss-pxtorem： 用来将 px 转换为 rem 单位，在适配移动端的场景下很常用。 postcss-preset-env: 通过它，你可以编写最新的 CSS 语法，不用担心兼容性问题。 cssnano: 主要用来压缩 CSS 代码，跟常规的代码压缩工具不一样，它能做得更加智能，比如提取一些公共样式进行复用、缩短一些常见的属性值等等。 css in js 社区中有两款主流的CSS In JS 方案: styled-components和emotion。 对于css in js的方案，我们要考虑多个问题 选择器命名问题 DCE(Dead Code Elimination 即无用代码删除) 代码压缩 生成 SourceMap 服务端渲染(SSR) 而styled-components和emotion已经提供了对应的 babel 插件来解决这些问题，我们在 Vite 中要做的就是集成这些 babel 插件。 配置// vite.config.ts import { defineConfig } from &#39;vite&#39; import react from &#39;@vitejs/plugin-react&#39; // https://vitejs.dev/config/ export default defineConfig({ plugins: [ react({ babel: { // 加入 babel 插件 // 以下插件包都需要提前安装 // 当然，通过这个配置你也可以添加其它的 Babel 插件 plugins: [ // 适配 styled-component &quot;babel-plugin-styled-components&quot; // 适配 emotion &quot;@emotion/babel-plugin&quot; ] }, // 注意: 对于 emotion，需要单独加上这个配置 // 通过 `@emotion/react` 包编译 emotion 中的特殊 jsx 语法 jsxImportSource: &quot;@emotion/react&quot; }) ] })","tags":[]},{"title":"理解Proxy和Reflect","date":"2022-09-03T02:43:45.000Z","path":"2022/09/03/理解Proxy和Reflect/","text":"理解Proxy Vue3中利用的是Proxy以及Reflect去代理对象的 我们知道Proxy是只能代理对象类型的，非对象类型不可以进行代理 所谓代理： 指的是对一个 对象 的 基本语义 的代理 何为基本语义比如我们对对象的一堆简单操作 console.log(obj.a); // 读取属性操作 obj.a++; // 设置属性值操作 类似这种读取，设置属性值的操作，就是属于基本的语义操作 —- 基本操作 类似这种的基本操作就可以用Proxy进行代理拦截 基本操作的基本用法 const data = new Proxy(obj, { // 拦截读取属性操作 get(){ .... }, // 拦截设置属性操作 set(){ .... } }) 例如函数：我们也可以使用apply对函数进行拦截 const fn = ()=&gt;{ console.log(&#39;wengkaimin&#39;) } const proFn = new Proxy(fn, { apply(target, thisArg, argArray){ target.call(thisArg, ...argArray) } }) 复合操作既然有基本操作，可以也有非基本操作，在js里头，我们叫他复合操作 obj.fn() 这个显而易见，是又多个语义构成的（调用一个对象的一个函数属性）、 两个语义是： 首先通过get获取到obj的fn属性 通过获取到的fn进行调用 理解Reflect Reflect是一个全局对象，其中存在和Proxy的拦截器很多名字相同的方法 如下的等价操作 const obj = { a: &#39;wengkaimin&#39; }; console.log(obj.a); console.log(Reflect.get(obj, &#39;a&#39;)); 但是Reflect它能够传入第三个参数 reveiver 就相当于函数执行过程中，指向的this console.log(Reflect.get(obj, &#39;a&#39;, { a: &#39;kaimin&#39; })); // kaimin 在vue3响应式学习 整理的那篇文章中，记录了实现 响应式代理的代码 const obj = new Proxy(data, { get(target, key) { track(target, key); // 返回函数属性 // 这里没有用Reflect.get实现读取数据 return target[key]; }, set(target, key, newVal) { target[key] = newVal; trigger(target, key); }, }); 我们在Proxy中无论设置get还是set拦截，都是直接用的原始对象target来进行读取或者赋值 假如目前的obj为，返回了this.foo的值。 接着我们在effect副作用函数中通过代理对象data读取b的值。 之后我们修改了a的值 const obj = { a:1, get b(){ return this.a + 1; } } const data = new Proxy(obj, { get(target, key) { track(target, key); // 返回函数属性 // 这里没有用Reflect.get实现读取数据 return target[key]; }, set(target, key, newVal) { // 这里没有用Reflect.set target[key] = newVal; trigger(target, key); }, }) effect(()=&gt;{ console.log(data.b) // 2 }) data.a++ 修改了a的值之后，并不会相对应的触发副作用函数的重新执行 梳理下读取步骤： 首先我们在副作用函数中读取了data.b的值 会触发data代理对象的get拦截器，在get拦截器中，通过target[key]读取; 此时target就指的是 obj 原始对象，key就是 ‘b’，所以相当直接读了obj.b 访问obj.b的时候，其实是一个getter函数，这个getter的this指向了obj，最终实质上是访问了 obj.a 并且给他加了个1 当然，在副作用函数effect当中相当于，直接读取了原生对象obj的属性，虽然看上去走了代理，但不多。所以这肯定是没有追踪到的，建立不起相应的联系 就类似 effect(()=&gt;{ console.log(obj.a + 1) // 2 }) 在这种场景下Reflect的第三个参数receiver就派上用场了 使用Reflect改造完get拦截器 const obj = new Proxy(data, { get(target, key, receiver) { track(target, key); // 返回函数属性 return Reflect.get(target, key, receiver) }, set(target, key, newVal) { target[key] = newVal; trigger(target, key); }, }); 使用了Relfect之后，this指向就转为了data代理对象，就可以成功的建立联系了 Reflect的作用不仅于此","tags":[{"name":"vue3","slug":"vue3","permalink":"https://github.com/NollieLeo/tags/vue3/"},{"name":"Proxy","slug":"Proxy","permalink":"https://github.com/NollieLeo/tags/Proxy/"},{"name":"Reflect","slug":"Reflect","permalink":"https://github.com/NollieLeo/tags/Reflect/"},{"name":"响应式","slug":"响应式","permalink":"https://github.com/NollieLeo/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"}]},{"title":"ts之协变和逆变","date":"2022-06-05T08:53:07.000Z","path":"2022/06/05/ts之协变和逆变/","text":"协变和逆变协变和逆变是编程理论中一个很重要的话题。用于表达父类子类在安全类型转换后的兼容性（或者说继承关系）。定义为：如果A，B代表两个类型；f()表示类型转换；A -&gt; B表示A是B的子类。 当f()是协变时：若 A -&gt; B，则f(A) -&gt; f(B) 当f()是逆变时：若 A -&gt; B，则f(B) -&gt; f(A) 当f()是双变时：若 A -&gt; B，则以上均成立 当f()是不变时：若 A -&gt; B，则以上均不成立，没有兼容关系 class Animal { move(){ console.log(&quot;animal is moving&quot;); } } class Cat extends Animal { purr() { console.log(&quot;cat is purring&quot;); } } class WhiteCat extends Cat { showoffColor() { console.log(&quot;see my hair color&quot;); } } 我们有名为Animial的父类，Cat是Animal的子类。WhiteCat是Cat的子类， 即WhiteCat -&gt; Cat -&gt; Animal。根据父类兼容子类的原则可知： let animal: Animal; let cat: Cat; let whiteCat: WhiteCat; animal = cat; animal = whiteCat; cat = whiteCat; 抛出问题假如现在有一个函数，类型为(param: Cat) =&gt; Cat。那么它的兼容类型是什么呢？ 我们可以把这个问题分解成两个部分参数兼容性和返回值兼容性。 (param: Cat) =&gt; void的兼容类型是什么？ () =&gt; Cat的兼容类型是什么？ 参数兼容性我们假设(param: Cat) =&gt; void为A，此时有以下两种函数： B: (param: WhiteCat) =&gt; void C：(param: Animal) =&gt; void 那么A兼容哪一个函数？ 假设兼容B那么此时 A = B成立： let A: (param: Cat) =&gt; void; const B = (param: WhiteCat) =&gt; { param.move(); param.purr(); param.showoffColor(); }; A = B; A(new Cat()); 函数运行到param.showoffColor()会报错。那么假设不成立。 假设兼容C那么此时 A = C成立： let A: (param: Cat) =&gt; void; const C = (param: Animal) =&gt; { param.move(); }; A = C; A(new Cat()); 此时函数成功运行。那么假设成立。 所以(param: Animal) =&gt; void -&gt; (param: Cat) =&gt; void 。根据前面的定义可以看出函数参数是逆变的。 返回值兼容性我们假设() =&gt; Cat为A，此时有以下两种函数： B: () =&gt; Animal C：() =&gt; WhiteCat 那么A兼容哪一个函数？ 假设兼容B那么此时 A = B成立： let A: () =&gt; Cat; const B = () =&gt; new Animal(); A = B; const result = A(); result.move(); result.purr(); 函数运行到result.purr()会报错。那么假设不成立。 假设兼容C那么此时 A = C成立： let A: () =&gt; Cat; const C = () =&gt; new WhiteCat(); A = C; const result = A(); result.move(); result.purr(); 此时函数成功运行。那么假设成立。 所以() =&gt; WhiteCat -&gt; () =&gt; Cat。根据前面的定义可以看出函数返回值是协变的。 函数参数类型的现实在ts中，参数类型是双变的，也就是说既是协变，也是逆变。这当然不安全。所以我们可以通过开启strictFunctionTypes修复这个问题，保证参数类型是逆变。 那么为什么ts会让函数参数类型保留双变转换呢？下面是一个十分常见的例子： interface Event { timestamp: number; } interface MouseEvent extends Event { x: number; y: number } function listenEvent(eventType: EventType, handler: (n: Event) =&gt; void) { /* ... */ } // 虽然不安全，且编译无法通过，但是十分常见的使用方式 listenEvent(EventType.Mouse, (e: MouseEvent) =&gt; console.log(e.x, e.y)); // 为了保证编译通过，只能通过以下方式 listenEvent(EventType.Mouse, (e: Event) =&gt; console.log((e as MouseEvent).x, (e as MouseEvent).y)); listenEvent(EventType.Mouse, ((e: MouseEvent) =&gt; console.log(e.x, e.y)) as (e: Event) =&gt; void); 而如果函数参数类型是双变，那么上面第一种形式的代码也能顺利通过编译，无需使用后两种绕路的方式。","tags":[{"name":"typescript","slug":"typescript","permalink":"https://github.com/NollieLeo/tags/typescript/"},{"name":"协变和逆变","slug":"协变和逆变","permalink":"https://github.com/NollieLeo/tags/%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/"}]},{"title":"typescript刷题记录","date":"2022-05-23T05:56:55.547Z","path":"2022/05/23/typescript刷题记录/","text":"typescript刷题记录题目一解决如下错误 type User = { id: number; kind: string; }; function makeCustomer&lt;T extends User&gt;(u: T): T { // Error（TS 编译器版本：v4.4.2） // Type &#39;{ id: number; kind: string; }&#39; is not assignable to type &#39;T&#39;. // &#39;{ id: number; kind: string; }&#39; is assignable to the constraint of type &#39;T&#39;, // but &#39;T&#39; could be instantiated with a different subtype of constraint &#39;User&#39;. return { id: u.id, kind: &#39;customer&#39; } } 因为T受User类型的约束，但是也有可能有其他情况，比如{id:1, kind:&#39;2&#39;,name:&#39;test&#39;}，所以返回值中缺少了name 方法一直接把剩余的u的key返回出去 type User = { id: number; kind: string; }; function makeCustomer&lt;T extends User&gt;(u: T): T { return { ...u, id: u.id, kind: &#39;customer&#39; } } 方法二function makeCustomer&lt;T extends User&gt;(u: T): ReturnMake&lt;T, User&gt; { // Error（TS 编译器版本：v4.4.2） // Type &#39;{ id: number; kind: string; }&#39; is not assignable to type &#39;T&#39;. // &#39;{ id: number; kind: string; }&#39; is assignable to the constraint of type &#39;T&#39;, // but &#39;T&#39; could be instantiated with a different subtype of constraint &#39;User&#39;. return { id: u.id, kind: &#39;customer&#39; } } type ReturnMake&lt;T extends User, U&gt; = { [K in keyof R as K extends keyof T ? K: never]: U[K] } 遍历 User中的 key ，并使用 as 断言，如果K（也就是 User 类型的 key），约束于 泛型类型的 key 就返回 K，否侧返回 never，U[K] 取键值。 题目二（考察函数重载）本道题我们希望参数 a 和 b 的类型都是一致的，即 a 和 b 同时为 number 或 string 类型。当它们的类型不一致的值，TS 类型检查器能自动提示对应的错误信息。 function f(a: string | number, b: string | number) { if (typeof a === &#39;string&#39;) { return a + &#39;:&#39; + b; // no error but b can be number! } else { // error: 运算符“+”不能应用于类型“number”和“string | number”。ts(2365) return a + b; // error as b can be number | string } } 解决方案：函数重载function f(a:string, b:string ):string function f(a:number, b:number):number; function f(a: string | number, b: string | number) { if (typeof a === &#39;string&#39; || typeof b === &#39;string&#39;) { return a + &#39;:&#39; + b; // no error but b can be number! } else { return a + b; // error as b can be number | string } } 题目三（SetOptional || SetRequired）如何定义一个 SetOptional 工具类型，支持把给定的keys对应的属性变成可选的？对应的使用示例如下所示： type Foo = { a: number; b?: string; c: boolean; } // 测试用例 type SomeOptional = SetOptional&lt;Foo, &#39;a&#39; | &#39;b&#39;&gt;; // type SomeOptional = { // a?: number; // 该属性已变成可选的 // b?: string; // 保持不变 // c: boolean; // } 解决方法type Foo = { a: number; b?: string; c: boolean; } // 测试用例 type SomeOptional = SetOptional&lt;Foo, &#39;a&#39; | &#39;b&#39;&gt;; // type SomeOptional = { // a?: number; // 该属性已变成可选的 // b?: string; // 保持不变 // c: boolean; // } type SetOptional&lt;T, R extends keyof T&gt; = Omit&lt;T,R&gt; &amp; Partial&lt;Pick&lt;T,R&gt;&gt; setRequried也是一样的如下 type SetRequired&lt;T, K extends keyof T&gt; = Omit&lt;T, K&gt; &amp; Required&lt;Pick&lt;T, K&gt;&gt;; 题目四（ConditionalPick）Pick&lt;T, K extends keyof T&gt;的作用是将某个类型中的子属性挑出来，变成包含这个类型部分属性的子类型。 interface Todo { title: string; description: string; completed: boolean; } type TodoPreview = Pick&lt;Todo, &quot;title&quot; | &quot;completed&quot;&gt;; const todo: TodoPreview = { title: &quot;Clean room&quot;, completed: false }; 那么如何定义一个 ConditionalPick工具类型，支持根据指定的 Condition 条件来生成新的类型，对应的使用示例如下： interface Example { a: string; b: string | number; c: () =&gt; void; d: {}; } // 测试用例： type StringKeysOnly = ConditionalPick&lt;Example, string&gt;; //=&gt; {a: string} 解决方案1、in keyof遍历 V 泛型； 2、通过类型断言判断 V[K] 对应键值是否约束于传入的 string如果是 true那么断言成返回遍历的当前 K，否则为 never。 返回 never在 TypeScript 编译器中，会默认认为这是个用不存在的类型，也相当于没有这个 K会被过滤，对应值则是 V[K] 获取。 interface Example { a: string; b: string | number; c: () =&gt; void; d: {}; } // 测试用例： type StringKeysOnly = ConditionalPick&lt;Example, string&gt;; //=&gt; {a: string} type ConditionalPick&lt;T,R&gt; = { [K in keyof T as T[K] extends R ? K : never ]: T[K] } 题目五（追加args）定义一个工具类型 AppendArgument，为已有的函数类型增加指定类型的参数，新增的参数名是x，将作为新函数类型的第一个参数。具体的使用示例如下所示： type Fn = (a: number, b: string) =&gt; number type AppendArgument&lt;F, A&gt; = // 你的实现代码 type FinalFn = AppendArgument&lt;Fn, boolean&gt; // (x: boolean, a: number, b: string) =&gt; number 解决方案1 （使用泛型工具）使用泛型工具Parameters以及ReturnType type Fn = (a: number, b: string) =&gt; number type FinalFn = AppendArgument&lt;Fn, boolean&gt; // (x: boolean, a: number, b: string) =&gt; number type AppendArgument&lt;F extends (...args:any[]) =&gt; any, A&gt; = (arg1:A , ...args2:Parameters&lt;F&gt;) =&gt; ReturnType&lt;F&gt; // 你的实现代码 解决方案2 （使用infer）infer推导拿到参数类型T返回值类型为R，再从新返回一个新函数arg1参数为A，...args参数类型为前面推导保留的T，返回值即R。 type AppendArgument&lt;F extends (...args:any[]) =&gt; any, A&gt; = F extends (...args:infer T)=&gt; infer R ? (agr1:A, ...args:T)=&gt;R : never 题目五（数组类型拍平）定义一个NativeFlat工具类型，支持把数组类型拍平（扁平化）。具体的使用示例如下所示： type NaiveFlat&lt;T extends any[]&gt; = // 你的实现代码 // 测试用例： type NaiveResult = NaiveFlat&lt;[[&#39;a&#39;], [[&#39;b&#39;, &#39;c&#39;]], [&#39;d&#39;]]&gt; // NaiveResult的结果： &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; 解决方案（递归）type NaiveFlat&lt;T extends any[]&gt; = T extends (infer R)[] ? (R extends any[] ? NaiveFlat&lt;R&gt;: R ): never// 你的实现代码 // 测试用例： type NaiveResult = NaiveFlat&lt;[[&#39;a&#39;], [[&#39;b&#39;, &#39;c&#39;]], [&#39;d&#39;]]&gt; // NaiveResult的结果： &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; 1、首先需要在约束条件中使用infer关键字推导出 T 传入的数组类型，并用 P 保存数组类型。 2、三元嵌套判断R类型是否约束于类型any[]如果还是是数组继续递归遍历调用NaiveFlat&lt;R&gt;并传入R，放 R类型不满足 any[]，返回最后的扁平完成R类型所以得到最终联合类型&quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; 。 题目六 (数组不为空)定义NonEmptyArray工具类型，用于确保数据非空数组。 type NonEmptyArray&lt;T&gt; = // 你的实现代码 const a: NonEmptyArray&lt;string&gt; = [] // 将出现编译错误 const b: NonEmptyArray&lt;string&gt; = [&#39;Hello TS&#39;] // 非空数据，正常使用 解决方案const a: NonEmptyArray&lt;string&gt; = [] // 将出现编译错误 const b: NonEmptyArray&lt;string&gt; = [&#39;Hello TS&#39;] // 非空数据，正常使用 type NonEmptyArray&lt;T&gt; = [T, ...T[]] [T, ...T[]]确保第一项一定是T，[...T[]]，为剩余数组类型。 题目七定义一个JoinStrArray工具类型，用于根据指定的Separator分隔符，对字符串数组类型进行拼接。具体的使用示例如下所示： type JoinStrArray&lt;Arr extends string[], Separator extends string&gt; = // 你的实现代码 // 测试用例 type Names = [&quot;Sem&quot;, &quot;Lolo&quot;, &quot;Kaquko&quot;] type NamesComma = JoinStrArray&lt;Names, &quot;,&quot;&gt; // &quot;Sem,Lolo,Kaquko&quot; type NamesSpace = JoinStrArray&lt;Names, &quot; &quot;&gt; // &quot;Sem Lolo Kaquko&quot; type NamesStars = JoinStrArray&lt;Names, &quot;⭐️&quot;&gt; // &quot;Sem⭐️Lolo⭐️Kaquko&quot; 解决方法// 测试用例 type Names = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] type NamesComma = JoinStrArray&lt;Names, &quot;,&quot;&gt; // &quot;Sem,Lolo,Kaquko&quot; type NamesSpace = JoinStrArray&lt;Names, &quot; &quot;&gt; // &quot;Sem Lolo Kaquko&quot; type NamesStars = JoinStrArray&lt;Names, &quot;⭐️&quot;&gt; // &quot;Sem⭐️Lolo⭐️Kaquko&quot; type JoinStrArray&lt;Arr extends string[], Separator extends string&gt; = Arr extends [infer A,...infer B] ? (`${A extends string ? A : &#39;&#39;}${B extends [string, ...string[]] ? `${Separator}${JoinStrArray&lt;B, Separator&gt;}` : &#39;&#39;}`):&#39;&#39; // 你的实现代码 JoinStrArray工具方法，Arr泛型必须约束于string[]类型，Separator为分隔符，也必须约束于string类型； 1、首先Arr约束于后面[infer A, ...infer B]并通过infer关键字推导拿到第一个索引A的类型，以及剩余（rest）数组的类型为B； 2、如果满足约束，则连接字符，连接字符使用模板变量，先判断A（也就是第一个索引）是否约束于string类型，满足就取第一个A否则直接返回空字符串； 3、后面连接的B（…rest）判断是否满足于[string, ...string[]]，意思就是是不是还有多个索引。如果有，用分割符号，加上递归再调用JoinStrArray工具类型方法，Arr泛型就再为 B ，分隔符泛型Separator不变。减治思想，拿出数组的每一项，直至数组为空。 最开始的话，如果Arr不满足约束，那么直接返回为空字符串。 题目八实现一个Trim工具类型，用于对字符串字面量类型进行去空格处理。具体的使用示例如下所示： type Trim&lt;V extends string&gt; = // 你的实现代码 // 测试用例 Trim&lt;&#39; semlinker &#39;&gt; //=&gt; &#39;semlinker&#39; 解决方案type TrimLeft&lt;V extends string&gt; = V extends ` ${infer R}` ? TrimLeft&lt;R&gt; : V; type TrimRight&lt;V extends string&gt; = V extends `${infer R} ` ? TrimRight&lt;R&gt; : V; type Trim&lt;V extends string&gt; = TrimLeft&lt;TrimRight&lt;V&gt;&gt;; // 测试用例 type Result = Trim&lt;&#39; semlinker &#39;&gt; //=&gt; &#39;semlinker&#39; 题目九实现一个IsEqual工具类型，用于比较两个类型是否相等。具体的使用示例如下所示： type IsEqual&lt;A, B&gt; = // 你的实现代码 // 测试用例 type E0 = IsEqual&lt;1, 2&gt;; // false type E1 = IsEqual&lt;{ a: 1 }, { a: 1 }&gt; // true type E2 = IsEqual&lt;[1], []&gt;; // false 解决方案// 测试用例 type E0 = IsEqual&lt;1, 2&gt;; // false type E1 = IsEqual&lt;{ a: 1 }, { a: 1 }&gt; // true type E2 = IsEqual&lt;[1], []&gt;; // false type IsEqual&lt;A, B&gt; = [A] extends [B]? ([B] extends [A]? true:false ): false // 你的实现代码 题目十 以下两者都是相类似的类型推倒 实现一个获取数组第一个位置的类型 HEAD // 测试用例 type H0 = Head&lt;[]&gt; // never type H1 = Head&lt;[1]&gt; // 1 type H2 = Head&lt;[3, 2]&gt; // 3 type Head&lt;T extends Array&lt;any&gt;&gt; = T extends [infer A, ...infer B] ? A :never// 你的实现代码 实现一个获取数组最后一个位置的类型TAIL // 测试用例 type T0 = Tail&lt;[]&gt; // [] type T1 = Tail&lt;[1, 2]&gt; // [2] type T2 = Tail&lt;[1, 2, 3, 4, 5]&gt; // [2, 3, 4, 5] type Tail&lt;T extends Array&lt;any&gt;&gt; = T extends [...any, infer A] ? A : never // 你的实现代码 题目十一实现一个Unshift工具类型，用于把指定类型E作为第一个元素添加到 T 数组类型中。具体的使用示例如下所示： type Unshift&lt;T extends any[], E&gt; = // 你的实现代码 // 测试用例 type Arr0 = Unshift&lt;[], 1&gt;; // [1] type Arr1 = Unshift&lt;[1, 2, 3], 0&gt;; // [0, 1, 2, 3] 复制代码 实现方法type Unshift&lt;T extends any[], E&gt; = [E, ...T]; // 测试用例 type Arr0 = Unshift&lt;[], never&gt;; // [1] type Arr1 = Unshift&lt;[1, 2, 3], 0&gt;; // [0, 1, 2, 3] 复制代码 新建一个数组，第一项类型为E，剩余使用...T连接。 题目十二实现一个Shift工具类型，用于移除T数组类型中的第一个类型。具体的使用示例如下所示： type Shift&lt;T extends any[]&gt; = // 你的实现代码 // 测试用例 type S0 = Shift&lt;[1, 2, 3]&gt; type S1 = Shift&lt;[string,number,boolean]&gt; 实现方案// 测试用例 type S0 = Shift&lt;[1, 2, 3]&gt; type S1 = Shift&lt;[string,number,boolean]&gt; type Shift&lt;T extends any[]&gt; = T extends [infer A, ...infer B] ? B : [] // 你的实现代码 ...infer B去除第一项之后的集合，使用变量B保存该类型。如果满足约束，返回剩余参数类型，也就是B。 题目十三实现一个Push工具类型，用于把指定类型E作为第最后一个元素添加到T数组类型中。具体的使用示例如下所示： type Push&lt;T extends any[], V&gt; = // 你的实现代码 // 测试用例 type Arr0 = Push&lt;[], 1&gt; // [1] type Arr1 = Push&lt;[1, 2, 3], 4&gt; // [1, 2, 3, 4] 解决方案// 测试用例 type Arr0 = Push&lt;[], 1&gt; // [1] type Arr1 = Push&lt;[1, 2, 3], 4&gt; // [1, 2, 3, 4] type Push&lt;T extends any[], E&gt; = [...T, E] // 你的实现代码 题目十四实现一个Includes工具类型，用于判断指定的类型E是否包含在T数组类型中。具体的使用示例如下所示： type Includes&lt;T extends Array&lt;any&gt;, E&gt; = // 你的实现代码 type I0 = Includes&lt;[], 1&gt; // false type I1 = Includes&lt;[2, 2, 3, 1], 2&gt; // true type I2 = Includes&lt;[2, 3, 3, 1], 1&gt; // true 解决方法type I0 = Includes&lt;[], 1&gt; // false type I1 = Includes&lt;[2, 2, 3, 1], 2&gt; // true type I2 = Includes&lt;[2, 3, 3, 1], 1&gt; // true type Includes&lt;T extends Array&lt;any&gt;, E&gt; = E extends T[number] ? true :false 这里T[number]可以理解返回T数组元素的类型，比如传入的泛型T为[2, 2, 3, 1]，那么T[number]被解析为：2 | 2 | 3 | 1。 *题目十五实现一个UnionToIntersection工具类型，用于把联合类型转换为交叉类型。具体的使用示例如下所示： type UnionToIntersection&lt;U&gt; = // 你的实现代码 // 测试用例 type U0 = UnionToIntersection&lt;string | number&gt; // never type U1 = UnionToIntersection&lt;{ name: string } | { age: number }&gt; // { name: string; } &amp; { age: number; } 解决方案// 测试用例 type U0 = UnionToIntersection&lt;string | number&gt; // never type U1 = UnionToIntersection&lt;{ name: string } | { age: number }&gt; // { name: string; } &amp; { age: number; } type UnionToIntersection&lt;U&gt; = ( U extends unknown ? (props: U)=&gt;void : never ) extends (props2: infer P) =&gt; void ? P : never 1、extends unknown始终为true，默认进入到分发情况 2、会声明一个以U为入参类型的函数类型A，即(props: U) =&gt; void，该函数约束于以props2类型为入参的函数类型B，即(props2: infer P) =&gt; void。 3、如果函数A能继承函数B则 返回infer P声明的P，否则返回never，再利用函数参数类型逆变，从而实现得到的结果从联合类型到交叉类型的转变。 这里是也设计到一个知识点：分布式条件类型，条件类型的特性：分布式条件类型。在结合联合类型使用时（只针对\\**extends**\\左边的联合类型**），分布式条件类型会被自动分发成联合类型。例如，T extends U ? X : Y，T的类型为A | B | C，会被解析为(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)。 都知道infer声明都是只能出现在extends子语句中。但是，在协变的位置上，同一类型变量的多个候选类型会被推断为联合类型： type Foo&lt;T&gt; = T extends { a: infer U, b: infer U } ? U : never; type T10 = Foo&lt;{ a: string, b: string }&gt;; // string type T11 = Foo&lt;{ a: string, b: number }&gt;; // string | number 在逆变的位置上，同一个类型多个候选类型会被推断为交叉类型： type Bar&lt;T&gt; = T extends { a: (x: infer U) =&gt; void, b: (x: infer U) =&gt; void } ? U : never; type T20 = Bar&lt;{ a: (x: string) =&gt; void, b: (x: string) =&gt; void }&gt;; // string type T21 = Bar&lt;{ a: (x: string) =&gt; void, b: (x: number) =&gt; void }&gt;; // string &amp; number 题目十六（元组转化为对象）ts内置方法实现Exclude 排除类型例子： type Dir=&#39;1&#39;|&#39;2&#39;|&#39;3&#39;|&#39;4&#39; // type dir1 = &quot;3&quot; | &quot;4&quot; type dir1=Exclude&lt;Dir,&#39;1&#39;|&#39;2&#39;&gt; 实现： type MyExclude&lt;T, R&gt; = T extends R ? never :T Pick 获取 key 类型type MyPick&lt;T, R extends keyof T&gt; = { [Key in R]: T[Key] } Omit 排除 key 类型type MyOmit&lt;T, R extends keyof T&gt; = MyPick&lt;T, MyExclude&lt;keyof T, R&gt;&gt; Readonly 属性只读type MyReadonly&lt;T&gt; = { readonly [Key in keyof T]: T[Key] } Required 属性必选type MyRequired&lt;T&gt; = { [Key in keyof T]-?:T[Key] } Partial 属性可选type MyPartial&lt;T&gt; = { [Key in keyof T]?: T[Key] } ReturnType 获取函数返回类型type MyReturnType&lt;T extends (...args:any[])=&gt;any&gt; = T extends (...args:any[]) =&gt; infer R ? R :never Parameters 获取函数参数类型type MyParameters&lt;T extends (...args:any[])=&gt;any&gt; = T extends (...args:infer B) =&gt; any? B:never ts 实用范型工具OptionalRequired 部分属性必选实现一/* * @Description: 部分属性必选 */ export type OptionalRequired&lt;T,R extends keyof T&gt; = { [key in R]-?: T[key] } &amp; { [key in Exclude&lt;keyof T, R&gt;]: T[key] } type TestObj = { a?:string, b:number, c?:object } type OptionRequiredObjType = OptionalRequired&lt;TestObj,&#39;a&#39; | &#39;c&#39;&gt; 实现二export type OptionRequired&lt;T,R extends keyof T&gt; = Required&lt;T&gt; &amp; Omit&lt;T, R&gt; OptionalReadonly 部分属性只读实现一/* * @Description: 部分属性只读 */ export type OptionalReadonly&lt;T,R extends keyof T&gt; = { readonly [key in R]: T[key] } &amp; { [key in Exclude&lt;keyof T, R&gt;]: T[key] } type TestObj = { a?:string, b:number, c?:object } type OptionReadonlyObjType = OptionalReadonly&lt;TestObj,&#39;a&#39; | &#39;c&#39;&gt; 实现二export type OptionalReadonly&lt;T,R extends keyof T&gt; = Omit&lt;T,R&gt; &amp; Readonly&lt;Pick&lt;T,R&gt;&gt; OptionalPartial 部分属性可选实现一/* * @Description: 部分可选 */ type OptionalPartial&lt;T, R extends keyof T&gt; = { [key in R]?: T[key] } &amp; { [key in Exclude&lt;keyof T, R&gt;]: T[key] } type TestObj = { a:string, b:number, c:object } type OptionPartialObjType = OptionalPartial&lt;TestObj,&#39;a&#39; | &#39;c&#39;&gt; 实现二type OptionalPartial&lt;T, R extends keyof T&gt; = Omit&lt;T, R&gt; &amp; Partial&lt;Pick&lt;T,R&gt;&gt;;","tags":[]},{"title":"vue的响应式系统设计总结","date":"2022-05-08T06:50:34.000Z","path":"2022/05/08/vue的响应式系统设计总结/","text":"vue3 - 响应式学习前置知识副作用函数副作用函数就是指的会产生副作用的函数 function effect(){ document.body.innerHTML = &#39;hello world&#39; } effect函数会直接或者间接的影响到其他地方函数的执行，也就是说，比如修改一个变量，这个变量其他地方也读取到了 响应式数据假如，有一个引用类型变量, 有一个函数读取到他的属性 const obj = { a: &#39;wengkaimin&#39; }; function read(){ document.body.innerText = obj.a } 当我们修改了obj.a的值的时候，希望read这个函数重新执行；如果read函数能够因为obj.a的值变化，重新自动的执行，那么我们说obj是一个响应数据 实现响应式数据有一个data数据 const data = { a: 1 }; 从两个点出发去实现： 副作用函数执行的时候，会触发读取 data.a的操作 当修改了data.a的值的时候，会触发data.a的设置操作 不难联想到es5的Object.defineProperty和es6的Proxy代理，都是用于数据的拦截操作，我们只要做好读和取的拦截操作，就能实现数据的响应 基本实现实现读取 拦截当我们读取data.a的时候，通过拦截将副作用函数加入到一个 “桶” 的数据结构中 {% image image-20220807160051989.png 'image-20220807160051989.png' '' %} 接着我们设置data.a的时候把副作用函数取出来 接下来执行对data的代理, obj就是代理的对象 const buckect = new Set(); // 桶 const data = { a: 1, }; const obj = new Proxy(data, { get(target, key) { buckect.add(effect); return target[key]; }, set(target, key, newVal) { target[key] = newVal; // 取出副作用函数effect buckect.forEach((fn) =&gt; fn()); return true; }, }); const effect = () =&gt; { document.body.innerText = obj.a; }; effect(); setTimeout(() =&gt; { obj.a = 2; }, 2000); Step1: 完善系统上面的基本实现存在很多缺陷 硬编码了副作用函数名称 effect 要想副作用函数被正确的收集到 bucket当中，就不能使用硬编码的函数名 因此，这里提供一个函数的注册机制，用于注册副作用函数 let activeEffect; // 注册函数 function effect(fn){ activeEffect = fn; fn(); } 使用effect包裹 读去了obj的那个管他什么函数 effect(()=&gt;{ document.body.innerText = obj.a }) 之后需要在读的拦截器中做判断 const obj = new Proxy(data, { get(target, key){ if(activeEffect){ // ➕ buckect.add(activeEffect); } return target[key] }, set(target, key, newVal){ target[key] = newVal; // 取出副作用函数effect buckect.forEach(fn =&gt; fn()); return true } }) 属性和副作用函数关系不明确 上面的桶数据结构是一个set，这肯定是不符合情理的，因为一个对象可能存在多个属性，不同的属性之间对应的副作用函数也有可能不一样 这样就会导致，无论读取什么值（是否存在）都会去触发副作用函数的重新执行 const buckect = new Set(); // 桶 let activeEffect; const data = { a: 1, b: 2, }; const obj = new Proxy(data, { get(target, key) { if (activeEffect) { // new buckect.add(activeEffect); } return target[key]; }, set(target, key, newVal) { target[key] = newVal; // 取出副作用函数effect buckect.forEach((fn) =&gt; fn()); return true; }, }); // 注册函数 function effect(fn) { activeEffect = fn; fn(); } function setDoc() { document.body.innerText = obj.a; console.log(&#39;触发了&#39;)// obj.b的修改也会引起effect重新 } effect(setDoc); setTimeout(() =&gt; { obj.a = 2; obj.b = 3; // ➕ }, 2000); 因此需要重新的设计桶结构，就不能简单的用Set了 多个属性，多个响应式数据，要有一一的对应关系 image-20220809141823945.png target：表示不同的需要代理的引用类型数据（当然会存在很多不同的引用数据啊） key：表示当前的target里头不同的key（不同的key，触发的副作用函数们也不一样，这里要做区分） target存在不同的key，所以不同的key也有不同的副作用 function someFn(){ console.log(obj.a, obj.b) } effectFn：表示target下面，这个key所对应的所有副作用函数 因为存在，例如obj.a 被A和B或者C等等其他不同引用地址的函数读取的情况 function someFn(){ console.log(obj.a) } function someFn2(){ console.log(obj.a) } 综上 这个bucket数据结构可以为 bucket – &gt; WeakMap （weakMap由target的引用组成） target — &gt; Map （map由key组成） key — &gt; Set （Set存储了当前key对应的副作用函数） 修改get拦截器get(target, key){ // 如果没有 activeEffect说明没有注册过这个副作用函数，直接return if(!activeEffect) return; // ➕ // 根据targt代理引用，取得它对应的map，对应关系target --- &gt; Map const depsMap = buckect.get(target); // ➕ // 假如说这个map不存在，那么就new一个map，与target引用关联 if(!depsMap) { // ➕ buckect.set(target, (depsMap = new Map())) // ➕ } // 再根据key从map中取得key对应的Set，key ---&gt; Set // Set里头存储了这个key对应的副作用函数 const deps = depsMap.get(key); // ➕ if(!deps){ // ➕ depsMap.set(key, (deps = new Set())) // ➕ } // 最后将activeEffect加入到key对应的Set当中 deps.add(activeEffect);// ➕ // 返回函数属性 return target[key] }, 修改set拦截 set(target, key, newVal){ target[key] = newVal; // 根据target引用从桶中取得对应的Map const depsMap = buckect.get(target); // ➕ if(!depsMap) return; // ➕ // 取得target 上key对应的Set数据，遍历，执行里头的副作用 const effects = depsMap.get(key);// ➕ if(effects){ effects.forEach(fn =&gt; fn()) } return true } 这样就可以避免修改其他key值带来的不必要的副作用执行，并且明确了代理目标和副作用函数之间的关系 优化这一步骤提取一下get和set的里头的一些逻辑，作为封装函数。 track：表示追踪的含义，追踪副作用函数 trigger：是表示触发副作用的函数 完整代码 let activeEffect; // 注册函数 function effect(fn){ activeEffect = fn; fn(); } function track(target,key){ // 如果没有 activeEffect说明没有注册过这个副作用函数，直接return if(!activeEffect) return; // 根据targt代理引用，取得它对应的map，对应关系target --- &gt; Map let depsMap = buckect.get(target); // 假如说这个map不存在，那么就new一个map，与target引用关联 if(!depsMap) { buckect.set(target, (depsMap = new Map())) } // 再根据key从map中取得key对应的Set，key ---&gt; Set // Set里头存储了这个key对应的副作用函数 let deps = depsMap.get(key); if(!deps){ depsMap.set(key, (deps = new Set())) } // 最后将activeEffect加入到key对应的Set当中 deps.add(activeEffect); } function trigger(target, key){ // 根据target引用从桶中取得对应的Map const depsMap = buckect.get(target); if(!depsMap) return; // 取得target 上key对应的Set数据，遍历，执行里头的副作用 const effects = depsMap.get(key); if(effects){ effects.forEach(fn =&gt; fn()) } } const obj = new Proxy(data, { get(target, key){ track(target,key) // 返回函数属性 return target[key] }, set(target, key, newVal){ target[key] = newVal; trigger(target, key) } }) 为何用WeakMap：因为target的数据源是不确定的，存在数据量非常大的情况，假如用Map作为数据结构，在IIFE当中其实是很可能存在内存溢出的现象； Step2: 加强系统健壮性考虑切换分支情况（clean up）在开发过程经常会有条件判断的情况，例如： const data = { a: true, b: &#39;weng&#39; }; const obj = new Proxy(data, {....}); effect(function someFn(){ console.log(obj.a ? obj.b : &#39;yes!&#39;) }) 当someFn触发的时候，会读取obj.a和obj.b，但是obj.b只有在obj.a为true的情况下，才会打印出来，这时候someFn已经被收集到了a和b各自对应的Set当中了 假如改变obj.a 为false，会触发someFn副作用重新 执行，但是由于obj.a已经是false了，所以就不再读取到obj.b了； obj.a = false 但是由于第一次读取了b，已经将b的副作用函数someFn收集到了对于的key – &gt; Set当中了 这时候如果去改变obj.b的值，其实还是会触发someFn const data = { a: true, b: &quot;weng&quot;, }; const obj = new Proxy(data, { get(target, key) { track(target, key); // 返回函数属性 return target[key]; }, set(target, key, newVal) { target[key] = newVal; trigger(target, key); }, }); function someFn() { console.log(obj.a ? obj.b : &quot;yes!&quot;); console.log(&#39;触发了&#39;, bucket); } effect(someFn); obj.a = false; setTimeout(() =&gt; { obj.b = &#39;kaimin&#39;; // 仍然会触发someFn }, 1000); 到这里，目前这套系统还没有一种能够清理这种 分支切换 的情况的能力 解决这种问题的思路： 副作用函数执行的时候，第一步，先把它从与之关联的 key—&gt;Set中删除 副作用函数执行完，去重新建立联系，但是在新的联系中，就不会再包含其他遗留的副作用函数了 改造effect - 1要想知道这个副作用函数被哪些对象的哪些key – &gt; Set收集了，必须要知道如何去收集以及标记下这些 key —&gt; Set 所以，我们可以先改造一下副作用函数的注册函数effect，目的在于收集 // 注册函数 function effect(fn){ const effectFn = ()=&gt;{ activeEffect = effectFn; fn(); } // 用于存储所有与该副作用函数相关的依赖合集 bucket桶中 key---&gt; Set 的 Set集合 effectFn.deps = []; // deps: Array&lt;Set&gt; effectFn(); } deps就是我们所说的，用于收集 用到这个副作用函数的集合的地方，存储的将是Set的引用 改造track有了 收集 Set的集合deps，收集的时机也很重要； 看之前的track函数，是作用在get拦截器当中的，将 当前激活的副作用函数 存入Set当中，如果没有key对应的Set，则会new一个，所以在这里，收集deps的时机是最好的 因此我们改造track函数 function track(target,key){ // 如果没有 activeEffect说明没有注册过这个副作用函数，直接return if(!activeEffect) return; // 根据targt代理引用，取得它对应的map，对应关系target --- &gt; Map let depsMap = buckect.get(target); // 假如说这个map不存在，那么就new一个map，与target引用关联 if(!depsMap) { buckect.set(target, (depsMap = new Map())) } // 再根据key从map中取得key对应的Set，key ---&gt; Set // Set里头存储了这个key对应的副作用函数 let deps = depsMap.get(key); if(!deps){ depsMap.set(key, (deps = new Set())) } // 最后将activeEffect加入到key对应的Set当中 deps.add(activeEffect); // 将 集合 Set 的引用推入 副作用函数的deps集合里头 ➕ activeEffect.caller.deps.push(deps); // ➕ } 改造effect - 2，实现cleanup清除函数上面提到，要在副作用函数执行之前，将事先收集到的deps中的所有对应的Set中someFn删掉 function cleanup(effectFn){ for (let i = 0; i &lt; effectFn.caller.deps.length; i++) { const deps = effectFn.deps[i]; // 将 effectFn 从依赖集合从移除 deps.delete(effectFn) } // 最后重置一下 deps effectFn.deps.length = 0 } // 注册函数 function effect(fn){ const effectFn = ()=&gt;{ cleanup(effectFn) activeEffect = effectFn; fn(); } // 用于存储所有与该副作用函数相关的依赖合集 bucket桶中 key---&gt; Set 的 Set集合 effectFn.deps = []; effectFn(); } 改造trigger函数因为在副作用执行之前，我们调用cleanup清除包含副作用函数的所有Set，但是执行之后又收集了进去。问题就在这里，我们在trigger的时候，去遍历这个Set执行fn（使用的foreach） foreach在遍历Set的时候，如果，一个值虽然被访问了，但是在遍历过程中被删除了，又被重新的添加到了集合当中，如果遍历过程还没有结束的话，就会重新被访问，一直在遍历，所以需要改造一下 function trigger(target, key){ // 根据target引用从桶中取得对应的Map const depsMap = bucket.get(target); if(!depsMap) return; // 取得target 上key对应的Set数据，遍历，执行里头的副作用 const effects = depsMap.get(key); if(effects){ effects.forEach(fn =&gt; fn()); // 问题所在， 遍历的时候在执行副作用，执行的时候又被收集进去到同一个Set当中了，所以我们可以使这个遍历的effects Set更换为另外一个引用 } } 改造后 function trigger(target, key){ // 根据target引用从桶中取得对应的Map const depsMap = bucket.get(target); if(!depsMap) return; // 取得target 上key对应的Set数据，遍历，执行里头的副作用 const effects = depsMap.get(key); if(effects){ const effectsClone = new Set(effects) // ➕ effectsClone.forEach(fn =&gt; fn()); // ➕ } } 这样，重新的创建一个Set的集合，就可以避免无限递归的情况了 const data = { a: true, b: &quot;weng&quot;, }; const obj = new Proxy(data, { get(target, key) { track(target, key); // 返回函数属性 return target[key]; }, set(target, key, newVal) { target[key] = newVal; trigger(target, key); }, }); function someFn() { console.log(obj.a ? obj.b : &quot;yes!&quot;); console.log(&quot;触发了&quot;, bucket); } effect(someFn); obj.a = false; setTimeout(() =&gt; { obj.b = &quot;kaimin&quot;; // 修改b值的时候，不会再触发someFn了 }, 1000); 考虑嵌套执行的情况 在MVVM或者MVC的框架中，都会存在，多层组建嵌套的情况 在vue中的每一个组建，其实都是存在一个render函数的。 多层组建之间的嵌套，在vue中又涉及到了响应式的数据，因此可以当作每一个组建如果使用到了响应式的数据，每一个render的函数其实都是可以看成是需要在数据变更时候重新执行的副作用 组建之间发生了嵌套，可以看成 // 组建B const B = { render(){ return {.....} } } // 组建A const A = { render(){ return &lt;B /&gt; } } // 由于A中嵌套了B，所以可以理解为 effect(()=&gt;{ A.render(); effect(()=&gt;{ B.render(); }) }) 这种类似的嵌套情况是非常常见的；但是我们目前的系统是不支持嵌套的 例： const data = { a:true, b:false }; const obj = new Proxy(data, {....}); let temp1, temp2; function innerFn() { console.log(&quot;run effect inner&quot;); temp2 = obj.b; } function outerFn() { console.log(&quot;run effect outer&quot;); effect(innerFn); temp1 = obj.a; } effect(outerFn); setTimeout(() =&gt; { obj.a = 3; }, 2000); 常理上我们，理想我们需要这种收集的情况 初始化执行结果是这样的 run effect outer run effect inner 这时候，我们去改动obj.a的值 输出的结果为 run effect inner 发现外层的effect函数并没有执行，而只是执行了内层的 这是由于，我们的effect副作用的包裹函数的问题： let activeEffect; // 注册函数 function effect(fn){ const effectFn = ()=&gt;{ cleanup(effectFn) activeEffect = effectFn; fn(); } // 用于存储所有与该副作用函数相关的依赖合集 bucket桶中 key---&gt; Set 的 Set集合 effectFn.deps = []; effectFn(); } 每次执行副作用函数的时候之前，会将副作用函数引用赋值给全局遍历activeEffect，而且activeEffect在同一时刻有且仅有一个。 由于发生了嵌套，第二次执行的副作用函数直接覆盖了上一层赋值的activeEffect 在track函数中，最终收集到的是内层的innerEffect副作用 使用副作用函数栈因为嵌套存在多层的情况，所以，考虑用一个副作用的函数栈 进行存储之前的副作用函数，保证不会丢失上一层的副作用函数 每次的执行之前，将副作用函数压入这个栈当中，等副作用函数执行完之后，再将当前执行完的这个副作用函数从栈中弹出， 并始终将activeEffect这个全局（正被激活的副作用函数）指向这个栈顶 // 全局加入effectStack栈结构 let effectStack=[] 上述例子的流程如下： image-20220820144311868 改造effect函数 // 注册函数 function effect(fn){ const effectFn = ()=&gt;{ cleanup(effectFn) // 当调用effect注册副作用函数时，将副作用函数复制给activeEffect activeEffect = effectFn; // 在调用副作用函数之前将当前副作用函数压入栈中 effectStack.push(effectFn) // ➕ fn(); effectStack.pop(); // ➕ // 执行完之后，弹出栈，并把activeEffect还原为之前的值, 指向栈顶 activeEffect = effectStack[effectStack.length - 1] // ➕ } // 用于存储所有与该副作用函数相关的依赖合集 bucket桶中 key---&gt; Set 的 Set集合 effectFn.deps = []; effectFn(); } 修改之后，我们会发现，修改了a的属性之后，会正常打印两次数据 考虑自增（自减）值的情况 自增就是例如obj.a++这样的 这种情况，等价于 obj.a = obj.a + 1 const data = { a: 1, }; const obj = new Proxy(data, { get(target, key) { track(target, key); // 返回函数属性 return target[key]; }, set(target, key, newVal) { target[key] = newVal; trigger(target, key); }, }); function someFn() { console.log((obj.a = obj.a + 1)); } effect(someFn); 这种情况就是既读取了obj.a的值，又设置了obj.a的值，会直接爆栈，原因如下 初始化的时候，我们执行副作用函数（这里我们叫做A，表示初始化的时候执行的），首先读取了obj.a的值，触发了track函数，会将当前的副作用函数收集到桶中。 接着将其 + 1之后 重新设置obj.a的值的时候，被setter拦截，这时候触发了trigger函数，把副作用函数（这里叫做B，表示赋值造成的第二次执行）从桶中取出执行 但是这个时候初始化的那次副作用函数（A）还在执行，赋值操作只会再次触发被收集的副作用函数（产生了B），因此会无限的递归赋值操作到爆栈 增加守卫其实，这种情况很普遍，不单单是自增的情况，也有可能副作用函数读取obj.a之后，经过一番处理进行了重新赋值。 function someFn(){ const b = obj.a + ....; obj.a = b; } 造成上述的递归，是因为不断的调用自身的副作用函数造成的 所以我们在第三步骤执行的时候，加一个守卫，如果当前正在执行的副作用函数和trigger触发的副作用函数相同，则不执行 改造trigger函数 function trigger(target, key){ // 根据target引用从桶中取得对应的Map const depsMap = buckect.get(target); if(!depsMap) return; // 取得target 上key对应的Set数据，遍历，执行里头的副作用 const effects = depsMap.get(key); const effectsToRun = new Set(); if(effects){ effects.forEach((current)=&gt;{ if(current !== activeEffect){ // 如果当前trigger执行的，和activeEffect不一样，加入 effectsToRun.add(current) } }) } effectsToRun.forEach((fn)=&gt;fn()) } 改造之后，就可以正常的进行副作用函数的收集和执行了 const data = { a: 1, }; const obj = new Proxy(data, { get(target, key) { track(target, key); // 返回函数属性 return target[key]; }, set(target, key, newVal) { target[key] = newVal; trigger(target, key); }, }); function someFn() { console.log((obj.a = obj.a + 1)); // 不会爆栈了 } effect(someFn); setTimeout(()=&gt;{ obj.a = 3; // 正常触发收集到的副作用函数 }) 考虑调度实现响应式系统比较重要的就是，一个可调度性，可调度性可以将控制权力交接给用户。 可调度性：有能力 决定副作用函数执行时机，执行次数，以及执行方式 比如修改了obj.a的值，执行顺序是 function someFn(){ console.log(obj.a) } effect(someFn) obj.a++; console.log(&#39;我是分割&#39;); // 1 // 2 // 我是分割 假如我想调整打印的顺序，需要在某些条件延迟去执行这个副作用函数 // 1 // 我是分割 // 2 我们可以这样设计 给effect函数加上调度的参数 effect(effectFn, options) options = { scheduler(effectFn){ .... } } 因此，可以想到，我们在trigger函数中进行副作用函数执行的时候，如果有调度器，我们就去执行用户传递进来的调度器，将副作用函数的执行权利抛给外界控制 effect加入调度函数参数加入options，挂载到effectFn上 // 注册函数 function effect(fn, options){ // ➕ const effectFn = ()=&gt;{ cleanup(effectFn) // 当调用effect注册副作用函数时，将副作用函数复制给activeEffect activeEffect = effectFn; // 在调用副作用函数之前将当前副作用函数压入栈中 effectStack.push(effectFn) fn(); // 执行完之后，弹出栈，并把activeEffect还原为之前的值, 指向栈顶 activeEffect = effectStack[effectStack.length - 1] // ➕ } // 将调度相关的参数加入到副作用函数当中 effectFn.options = options; // ➕ // 用于存储所有与该副作用函数相关的依赖合集 bucket桶中 key---&gt; Set 的 Set集合 effectFn.deps = []; effectFn(); } trigger触发调度遍历 执行副作用函数的时候，去判定是否具有调度器，有调度器就执行调度器，并将副作用函数执行权力交给用户，否则就默认执行副作用函数 function trigger(target, key){ // 根据target引用从桶中取得对应的Map const depsMap = buckect.get(target); if(!depsMap) return; // 取得target 上key对应的Set数据，遍历，执行里头的副作用 const effects = depsMap.get(key); const effectsToRun = new Set(); if(effects){ effects.forEach((current)=&gt;{ if(current !== activeEffect){ // 如果当前trigger执行的，和activeEffect不一样，加入 effectsToRun.add(current) } }) } effectsToRun.forEach((fn)=&gt;{ if(fn.options.scheduler){ // ➕ fn.options.scheduler(fn) // ➕ }else{ fn() } }) } 上述的例子就可以这样实现了 const data = { a: 1, }; const obj = new Proxy(data, { get(target, key) { track(target, key); // 返回函数属性 return target[key]; }, set(target, key, newVal) { target[key] = newVal; trigger(target, key); }, }); function someFn() { console.log(obj.a); } effect(someFn, { scheduler(fn) { setTimeout(() =&gt; { fn(); }, 0); }, }); obj.a++; console.log(&quot;我是分割&quot;); 考虑防抖情况在vue3中，我们多次在一次执行中，例如对obj.a做了3次赋值操作 const data = { a: 1 }; const obj = new Proxy(data, {...}); function someFn(){ console.log(obj.a) } effect(someFn) obj.a++; obj.a++; obj.a++; 3次的自增操作，vue3中只会打印2次 1 // 第一次是初始化的时候打印的 4 但是我们的系统会打印4次 1 2 3 4 其实我们关注的只是最后的结果，所以第2 3次的打印数据我们并不关心； 因此我们可以基于调度器，接入防抖系统 微任务队列实现防抖// 定义任务队列 const jobQueue = new Set(); // 使用promise.resolve创建微任务，添加到微任务队列 const p = Promise.resolve(); // 一个标志代表是否正在刷新队列 let isFlushing = false; function flushJob(){ // 如果队列正在刷新，则什么都不做 if(isFlushing) return; // 设置true, 代码正在刷新 isFlushing = true; // 在微任务队列中刷新 jobQueue 队列 p.then(()=&gt;{ jobQueue.forEach((fn =&gt; fn())) }).finally(()=&gt;{ // 结束后重置isFlushing isFlushing = false; }) } effect(someFn, { scheduler(fn){ // 每次调度时，将副作用函数添加到jobQueue队列中 jobQueue.add(fn); // 调用 flushJob 刷新队列 flushJob(); } }) 定一个任务队列jobQueue —&gt; Set，目的是利用Set数据结构的自动去重能力。 scheduler在每次调用一个副作用函数的时候，将 副作用函数加入jobQueue，然后再调用flushJob刷新队列 flushJob函数开始执行的时候，通过isFlushing字段进行限制，只有false的时候才执行；在进行的时候就是true 这样可以知道，无论我们走了多少次的flushJob，每个微任务的周期内都会执行一次；之后在微任务队列里头完成对jobQueue的遍历 多次修改响应式的值，其实在vue中也是类似这样的实现，只是比这个更完善 如上的例子就可以实现防抖的效果了 const data = { a: 1 }; const obj = new Proxy(data, {...}); function someFn(){ console.log(obj.a) } effect(someFn, { scheduler(fn) { jobQueue.add(fn); flushJob(); }, }) obj.a++; obj.a++; obj.a++; // 最终只会打印1 4 总结下来的代码： let activeEffect; const effectStack = []; const buckect = new WeakMap(); const source = { a: &#39;wengkaimin&#39;, b: &#39;weng&#39; } // 定义任务队列 const jobQueue = new Set(); // 使用promise.resolve创建微任务，添加到微任务队列 const p = Promise.resolve(); // 一个标志代表是否正在刷新队列 let isFlushing = false; function flushJob(){ // 如果队列正在刷新，则什么都不做 if(isFlushing) return; // 设置true, 代码正在刷新 isFlushing = true; // 在微任务队列中刷新 jobQueue 队列 p.then(()=&gt;{ jobQueue.forEach((fn =&gt; fn())) }).finally(()=&gt;{ // 结束后重置isFlushing isFlushing = false; }) } function cleanup(effectFn){ for (let i = 0; i &lt; effectFn.deps.length; i++) { const deps = effectFn.deps[i]; // 将 effectFn 从依赖集合从移除 deps.delete(effectFn) } // 最后重置一下 deps effectFn.deps.length = 0 } // 注册函数 function effect(fn, options){ // ➕ const effectFn = ()=&gt;{ cleanup(effectFn); // 当调用effect注册副作用函数时，将副作用函数复制给activeEffect activeEffect = effectFn; // 在调用副作用函数之前将当前副作用函数压入栈中 effectStack.push(effectFn); fn(); // 执行完之后，弹出栈，并把activeEffect还原为之前的值, 指向栈顶 activeEffect = effectStack[effectStack.length - 1]; // ➕ } // 将调度相关的参数加入到副作用函数当中 effectFn.options = options; // ➕ // 用于存储所有与该副作用函数相关的依赖合集 bucket桶中 key---&gt; Set 的 Set集合 effectFn.deps = []; effectFn(); } function someFn(){ console.log(source.a) } function someFn2(){ console.log(source.a) } effect(someFn, { scheduler(fn){ // 每次调度时，将副作用函数添加到jobQueue队列中 jobQueue.add(fn); // 调用 flushJob 刷新队列 flushJob(); } }) function track(target,key){ // 如果没有 activeEffect说明没有注册过这个副作用函数，直接return if(!activeEffect) return; // 根据targt代理引用，取得它对应的map，对应关系target --- &gt; Map let depsMap = buckect.get(target); // 假如说这个map不存在，那么就new一个map，与target引用关联 if(!depsMap) { buckect.set(target, (depsMap = new Map())) } // 再根据key从map中取得key对应的Set，key ---&gt; Set // Set里头存储了这个key对应的副作用函数 let deps = depsMap.get(key); if(!deps){ depsMap.set(key, (deps = new Set())) } // 最后将activeEffect加入到key对应的Set当中 deps.add(activeEffect); // 将 集合 Set 的引用推入 副作用函数的deps集合里头 activeEffect.deps.push(deps); } function trigger(target, key){ // 根据target引用从桶中取得对应的Map const depsMap = buckect.get(target); if(!depsMap) return; // 取得target 上key对应的Set数据，遍历，执行里头的副作用 const effects = depsMap.get(key); const effectsToRun = new Set(); if(effects){ effects.forEach((current)=&gt;{ if(current !== activeEffect){ // 如果当前trigger执行的，和activeEffect不一样，加入 effectsToRun.add(current) } }) } effectsToRun.forEach((fn)=&gt;{ if(fn.options.scheduler){ // ➕调度器 fn.options.scheduler(fn) // ➕调度器 }else{ fn() } }) } const obj = new Proxy(data, { get(target, key){ track(target,key) // 返回函数属性 return target[key] }, set(target, key, newVal){ target[key] = newVal; trigger(target, key) } }) Step3: 实现lazy+computed综上所说的，副作用函数，其实在我们目前的系统都是会立即执行的，但是其实有些情况下我们是不需要去做立刻执行我们的副作用函数的 所以结合上面的options副作用函数的参数，其实能够和调度器一样去实现我们的lazy的能力。 effect(()=&gt;{ console.log(obj.a) },{ scheduler(){....}, lazy:true // ➕ }) 实现lazy效果 - 改造effect函数当我们判断lazy字段为true的时候，我们就不立即执行effect函数 // 注册函数 function effect(fn, options){ const effectFn = ()=&gt;{ cleanup(effectFn); // 当调用effect注册副作用函数时，将副作用函数复制给activeEffect activeEffect = effectFn; // 在调用副作用函数之前将当前副作用函数压入栈中 effectStack.push(effectFn); fn(); effectStack.pop(); // 执行完之后，弹出栈，并把activeEffect还原为之前的值, 指向栈顶 activeEffect = effectStack[effectStack.length - 1]; } // 将调度相关的参数加入到副作用函数当中 effectFn.options = options; // 用于存储所有与该副作用函数相关的依赖合集 bucket桶中 key---&gt; Set 的 Set集合 effectFn.deps = []; // ➕ 如果options中 lazy为false，才立即执行副作用函数 if(!options.lazy){ effectFn(); } return effectFn // ➕将副作用函数作为返回值返回出去 } 但是其实，作为返回值，返回副作用函数其实意义不大的，因为你还得手动执行 const effectFn = effect(someFn, { lazy:true // ➕ }) effectFn() 所以我们引出computed 实现computed但是假如说，我们的someFn，也就是副作用函数是一个 有返回值的 函数，类似 getter，那么我们就有意思了 function someFn(){ return obj.a + 1; } const effectFn = effect(someFn, { lazy:true // ➕ }) const value = effectFn() 因此我们可以去除手动执行的这个逻辑，执行的时候，将执行结果返回。 去实现一个computed的工厂函数 function computed(getter){ // 把getter 作为副作用函数，创建一个lazy的effect const effectFn = effect(getter, { lazy: true }) const obj = { get value(){ return effectFn() // 手动执行 } } return obj } const testA = computed(()=&gt;{ return obj.a + 1 }) computed函数接受一个函数，返回值是一个对象，包含一个value属性。getter函数作为参数，然后getter其实就是副作用函数，用他创建一个lazy的effectFn，然后我们定一个obj，在访问obj的时候去执行getter。 改造effect函数我们在effectFn函数调用的时候，将执行结果返回出去 // 注册函数 function effect(fn, options){ const effectFn = ()=&gt;{ cleanup(effectFn); // 当调用effect注册副作用函数时，将副作用函数复制给activeEffect activeEffect = effectFn; // 在调用副作用函数之前将当前副作用函数压入栈中 effectStack.push(effectFn); const res = fn(); // ➕ effectStack.pop(); // 执行完之后，弹出栈，并把activeEffect还原为之前的值, 指向栈顶 activeEffect = effectStack[effectStack.length - 1]; return res; // ➕ 将函数执行结果返回出去，实现getter的效果 } // 将调度相关的参数加入到副作用函数当中 effectFn.options = options; // 用于存储所有与该副作用函数相关的依赖合集 bucket桶中 key---&gt; Set 的 Set集合 effectFn.deps = []; // 如果options中 lazy为false，才立即执行副作用函数 if(!options.lazy){ effectFn(); } return effectFn // 将副作用函数作为返回值返回出去 } 总结下来，就是lazy配合getter实现一套computed函数 试验一下，就可以实现computed的效果了 const data = { a: 1, }; const obj = new Proxy(data, { get(target, key) { track(target, key); // 返回函数属性 return target[key]; }, set(target, key, newVal) { target[key] = newVal; trigger(target, key); }, }); function someFn() { console.log(&quot;执行了getter&quot;); return obj.a + 1; } const computedData = computed(someFn); console.log(computedData.value); setTimeout(() =&gt; { obj.a = 3; // 在改变值得的时候也会做到同步的重新计算 }, 2000); 实现缓存 优化如上的例子，假如我们读取了两次computedData const data = { a: 1, }; const obj = new Proxy(data, { get(target, key) { track(target, key); // 返回函数属性 return target[key]; }, set(target, key, newVal) { target[key] = newVal; trigger(target, key); }, }); function someFn() { console.log(&quot;执行了getter&quot;); return obj.a + 1; } const computedData = computed(someFn); console.log(computedData.value); setTimeout(() =&gt; { console.log(computedData.value); }, 2000); 会发现，执行了两次的getter 执行了getter 2 执行了getter 2 我们并没有对a的值进行修改，而是重复读取了而已 原因如下： 当我们读取 computedData值的时候，才会去执行getter副作用函数。 但是目前的实现，我们在每次读取 computedData的时候其实都会将getter副作用函数重新执行一遍，就算是obj.a没有变化的情况下。 所以，我们在obj.a没有变化的时候，我们其实并不需要去重新执行副作用函数，我们只需要将第一次读取的值缓存下来就可以了。 改造computed函数加入缓存，我们可以再computed中，在第一次计算的时候加入缓存字段 - value，通过dirty表示判断，是否需要重新计算新的值，结合调度器参数，在依赖改变的时候，去回归dirty参数 function computed(getter){ let value; // ➕ 缓存值 let dirty = true; // true表示需要重新计算值 ➕ // 把getter 作为副作用函数，创建一个lazy的effect const effectFn = effect(getter, { lazy: true, scheduler(){ // ➕ dirty = true; // 执行调度，trigger执行的时候，重新触发调度 } }) const obj = { get value(){ if(dirty){ value = effectFn();// 手动执行 dirty = false; // 设置为false ➕ } return value // ➕ } } return obj } 这样我们就能将计算值缓存起来。 如下的例子： const data = { a: 1, }; const obj = new Proxy(data, { get(target, key) { track(target, key); // 返回函数属性 return target[key]; }, set(target, key, newVal) { target[key] = newVal; trigger(target, key); }, }); function someFn() { console.log(&quot;执行了getter&quot;); return obj.a + 1; } const computedData = computed(someFn); console.log(computedData.value) obj.a = 8; 我们先访问了computedData，会进行一层计算，此刻得值为2 之后我们修改了obj.a的值，会去走getter - 也就是someFn，因为存在调度器，所以这时候执行的是someFn的调度，将dirty设置为了true 所以在下一次访问computedData.value的时候，就会重新计算； 当然，如果没有去调用obj.a的赋值操作，这时候访问的computedData的时候就不会重新计算getter 嵌套读取计算属性值 缺陷我们使用计算属性的时候，经常会在模板或者是另外一个副作用函数里头使用，例如 const data = { a: 1, b: 2, }; const obj = new Proxy(data, { get(target, key) { track(target, key); // 返回函数属性 return target[key]; }, set(target, key, newVal) { target[key] = newVal; trigger(target, key); }, }); function someFn() { console.log(&quot;执行了getter&quot;); return obj.a + obj.b; } const computedData = computed(someFn); function effectOuter() { console.log(computedData.value); } effect(effectOuter); setTimeout(() =&gt; { obj.a++; }, 2000); 另外一个effect函数中读取了计算数据，当我们修改了obj.a的值之后，发现并不会 打印出 computedSum.value之后的值 回头看computed函数，会发现，getter函数使用到了obj.a和obj.b，getter被收集到了a,b对应的Set当中 image-20220826163739163.png getter是一个副作用函数，也是是被effect包裹并且处理为懒执行的函数 如上的情况，就是发生了嵌套，外层的effect包裹了内层effect，而外层的effect真正读取的是computedSum.value，而这玩意并不是响应式数据，也无法收集到这个外层effect包裹的这个函数。 而真正外层副作用函数读取的引用是computed内层的这个数据 computedSum.value —&gt; obj.value const obj = { get value(){ if(dirty){ value = effectFn();// 手动执行 dirty = false; // 设置为false ➕ } return value // ➕ } } 所以为了能够追踪到读取计算属性的副作用函数，我们可以手动嵌入 track和trigger，用于obj的追踪和触发，追踪的是obj对象的key 为value 改造computed函数function computed(getter){ let value; // let dirty = true; // true表示需要重新计算值 // 把getter 作为副作用函数，创建一个lazy的effect const effectFn = effect(getter, { lazy: true, scheduler(){ dirty = true; // 执行调度，trigger执行的时候，重新触发调度 // 当计算属性依赖的响应式数据发生变化的时候，手动的去调用trigger函数触发相应 trigger(obj, &#39;value&#39;) // ➕ } }) const obj = { get value(){ if(dirty){ value = effectFn();// 手动执行 dirty = false; // 设置为false } track(obj, &#39;value&#39;); // 当读取这个value值的时候，手动调用track函数 // ➕ return value; } } return obj } 因此这样就可以解决读取计算属性的问题了。 const data = { a: 1, b: 2 }; const obj = new Proxy(data, {...}); const computedData = computed(()=&gt; obj.a + obj.b); effect(function effectOuter(){ console.log(computedData.value) }) setTimeout(()=&gt;{ obj.a++; }, 2000) 这就样可以打印出修改的之后的computed的值了，并且执行副作用函数 他们之间的依赖关系就如图所示 image-20220829150759429.png Step4: 实现watchvue3中的wacth函数用法 wactch(obj, ()=&gt;{ console.log(&#39;变化数据&#39;) }) // 修改 obj.a++; 观测obj的值的改变，从而触发数据变化 主要是由两个参数，第一个是观测的数据，第二个是数据变化时候触发的回调函数 watch的实现本质就是利用了effect函数options.scheduler调度器选项。 可以理解为： effect(()=&gt;{ console.log(obj.a) }, { scheduler(){ // 当obj.a变化的时候，执行调度函数 } }) 从之前的调度器属性可以看到，当存在调度器的时候，数据变化会触发调度器的执行 首先要先读取watch的那个数据。 原始值如何处理 对象递归处理 目前暂时不考虑其他的数据结构 watch的回调函数，可以直接加入调度器中执行，利用effect的getter骚操作进行响应式数据的track，但是最终trigger触发的副作用函数并不是getter，而是调度器 假如是如下的场景 const data = { a: 1, }; const obj = new Proxy(data, { get(target, key) { track(target, key); // 返回函数属性 return target[key]; }, set(target, key, newVal) { target[key] = newVal; trigger(target, key); }, }); watch(obj, () =&gt; { console.log(&quot;改变了值&quot;); }); setTimeout(() =&gt; { obj.a = 2; }, 2000); 这个时候去改变a的值，希望能够实现和vue中的一样，直接执行这个回调函数 基础实现scheduler + effect effect进行数据的读取追踪，scheduler作为调度器 // wacth基本 function watch(source, callback){ effect(()=&gt; traverse(source),{ scheduler(){ callback() } }) } 首先我们要对watch的数据进行读取 source在这里指的是 数据源 实现traverse封装一个通用的读取操作，能够保证source能够被完全的读取 function traverse(value, seen = new Set()){ // 如果要读取的数据是原始值，或者已经被读取过了，那么什么都不做 if(typeof value !== &#39;object&#39; || value === null || seen.has(value)) return // 将数据添加到seen中，代表遍历的时候读取过了，避免循环引用 seen.add(value); // 。。。。目前不考虑数组等其他数据结构 // 假设value是一个对象，使用for...in...读取对象的每一个值，递归调用traverse for (const key in value) { traverse(value[key], seen) } return value; } seen: 是一个Set结构， 这块防止重复读取引用类型数据造成stack overflow 这里直接考虑vue中deep的情况，目前暂时不考虑其他的数据结构，只考虑对象类型 函数类型兼容在vue中，watch第一个参数还能是一个getter，在getter内部，可以指定wacth哪些响应式数据，只有数据变化的时候，才会触发回调 watch(()=&gt;obj.a,()=&gt;{ console.log(&#39;修改了值&#39;) }) 因此对source类型做判断，改造watch // wacth基本 function watch(source, callback) { // 定义一个getter let getter; // ➕ // 如果source为函数, 说明传进来了getter，所以source直接等于getter if (typeof source === &quot;function&quot;) { // ➕ getter = source; } else { getter = () =&gt; traverse(source); } effect(() =&gt; getter(source), { scheduler() { callback(); }, }); } 这样我们在修改a值得时候就可以如愿检测到数据变化并且执行回调函数 const data = { a: 1, }; const obj = new Proxy(data, { get(target, key) { track(target, key); // 返回函数属性 return target[key]; }, set(target, key, newVal) { target[key] = newVal; trigger(target, key); }, }); watch(obj, () =&gt; { console.log(&quot;改变了值&quot;); }); // or ()=&gt; obj.a setTimeout(() =&gt; { obj.a = 2; }, 2000); 新值和旧值在vue中使用watch的时候，经常需要 知道新的值 和旧的值 传入回调函数之中 watch(obj, (newVal, oldVal) =&gt; { console.log(&quot;改变了值&quot;, newVal, oldVal); }); 所以需要实现一下这种能力 需要知道的点 新值和旧值都是 getter函数触发最终的return结果 新值和旧值需要传入我们的callback函数当中作为参数提供给外界 需要存储新值和旧值 需要加入lazy属性，创建懒执行effect 改造watch// wacth基本 function watch(source, callback) { // 定义一个getter let getter; // 如果source为函数, 说明传进来了getter，所以source直接等于getter if (typeof source === &quot;function&quot;) { getter = source; } else { getter = () =&gt; traverse(source); } let oldValue; // ➕ 旧值 let newValue; // ➕ 新值 const effectFn = effect(() =&gt; getter(source), { lazy: true, // ➕ scheduler() { newValue = effectFn(); // 将执行结果返回给新值 ➕ 🐂👃 callback(newValue, oldValue); oldValue = newValue; // 每次记录上一次的值 ➕ }, }); } 这里最核心的地方就是使用到了lazy创建懒执行的effect； 如下这个例： const data = { a: 1, }; const obj = new Proxy(data, { get(target, key) { track(target, key); // 返回函数属性 return target[key]; }, set(target, key, newVal) { target[key] = newVal; trigger(target, key); }, }); watch( () =&gt; obj.a, (newVal, oldVal) =&gt; { console.log(&quot;改变了值&quot;, oldVal, &quot;---&gt;&quot;, newVal); } ); setTimeout(() =&gt; { obj.a = 2; }, 2000); 这样的话就可以记录下来旧值了 立即执行vue3中的watch能够通过 immediate参数立即进行执行 当immediate参数胃true的时候，回调函数就会在watch函数执行的时候，立刻执行一次回调函数 所以我们可以改造下watch加入immediate配置项 // wacth function watch(source, callback, options = {}) { // 定义一个getter let getter; // 如果source为函数, 说明传进来了getter，所以source直接等于getter if (typeof source === &quot;function&quot;) { getter = source; } else { getter = () =&gt; traverse(source); } let oldValue; // ➕ 旧值 let newValue; // ➕ 新值 // 提取scheduler调度函数为一个独立的job函数 const job = () =&gt; { newValue = effectFn(); // 将执行结果返回给新值 ➕ callback(newValue, oldValue); oldValue = newValue; // 每次记录上一次的值 ➕ }; const effectFn = effect(() =&gt; getter(source), { lazy: true, // ➕ scheduler: job, }); if (options.immediate) { job(); } else { oldValue = effectFn(); // 不是immediate的时候，其实只是将getter第一次的执行结果保存为oldValue，并不执行callback } } 由于是立即执行，所以第一次没有oldValue是正常的 回调的时机 处理立即执行之外，vue中还能指定回调函数的执行时机，通过flush参数进行限制 flush： ’pre‘ ‘post’ ‘sync’ ‘pre’的执行时机暂时先不处理，后续可以加上，因为涉及到组件的更新时机。 ‘sync‘的话相当于同步执行 ‘post’则是代表调度的函数需要将副作用函数放到一个微任务队列中，等dom更新后进行执行 改造watch// wacth function watch(source, callback, options = {}) { // 定义一个getter let getter; // 如果source为函数, 说明传进来了getter，所以source直接等于getter if (typeof source === &quot;function&quot;) { getter = source; } else { getter = () =&gt; traverse(source); } let oldValue; // let newValue; // // 提取scheduler调度函数为一个独立的job函数 const job = () =&gt; { newValue = effectFn(); // 将执行结果返回给新值 callback(newValue, oldValue); oldValue = newValue; // 每次记录上一次的值 }; const effectFn = effect(() =&gt; getter(source), { lazy: true, scheduler: ()=&gt; { if(options.flush === &#39;post&#39;){ // ➕ const p = Promise.resolve(); // ➕ p.then(job) // ➕ }else{ job() } }, }); if (options.immediate) { job(); } else { oldValue = effectFn(); // 不是immediate的时候，其实只是将getter第一次的执行结果保存为oldValue，并不执行callback } } 我们在调度器触发的时候，检测flush的类型，进而进行不一样的执行步骤 *竞态情况例如如下的情况 let data; watch(obj, async ()=&gt;{ // 发送请求网络请求 const res = await axios.get(&#39;/getData&#39;); data = res }) 我们修改了obj的某个值，会触发getData的请求，假如，我们在短时间内连续修改了，obj的属性两次，其实会触发两次getData的请求 假设第一次叫做A，第二次叫做B。因为两次请求落地的时机不相同，可能B会比A先落定，但是由于，我们第二次修改触发的请求得到的结果，才是我们真实想要的，但是由于AB落定时机不确定，我们无法明确最终是哪一次请求的值赋给了data。这种就存在了竞态的情况 image-20220831114324906.png 由于B才是我们真正想要的结果，所以 我们可以当B为 “最新”，A为“过期”的副作用函数产生的 在vue中watch的回调函数有第三个参数，叫做onInvalidate，这个函数就是当前副作用函数过期的时候执行的回调 watch(obj, async (newValue, oldValue, onInvalidate)=&gt;{ // 定义一个标志， 代表当前副作用函数是否过期，默认为false，代表没有过期 let expired = false; // 调用onInvalidate()函数注册一个过期的回调 onInvalidate(()=&gt; { // 当过期的时候，将expired的字段设置为true expired = true }) // 获取server数据 const res = await axios.get(&#39;/getData&#39;); // 只有当该副作用函数的执行没有过期的时候，才会执行后续的操作 if(!expired){ data = res; } }) 通过expired的变量标识，判断当前副作用是不是过期了。没有过期才采用请求结果 onInvalidate的原理，就是每次watch内部每次检测到变化的时候，在副作用函数执行之前，首先调用onInvalidate就可以了 因此我们可以在watch函数的内部加入onInvalidtae的逻辑 改造watch// wacth function watch(source, callback, options = {}) { // 定义一个getter let getter; // 如果source为函数, 说明传进来了getter，所以source直接等于getter if (typeof source === &quot;function&quot;) { getter = source; } else { getter = () =&gt; traverse(source); } let cleanupEffect; // ➕ let oldValue; // 旧值 let newValue; // 新值 function onInvalidate(fn){ // ➕ // 将过期的回调存储到 cleanupEffect中，以方便下一次触发回调之前调用 cleanupEffect = fn; } // 提取scheduler调度函数为一个独立的job函数 const job = () =&gt; { newValue = effectFn(); // 将执行结果返回给新值 // 在调用回调函数callback之前，先调用过期的回调函数 if(cleanupEffect){ // ➕ cleanupEffect() // ➕ } callback(newValue, oldValue, onInvalidate); // ➕ oldValue = newValue; // 每次记录上一次的值 }; const effectFn = effect(() =&gt; getter(source), { lazy: true, scheduler: ()=&gt; { if(options.flush === &#39;post&#39;){ const p = Promise.resolve(); p.then(job) }else{ job() } }, }); if (options.immediate) { job(); } else { oldValue = effectFn(); // 不是immediate的时候，其实只是将getter第一次的执行结果保存为oldValue，并不执行callback } } 引入onInvalidate的注册函数，每次执行job的时候，都会去提前查看之前是否注册过cleanupEffect，有的话在执行之前需要去执行一遍。 方便理解的一个例子例如如下场景 watch(obj, async (newValue, oldValue, onInvalidate)=&gt;{ // 定义一个标志， 代表当前副作用函数是否过期，默认为false，代表没有过期 let expired = false; // 调用onInvalidate()函数注册一个过期的回调 onInvalidate(()=&gt; { // 当过期的时候，将expired的字段设置为true expired = true }) // 获取server数据 const res = await axios.get(&#39;/getData&#39;); // 只有当该副作用函数的执行没有过期的时候，才会执行后续的操作 if(!expired){ data = res; } }) // 第一次修改 obj.a++; setTimeout(()=&gt;{ obj.a++; },200) 以上代码我们修改了两次obj.a 第一次sync立即执行，导致watch的回调执行。在回调内部，我们调用了onInvalidate，这时候就会在watch内部注册一个cleanupEffect，然后发送请求A（假设A用了2000ms才返回） 第二次200ms后又修改了obj.a，又执行了watch的回调函数，这时候由于第一次已经注册了一个cleanupEffect，在job执行之前呢，其实会先去处理之前注册的回调函数，这时候之前的那个闭包变量expired就会被设置为true，之后就算是A请求落定了，也不会进行data的赋值操作 Step5: 深入代理前置知识 Vue3中利用的是Proxy以及Reflect去代理对象的 我们知道Proxy是只能代理对象类型的，非对象类型不可以进行代理 所谓代理： 指的是对一个 对象 的 基本语义 的代理 何为proxy基本语义比如我们对对象的一堆简单操作 console.log(obj.a); // 读取属性操作 obj.a++; // 设置属性值操作 类似这种读取，设置属性值的操作，就是属于基本的语义操作 —- 基本操作 类似这种的基本操作就可以用Proxy进行代理拦截 基本操作的基本用法 const data = new Proxy(obj, { // 拦截读取属性操作 get(){ .... }, // 拦截设置属性操作 set(){ .... } }) 例如函数：我们也可以使用apply对函数进行拦截 const fn = ()=&gt;{ console.log(&#39;wengkaimin&#39;) } const proFn = new Proxy(fn, { apply(target, thisArg, argArray){ target.call(thisArg, ...argArray) } }) proxy复合操作既然有基本操作，可以也有非基本操作，在js里头，我们叫他复合操作 obj.fn() 这个显而易见，是又多个语义构成的（调用一个对象的一个函数属性）、 两个语义是： 首先通过get获取到obj的fn属性 通过获取到的fn进行调用 Reflect基本改造getter Reflect是一个全局对象，其中存在和Proxy的拦截器很多名字相同的方法 如下的等价操作 const obj = { a: &#39;wengkaimin&#39; }; console.log(obj.a); console.log(Reflect.get(obj, &#39;a&#39;)); 但是Reflect它能够传入第三个参数 reveiver 就相当于函数执行过程中，指向的this console.log(Reflect.get(obj, &#39;a&#39;, { a: &#39;kaimin&#39; })); // kaimin 在我们的响应式代码当中 const obj = new Proxy(data, { get(target, key) { track(target, key); // 返回函数属性 // 这里没有用Reflect.get实现读取数据 return target[key]; }, set(target, key, newVal) { target[key] = newVal; trigger(target, key); }, }); 我们在Proxy中无论设置get还是set拦截，都是直接用的原始对象target来进行读取或者赋值 例子： 假如目前的obj为，返回了this.foo的值。 接着我们在effect副作用函数中通过代理对象data读取b的值。 之后我们修改了a的值 const data = { a:1, get b(){ return this.a + 1; } } const obj = new Proxy(data, { get(target, key) { track(target, key); // 返回函数属性 // 这里没有用Reflect.get实现读取数据 return target[key]; }, set(target, key, newVal) { // 这里没有用Reflect.set target[key] = newVal; trigger(target, key); }, }) effect(()=&gt;{ console.log(obj.b) // 2 }) obj.a++ 修改了a的值之后，按道理应该执行读取了b属性的副作用函数，但是实际并不会相对应的触发副作用函数的重新执行 梳理下读取步骤： 首先我们在副作用函数中读取了obj.b的值 会触发obj代理对象的get拦截器，在get拦截器中，通过target[key]读取; 此时target就指的是 data 原始对象，key就是 ‘b’，所以相当直接读了data.b 访问obj.b的时候，其实是一个getter函数，这个getter的this指向了data，最终实质上是访问了 data.a 并且给他加了个1 当然，在副作用函数effect当中相当于，直接读取了原生对象data的属性，虽然看上去走了代理，但不多。所以这肯定是没有追踪到的，建立不起相应的联系 就类似 effect(()=&gt;{ console.log(data.a + 1) // 2 }) 在这种场景下Reflect的第三个参数receiver就派上用场了 改造getter拦截使用Reflect改造完get拦截器 const obj = new Proxy(data, { get(target, key, receiver) { track(target, key); // 返回函数属性 return Reflect.get(target, key, receiver) // ➕ }, ... }); 使用了Relfect之后，this指向就转为了obj代理对象，就可以成功的建立联系了 Reflect的作用不仅于此 改造setter拦截使用Reflect改造完setter拦截器 const obj = new Proxy(data, { set(target, key, newVal, receiver) { // 设置属性值 const res = Reflect.set(target, key, newVal, receiver) // 执行副作用 trigger(target, key); return res }, ... }); 代理obj使一个obj成为响应式的数据，我们必须要做的就是做好它代理。 首先需要知道一个普通对象的所有可能的读取操作 访问属性 ob.a 使用in操作符，key in obj 使用for….in….访问对象属性 属性的读取操作，上面我们已经实现过了, obj.a直接使用getter拦截器来实现拦截 in操作符拦截比如如下的副作用需要实现数据代理 effect(()=&gt;{ &#39;a&#39; in obj; }) 想找拦截in操作符必须知道in操作符的原理，其实需要理解ECMA-262的规范 第六点的 HasProperty(rval, ? ToPropertyKey(lval)) 这块的 Return ? O.[[HasProperty]](P). 的意思就是，调用原生对象的has方法去判断，是否有key值，因此我们可以理解为，in操作符的读取操作我们需要调用[[HasProperty]]函数槽对应的has方法，去做拦截 因此我们可以修改我们的拦截器 const obj = new Proxy(data, { has(target, key){ // ➕ track(target, key); // ➕ return Reflect.has(target, key) // ➕ } ... }); 拦截for…in…for…in…会在我们为响应式对象添加新的属性的时候，重新触发副作用函数。 const data = { a:1, b:2 }; const obj = new Proxy(data, {....}); effect(()=&gt;{ // for...in... for(const key in obj){ console.log(key) } }) 我们查看ECMA规范14.7.5.6 image-20220905215218547 第六步的c. Let iterator be EnumerateObjectProperties(obj). 如下是一个抽象方法，EnumerateObjectProperties该方法返回一个迭代器对象 实际上，可以看出，如果的obj就是被for…in…循环遍历的对象，其关键点在与 使用到了 Reflect.ownKeys()来获取只属于对象自身拥有的键。 因此我们可以使用Proxy的ownKeys来进行拦截。 改造代理，加入ownKeys拦截const ITERATE_KEY = Symbol() const obj = new Proxy(data, { ..... // 拦截for...in..., 获取所有对象所有key ownKeys(target) { // 将副作用函数与ITERATE_KEY关联起来 track(target, ITERATE_KEY); return Reflect.ownKeys(target) }, }); 理解： 将ITERATE_KEY作为track追踪的key：因为ownKeys拦截函数和get/set不同，无法具体到某个key值，ownKeys代表的时候拿到所有对象属于自己的key值，因此是无法具体的对应到哪个key的 既然追踪的是 ITERATE_KEY，在触发响应的时候也应该触发 trigger(target, ITERATE_KEY) 改造trigger上面的for循环的副作用函数，会与ITERATE_KEY建立联系，这时候，我们去新增obj的key，会触发setter拦截 obj.c=3; 按道理来说是能够触发上面的for循环的副作用函数。但是实际却不能正常触发。 那是因为，我们是将 obj作为一个元素对应的ITERATE_KEY做关联 其他的Key的Set副作用函数集合并没有将这个for…in…对应的副作用函数收起起来 所以在设置新的属性 c 的时候，for…in…对应的副作用函数 和 c 完全没有任何关系 所以，我们可以这么做，我们在trigger的时候，将那些与ITERATE_KEY相关副作用函数耶取出来执行就可以了。 function trigger(target, key) { // 根据target引用从桶中取得对应的Map const depsMap = buckect.get(target); if (!depsMap) return; // 取得target 上key对应的Set数据，遍历，执行里头的副作用 const effects = depsMap.get(key); // 取得for...in... 也就是ITERATE_KEY相关的副作用函数 const iterateEffects = depsMap.get(ITERATE_KEY); // ➕ const effectsToRun = new Set(); if (effects) { effects.forEach((current) =&gt; { if (current !== activeEffect) { // 如果当前trigger执行的，和activeEffect不一样，加入 effectsToRun.add(current); } }); } // 将与ITERATE_KEY挂钩的副作用函数也加入到effectsToRun ➕ if(iterateEffects){ // ➕ iterateEffects.forEach((current) =&gt; { // ➕ if (current !== activeEffect) { // ➕ // 如果当前trigger执行的，和activeEffect不一样，加入 // ➕ effectsToRun.add(current); // ➕ } }); } effectsToRun.forEach((fn) =&gt; { if (fn.options.scheduler) { // 调度器 fn.options.scheduler(fn); // 调度器 } else { fn(); } }); } 改造之后，我们去新增新的属性值，就会重新触发for…in…的那个副作用函数 const data = { a: 1, }; const obj = new Proxy(data, { get(target, key, receiver) { track(target, key); // 返回函数属性 return Reflect.get(target, key, receiver); // ➕ }, set(target, key, newVal, receiver) { // 设置属性值 const res = Reflect.set(target, key, newVal, receiver); // 执行副作用 trigger(target, key); return res; }, has(target, key) { track(target, key); return Reflect.has(target, key); }, // 拦截for...in..., 获取所有对象所有key ownKeys(target) { // 将副作用函数与ITERATE_KEY关联起来 track(target, ITERATE_KEY); return Reflect.ownKeys(target); }, }); effect(() =&gt; { // for...in... for (const key in obj) { console.log(key); } }); setTimeout(() =&gt; { obj.b = 2; }, 2000); 优化（区分新属性和旧属性）假如我们修改一个已存在的属性，按道理是不应该去重新出发for…in…副作用函数的 const data = { a: 1, }; const obj = new Proxy(data, { get(target, key, receiver) { track(target, key); // 返回函数属性 return Reflect.get(target, key, receiver); // ➕ }, set(target, key, newVal, receiver) { // 设置属性值 const res = Reflect.set(target, key, newVal, receiver); // 执行副作用 trigger(target, key); return res; }, has(target, key) { track(target, key); return Reflect.has(target, key); }, // 拦截for...in..., 获取所有对象所有key ownKeys(target) { // 将副作用函数与ITERATE_KEY关联起来 track(target, ITERATE_KEY); return Reflect.ownKeys(target); }, }); effect(() =&gt; { // for...in... for (const key in obj) { console.log(key); } }); setTimeout(() =&gt; { obj.a = 2; }, 2000); 但是，目前我们会重新去触发副作用函数，这会造成不必要的性能开销。需要做限制 所以我们真正要做的是，在set的拦截器中去对新增属性和设置 场景 做区分 首先定义一个全局的枚举，表示场景 // 枚举 -- 触发类型，set为设置属性，add为添加属性 const TRIGGER_TYPE = { SET:&#39;set&#39;, ADD:&#39;add&#39; } 改造setter const obj = new Proxy(data, { set(target, key, newVal, receiver) { // 如果属性不存在，则说明是在添加属性，否则是在设置属性 const triggerType = Object.prototype.hasOwnProperty.call(target, key) // ➕ ? TRIGGER_TYPE.SET : TRIGGER_TYPE.ADD; // 设置属性值 const res = Reflect.set(target, key, newVal, receiver); // 执行副作用 // 将triggerType作为trigger的第三个参数 trigger(target, key, triggerType); return res; }, }); 通过hasOwnProperty去判断，当前对象上是否存在这个属性了，从而知道是新的属性还是旧的属性 改造trigger函数 function trigger(target, key, triggerType) { // 根据target引用从桶中取得对应的Map const depsMap = bucket.get(target); if (!depsMap) return; // 取得target 上key对应的Set数据，遍历，执行里头的副作用 const effects = depsMap.get(key); const effectsToRun = new Set(); if (effects) { effects.forEach((current) =&gt; { if (current !== activeEffect) { // 如果当前trigger执行的，和activeEffect不一样，加入 effectsToRun.add(current); } }); } // 只有当 triggerType为 ADD的时候才会去触发与ITERATE_KEY相关联的副作用函数的重新执行 if (triggerType === TRIGGER_TYPE.ADD) { // ➕ // 取得for...in... 也就是ITERATE_KEY相关的副作用函数 const iterateEffects = depsMap.get(ITERATE_KEY); // 将与ITERATE_KEY挂钩的副作用函数也加入到effectsToRun if (iterateEffects) { iterateEffects.forEach((current) =&gt; { if (current !== activeEffect) { // 如果当前trigger执行的，和activeEffect不一样，加入 effectsToRun.add(current); } }); } } effectsToRun.forEach((fn) =&gt; { if (fn.options.scheduler) { // 调度器 fn.options.scheduler(fn); // 调度器 } else { fn(); } }); } 加入triggerType做区分，只有在triggerType为ADD的时候才去触发与ITERATE_KEY相关的副作用函数 拦截delete操作符delete obj.a 删除了a属性时候，其实我们要做的不是去触发，那些和a关联的副作用函数； 其实和for…in…一样，删除了某个对象的key，其实会影响for…in…关联的副作用函数，会导致for…in…减少一层循环，应该合理的去触发这个副作用函数 同样，我们需要拦截delete操作符，也需要提前了解EcMA的规范 从 5.d 的步骤可以知道，delete操作符的行为依赖 [[Delete]] 函数槽。对应的是Proxy deleteProperty拦截函数 从上就知道了其实我们要做的就是在 删除 某个对象的属性 的时候去触发 那个和 ITERATE_KEY 绑定的副作用函数 加入“删除”类型的TRIGGER_TYPE// 枚举 -- 触发类型，set为设置属性，add为添加属性，delete为删除属性 const TRIGGER_TYPE = { SET: &quot;set&quot;, ADD: &quot;add&quot;, DELETE: &quot;delete&quot;, }; 改造代理，加入deleteProperty拦截 判断当前删除的属性是否存在于自身对象上（如果不在自己的对象上，就不应该触发对应的副作用） 使用Reflect.deleteProperty进行删除 当1 2两者的条件全部都满足的时候，则去触发trigger函数，并且传入 DELETE的标识告诉trigger函数，目前进行的是删除属性操作。 const obj = new Proxy(data, { // 拦截delete操作符 deleteProperty(target, key){ // 检查被操作的属性是否是对象自己的属性 const hasKey = Object.prototype.hasOwnProperty.call(target,key); // 使用Reflect.deleteProperty 完成属性的删除 const res = Reflect.deleteProperty(target,key); if(hasKey &amp;&amp; res){ // 只有删除的是自己的属性，并且成功删除，才回去触发trigger函数 trigger(target, key, TRIGGER_TYPE.DELETE) } return res; } .... }); 改造trigger函数，加入delete判断条件function trigger(target, key, triggerType) { // 根据target引用从桶中取得对应的Map const depsMap = buckect.get(target); if (!depsMap) return; // 取得target 上key对应的Set数据，遍历，执行里头的副作用 const effects = depsMap.get(key); const effectsToRun = new Set(); if (effects) { effects.forEach((current) =&gt; { if (current !== activeEffect) { // 如果当前trigger执行的，和activeEffect不一样，加入 effectsToRun.add(current); } }); } // 只有当 triggerType为 ADD 或者 DELETE 的![]()时候才会去触发与ITERATE_KEY相关联的副作用函数的重新执行 // ➕ if ([TRIGGER_TYPE.ADD, TRIGGER_TYPE.DELETE].includes(triggerType)) { // ➕ // 取得for...in... 也就是ITERATE_KEY相关的副作用函数 const iterateEffects = depsMap.get(ITERATE_KEY); // 将与ITERATE_KEY挂钩的副作用函数也加入到effectsToRun if (iterateEffects) { iterateEffects.forEach((current) =&gt; { if (current !== activeEffect) { // 如果当前trigger执行的，和activeEffect不一样，加入 effectsToRun.add(current); } }); } } effectsToRun.forEach((fn) =&gt; { if (fn.options.scheduler) { // 调度器 fn.options.scheduler(fn); // 调度器 } else { fn(); } }); } 加入 type === ‘DELETE’的判断，从而是删除属性的操作也能够触发 与 ITERATE_KEY 绑定的操作。 Step6: 合理的触发响应 合理的触发响应，就是在一些情况下，我们其实是不需要去做副作用函数的重新执行的 前后值不改变情况的处理如下例子 const data = { a: 1 }; const obj = new Proxy(obj, { .... }) effect(()=&gt;{ console.log(obj.a) }) obj.a = 1; 在这种情况下，我们去修改a的值为1，其实实质上是并没有改动到obj的a属性值得，但是在这种情况下还是会疫情副作用函数的重新执行 那是因为并没有做值比较的拦截 修改setter拦截我们在set拦截器中，进行前后值的全等比较 const obj = new Proxy(data, { set(target, key, newVal, receiver) { // 首先获取旧值 const oldValue = target[key]; // 如果属性不存在，则说明是在添加属性，否则是在设置属性 const triggerType = Object.prototype.hasOwnProperty(target, key) ? TRIGGER_TYPE.SET : TRIGGER_TYPE.ADD; // 设置属性值 const res = Reflect.set(target, key, newVal, receiver); if (oldValue !== newVal) { // ➕ // 执行副作用 // 将triggerType作为trigger的第三个参数 trigger(target, key, triggerType); } return res; }, ..... }) 如上加入了一个全等的比较，但是其实这样是不妥当的。 我们没有考虑到NaN的情况 在js中NaN和NaN无论如何全等比较都是得到false的。 NaN !== NaN NaN === NaN 因此加入NaN的限制 const obj = new Proxy(data, { get(target, key, receiver) { track(target, key); // 返回函数属性 return Reflect.get(target, key, receiver); }, set(target, key, newVal, receiver) { // 首先获取旧值 const oldValue = target[key]; // 如果属性不存在，则说明是在添加属性，否则是在设置属性 const triggerType = Object.prototype.hasOwnProperty(target, key) ? TRIGGER_TYPE.SET : TRIGGER_TYPE.ADD; // 设置属性值 const res = Reflect.set(target, key, newVal, receiver); // 比较新值和旧值，只有他们不全等，并且都不是NaN的时候才触发响应的 ➕ if (oldValue !== newVal &amp;&amp; (oldValue === oldValue || newVal === newVal)) { // ➕ // 执行副作用 // 将triggerType作为trigger的第三个参数 trigger(target, key, triggerType); } return res; }, ... }); 封装为reactive我们将上述的所有的拦截器都封装到一个reactive的函数当中，后续直接以reactive为例子 function reactive(data) { return new Proxy(data, { get(target, key, receiver) { track(target, key); // 返回函数属性 return Reflect.get(target, key, receiver); }, set(target, key, newVal, receiver) { // 首先获取旧值 const oldValue = target[key]; // 如果属性不存在，则说明是在添加属性，否则是在设置属性 const triggerType = Object.prototype.hasOwnProperty(target, key) ? TRIGGER_TYPE.SET : TRIGGER_TYPE.ADD; // 设置属性值 const res = Reflect.set(target, key, newVal, receiver); // 比较新值和旧值，只有他们不全等，并且都不是NaN的时候才触发响应的 if (oldValue !== newVal &amp;&amp; (oldValue === oldValue || newVal === newVal)) { // 执行副作用 // 将triggerType作为trigger的第三个参数 trigger(target, key, triggerType); } return res; }, // 拦截in操作符 has(target, key) { track(target, key); return Reflect.has(target, key); }, // 拦截for...in..., 获取所有对象所有key ownKeys(target) { // 将副作用函数与ITERATE_KEY关联起来 track(target, ITERATE_KEY); return Reflect.ownKeys(target); }, // 拦截delete操作符 deleteProperty(target, key) { // 检查被操作的属性是否是对象自己的属性 const hasKey = Object.prototype.hasOwnProperty.call(target, key); // 使用Reflect.deleteProperty 完成属性的删除 const res = Reflect.deleteProperty(target, key); if (hasKey &amp;&amp; res) { // 只有删除的是自己的属性，并且成功删除，才回去触发trigger函数 trigger(target, key, TRIGGER_TYPE.DELETE); } return res; }, }); } 这样就可以直接使用了 const data = { a: 1, b: 2, }; const obj = reactive(data); 考虑原型情况存在一种情况，原型和代理的对象都是响应式数据的情况下 例如： const obj = {}; const prototype = { a: &#39;weng&#39; }; const child = reactive(obj); const parent = reactive(prototype); Object.setPrototypeOf(child, parent); effect(()=&gt;{ console.log(child.a); }); child.a = &#39;kaimin&#39;; // 会走两次副作用函数 为什么会存在两次执行的情况？ 分析如下： 在读取child.a的时候，会触发get拦截函数 最终的结果如下 Reflect.get(obj, &#39;a&#39;, child) // obj是child的原生对象 // child在这里就相当于receiver 其实最终是通过访问obj.a来访问属性的默认行为的。 引擎内部是通过调用obj对象所部署的[[Get]]内部方法得到最终结果 查看ECMA的规范： 在第三步骤，判定，如果我们自身的读取对象上没有这个属性的时候，会去原型上去调用原型对象属性的[[Get]]，因此这里就是parent.a，而parent的本身也是一个响应式数据，所以在副作用函数中相当于也访问了parent.a的值；这样就导致 child.a 和parent.a都与副作用函数建立的响应的联系 在我们修改child.a的值的时候，会触发obj原生对象的[[Set]] 引擎内部的定义如下： 由第二步的步骤知道，如果对象上面设置的这个属性不存在的话，那么就会获取它的原型，这里就是parent，由于parent是响应数据，就会调用parent的[[Set]]，所以，我们修改child.a的值的时候，由于在[[Get]]的时候，child.a和parent.a都收集到了副作用函数，所以会执行两次副作用函数。 总结来说，两次的触发分别是这样的效果的 第一次，作用在receiver 为child和target为 obj原生对象上 Reflect.set(obj, &#39;a&#39;, &#39;kaimin&#39;, child) 由于引擎的[[Get]]机制，发现没有a属性，就去parent上找了 第二次，作用在在receiver 为child和target为 prototype原生对象上 Reflect.set(prototype, &#39;a&#39;, &#39;kaimin&#39;, child) 第一次和第二次的差距就是，所设置的target的原生对象不一样的。但是receiver永远是那个child响应数据，所以可以利用这个特点来作区分。 target变化，receiver不变，我们只需要做到一次的屏蔽更新就可以了。去掉那一次由于原型而引起的更新 所以接下来的问题就是确定receiver是不是target的代理对象就可以了。 修改getter拦截新增加一个代理对象的raw属性，这个属性是指向这个需要代理的对象的，当我们访问这个代理对象的时候，如果key为raw，那我们就直接返回这个代理的对象，为后续的setter触发时间做判断 function reactive(data) { return new Proxy(data, { get(target, key, receiver) { // 代理对象可以通过raw的属性，访问原始的数据 if (key === &quot;raw&quot;) { // ➕ return target; // ➕ } track(target, key); // 返回函数属性 return Reflect.get(target, key, receiver); }, } 这样代理对象就可以这么搞了 child.raw === obj; // true; parent.raw === prototype; // true 有了它，我们就能够在setter当中拦截了 修改setter有了raw的属性，我们可以在setter当中去访问receiver的raw属性，从而将其和当前的target做判断，进行拦截 function reactive(data) { return new Proxy(data, { set(target, key, newVal, receiver) { // 首先获取旧值 const oldValue = target[key]; // 如果属性不存在，则说明是在添加属性，否则是在设置属性 const triggerType = Object.prototype.hasOwnProperty(target, key) ? TRIGGER_TYPE.SET : TRIGGER_TYPE.ADD; // 设置属性值 const res = Reflect.set(target, key, newVal, receiver); // 如果target === receiver.raw（raw指向原生对象）就说明receiver就是target的代理对象 if (receiver.raw === target) { // ➕ // 比较新值和旧值，只有他们不全等，并且都不是NaN的时候才触发响应的 if ( oldValue !== newVal &amp;&amp; (oldValue === oldValue || newVal === newVal) ) { // 执行副作用 // 将triggerType作为trigger的第三个参数 trigger(target, key, triggerType); } } return res; }, } 经过如上的改造，我们增加了判断条件，这样就可以屏蔽那些 由原型值引起的不必要的更新。 因此上面的例子就能解决两次执行副作用的问题 Step7: 引入“深”和“浅”概念浅与深响应 在vue中，有shallowReactive的浅响应的方法，也有reactive深响应的方法 目前我们所实现的reactive是浅响应 const data = { a: { b: &#39;weng &#39;} }; const obj = reactive(data); effect(()=&gt;{ console.log(obj.a.b) }); // 修改b的值并不会触发副作用函数 obj.a.b = &#39;kaimin&#39; 目前这种情况造成的原因是因为，在我们getter拦截器中 get(target, key, receiver) { // 代理对象可以通过raw的属性，访问原始的数据 if (key === &quot;raw&quot;) { return target; } track(target, key); // 返回函数属性 return Reflect.get(target, key, receiver); }, 我们在读取obj.a.b的时候 需要先访问obj.a，通过getter拿到的是Reflect.get(data, &#39;a&#39;, obj) 结果拿到的data.a其实是非响应式的数据：{ b: &#39;weng&#39; } 所以说这种情况我们我们无法追踪这个对象的，得不到响应 因此我们称这种为浅响应，如果需要在修改b值的时候，也触发响应，那就是深入到了下面一层级，或者更深一层级，这样的就叫做深响应。 如果要实现深响应的话，我们可以改造getter，让他深入到下一层的数据 改造reactive和getter实现深响应当读取一个对象的某个属性的时候 先判断这个属性是否是对象 如果是对象的话，则递归地调用reactive函数将其包装成响应式数据并且返回。 这样的话在下一层级访问属性的时候，就可以简历响应的联系了。 function reactive(data) { return new Proxy(data, { get(target, key, receiver) { // 代理对象可以通过raw的属性，访问原始的数据 if (key === &quot;raw&quot;) { return target; } track(target, key); // 返回函数属性，得到原始值结果 const res = Reflect.get(target, key, receiver); // ➕ if (typeof res === &quot;object&quot; &amp;&amp; res !== null) { // ➕ // 调用 reactive 将结果包装成响应式数据并返回 return reactive(res); // ➕ } // 返回res return res; }, }); } 封装深响应reactive和浅响应shallowReactive实现了上层的深响应的方案之后我们希望能够将两者变成vue中的reactive和shallowReactive函数。 封装一个createReactive公共函数，接收一个参数isShallow参数，在这里代表是否为浅层，默认为false，即深层 // 封装 function createReactive(data, isShallow = false) { return new Proxy(data, { get(target, key, receiver) { // 代理对象可以通过raw的属性，访问原始的数据 if (key === &quot;raw&quot;) { return target; } track(target, key); // 返回函数属性，得到原始值结果 const res = Reflect.get(target, key, receiver); // 如果是浅响应直接返回 if (isShallow) { // ➕ return res; // ➕ } if (typeof res === &quot;object&quot; &amp;&amp; res !== null) { // 调用 reactive 将结果包装成响应式数据并返回 return reactive(res); } // 返回res return res; }, set(target, key, newVal, receiver) { // 首先获取旧值 const oldValue = target[key]; // 如果属性不存在，则说明是在添加属性，否则是在设置属性 const triggerType = Object.prototype.hasOwnProperty(target, key) ? TRIGGER_TYPE.SET : TRIGGER_TYPE.ADD; // 设置属性值 const res = Reflect.set(target, key, newVal, receiver); // 如果target === receiver.raw（raw指向原生对象）就说明receiver就是target的代理对象 if (receiver.raw === target) { // 比较新值和旧值，只有他们不全等，并且都不是NaN的时候才触发响应的 if ( oldValue !== newVal &amp;&amp; (oldValue === oldValue || newVal === newVal) ) { // 执行副作用 // 将triggerType作为trigger的第三个参数 trigger(target, key, triggerType); } } return res; }, // 拦截in操作符 has(target, key) { track(target, key); return Reflect.has(target, key); }, // 拦截for...in..., 获取所有对象所有key ownKeys(target) { // 将副作用函数与ITERATE_KEY关联起来 track(target, ITERATE_KEY); return Reflect.ownKeys(target); }, // 拦截delete操作符 deleteProperty(target, key) { // 检查被操作的属性是否是对象自己的属性 const hasKey = Object.prototype.hasOwnProperty.call(target, key); // 使用Reflect.deleteProperty 完成属性的删除 const res = Reflect.deleteProperty(target, key); if (hasKey &amp;&amp; res) { // 只有删除的是自己的属性，并且成功删除，才回去触发trigger函数 trigger(target, key, TRIGGER_TYPE.DELETE); } return res; }, }); } 之后的reactive和shallowReactive就调用穿不同参数就好了 function reactive(data) { return createReactive(data) } function shallowReactive(data){ return createReactive(data, true) } 如下例子： const data = { a: { b: &quot;weng&quot; } }; const data2 = { a: { b: &quot;weng2&quot; } }; const obj = reactive(data); const obj2 = shallowReactive(data2); effect(() =&gt; { console.log(obj.a.b); }); effect(() =&gt; { console.log(obj2.a.b); }); obj.a.b = &quot;kaimin&quot;; obj2.a.b = &quot;kaimin2&quot;; 这样就OK 浅与深的只读只读的概念，就是尝试修改只读数据的时候，会阻止其值的修改，或者删除某个只读数据的时候，会阻止，并且抛出警告。 我们提供一个 readonly的函数，将某个数据变成只读的。 const obj = readonly({ a: &#39;weng&#39; }); effect(()=&gt;{ console.log(obj.a); // 可以读，但是在这里就不需要在追踪数据 }) obj.a = &#39;kaimin&#39;; // 修改失败，并且抛出警告 只读本质也是对数据对象做了一层代理，我们可以服用上述封装的createReactive的函数来改造，并且加入isReadonly参数 改造createReative// 新增isShallow表示浅还是深响应，isReadonly表示浅还是深只读 function createReactive(data, isShallow = false, isReadonly = false) { return new Proxy(data, { get(target, key, receiver) { // 代理对象可以通过raw的属性，访问原始的数据 if (key === &quot;raw&quot;) { return target; } // 非只读的数据才需要建立响应式的联系 if (!isReadonly) { // ➕ track(target, key); } // 返回函数属性，得到原始值结果 const res = Reflect.get(target, key, receiver); // 如果是浅响应直接返回 if (isShallow) { return res; } if (typeof res === &quot;object&quot; &amp;&amp; res !== null) { // 调用 reactive 将结果包装成响应式数据并返回 return reactive(res); } // 返回res return res; }, set(target, key, newVal, receiver) { // 如果是只读的，则打印警告信息并返回 if (isReadonly) { // ➕ console.warn(`the param ${key} is readonly`); return true; } // 首先获取旧值 const oldValue = target[key]; // 如果属性不存在，则说明是在添加属性，否则是在设置属性 const triggerType = Object.prototype.hasOwnProperty(target, key) ? TRIGGER_TYPE.SET : TRIGGER_TYPE.ADD; // 设置属性值 const res = Reflect.set(target, key, newVal, receiver); // 如果target === receiver.raw（raw指向原生对象）就说明receiver就是target的代理对象 if (receiver.raw === target) { // 比较新值和旧值，只有他们不全等，并且都不是NaN的时候才触发响应的 if ( oldValue !== newVal &amp;&amp; (oldValue === oldValue || newVal === newVal) ) { // 执行副作用 // 将triggerType作为trigger的第三个参数 trigger(target, key, triggerType); } } return res; }, // 拦截in操作符 has(target, key) { track(target, key); return Reflect.has(target, key); }, // 拦截for...in..., 获取所有对象所有key ownKeys(target) { // 将副作用函数与ITERATE_KEY关联起来 track(target, ITERATE_KEY); return Reflect.ownKeys(target); }, // 拦截delete操作符 deleteProperty(target, key) { // 如果是只读的，删除失败，提示 if (isReadonly) { // ➕ console.warn(`the param ${key} is readonly`); return true; } // 检查被操作的属性是否是对象自己的属性 const hasKey = Object.prototype.hasOwnProperty.call(target, key); // 使用Reflect.deleteProperty 完成属性的删除 const res = Reflect.deleteProperty(target, key); if (hasKey &amp;&amp; res) { // 只有删除的是自己的属性，并且成功删除，才回去触发trigger函数 trigger(target, key, TRIGGER_TYPE.DELETE); } return res; }, }); } 改造点： 加入第三个参数isReadonly表示是只读还是非只读 在getter中加入判断，当只有非只读的数据，才需要进行响应式的追踪，也就是调用track函数 在setter当中加入判断，只读的数据直接返回true，并且抛出警告 在拦截delete操作符中，加入判断，只读的数据直接返回true，并且抛出警告 封装深响应readonly和浅响应shallowReadonly如上的实现，只是对数据进行了一层浅层的readonly，也就是vue中的shallowReadonly，我们可以定义深只读readonly函数，对数据进行深层的只读，并且对getter进行改造。 function readonly(data){ return createReactive(data, false, true) } // 新增isShallow表示浅还是深响应，isReadonly表示浅还是深只读 function createReactive(data, isShallow = false, isReadonly = false) { return new Proxy(data, { get(target, key, receiver) { // 代理对象可以通过raw的属性，访问原始的数据 if (key === &quot;raw&quot;) { return target; } // 非只读的数据才需要建立响应式的联系 if (!isReadonly) { track(target, key); } // 返回函数属性，得到原始值结果 const res = Reflect.get(target, key, receiver); // 如果是浅响应直接返回 if (isShallow) { return res; } if (typeof res === &quot;object&quot; &amp;&amp; res !== null) { // 调用 reactive / readonly 将结果包装成响应式数据并返回 return isReadonly ? readonly(res) : reactive(res); // ➕ } // 返回res return res; }, set(target, key, newVal, receiver) { // 如果是只读的，则打印警告信息并返回 if (isReadonly) { console.warn(`the param ${key} is readonly`); return true; } // 首先获取旧值 const oldValue = target[key]; // 如果属性不存在，则说明是在添加属性，否则是在设置属性 const triggerType = Object.prototype.hasOwnProperty(target, key) ? TRIGGER_TYPE.SET : TRIGGER_TYPE.ADD; // 设置属性值 const res = Reflect.set(target, key, newVal, receiver); // 如果target === receiver.raw（raw指向原生对象）就说明receiver就是target的代理对象 if (receiver.raw === target) { // 比较新值和旧值，只有他们不全等，并且都不是NaN的时候才触发响应的 if ( oldValue !== newVal &amp;&amp; (oldValue === oldValue || newVal === newVal) ) { // 执行副作用 // 将triggerType作为trigger的第三个参数 trigger(target, key, triggerType); } } return res; }, // 拦截in操作符 has(target, key) { track(target, key); return Reflect.has(target, key); }, // 拦截for...in..., 获取所有对象所有key ownKeys(target) { // 将副作用函数与ITERATE_KEY关联起来 track(target, ITERATE_KEY); return Reflect.ownKeys(target); }, // 拦截delete操作符 deleteProperty(target, key) { // 如果是只读的，删除失败，提示 if (isReadonly) { console.warn(`the param ${key} is readonly`); return true; } // 检查被操作的属性是否是对象自己的属性 const hasKey = Object.prototype.hasOwnProperty.call(target, key); // 使用Reflect.deleteProperty 完成属性的删除 const res = Reflect.deleteProperty(target, key); if (hasKey &amp;&amp; res) { // 只有删除的是自己的属性，并且成功删除，才回去触发trigger函数 trigger(target, key, TRIGGER_TYPE.DELETE); } return res; }, }); } 我们在getter返回属性之前，判断他是否是只读的，再去调用readonly对值包装并且返回 对于shallowReadonly我们只需要把第二个参数设置为true就好了（isShallow） function shallowReadonly(data) { return createReactive(data, true, true); } 如下例子： const data = { a: { b: &quot;weng&quot; } }; const data2 = { a: { b: &quot;weng2&quot; } }; const obj = readonly(data); const obj2 = shallowReadonly(data2); effect(() =&gt; { console.log(obj.a.b); }); effect(() =&gt; { console.log(obj2.a.b); }); obj.a.b = &quot;kaimin&quot;; obj2.a.b = &quot;kaimin2&quot;; Step8：原始值的响应实现如上的step1～step7都是在讨论 引用类型的数据响应式（目前到这里只讲过obj的引用代理） 因为我们上述的讨论都是基于js 的proxy的来实现的，但是Proxy不能用于原始值的代理 现在说一下原始数据类型的响应式方案（Boolean，Number，BigInt，String，Symbol，undifined，null）。 实现ref在vue3中，我们可以用ref或者reactive实现数据的响应，比较常用实现原始数据的代理就是用ref包裹实现 const num = ref(2); // 读取 console.log(num.value) // 修改 num.value = 3; 参照vue3的实现方案，我们可以很容易实现一个ref的工厂函数 ref函数： // ref函数 function ref(val) { // 在ref函数内部创建包裹对象 const wrapper = { value: val, }; // 将包裹对象变成响应式数据 return reactive(wrapper); } vue3中对ref类型的数据做了很多判断，所以前提是我们需要告诉使用到这个ref的地方，或者某些场景下（例如模板中自动脱离ref的操作）。所以 加入ref标识// ref函数 function ref(val) { // 在ref函数内部创建包裹对象 const wrapper = { value: val, }; // 在wrapper对象上定义一个不可枚举的属性__v_isRef，设置值为true Object.defineProperties(wrapper, &quot;__v_isRef&quot;, { value: true, enumerable: false, }); // 将包裹对象变成响应式数据 return reactive(wrapper); } 实现toRef以及toRefs在实现toRef和toRefs之前，需要了解一个Vue3常用场景，就是响应式丢失的场景 在vue3中，我们经常使用setup这么搞 export default { setup(){ const obj = reactive({ a:1, b:2 }); return { ...obj } } } 然后在模板中，我们就能读取a, b的值 &lt;temlplate&gt; &lt;span&gt;{{ a }} / {{ b }}&lt;/span&gt; &lt;/template&gt; 但是其实这么做会造成响应式的丢失。 因为在我们的setup中，最终return的是一个 新的对象 return { ...obj } // 等价于 return { a: 1, b: 2, } 用另外一个种方式描述响应式丢失就是： const data = { a: 1 }; const obj = reactive(data); const newObj = { ...obj, }; effect(() =&gt; { console.log(newObj.a); }); setTimeout(() =&gt; { obj.a = 2; // 无法触发副作用函数的重新执行 }, 2000); 我们最终的副作用函数（模板里头就是render函数）读取的其实是newObj对象，这个并不是响应的数据 当然也是有解决的方法 const data = { a: 1 }; const obj = reactive(data); const newObj = { a: { get value() { return obj.a; }, }, b: { get value() { return obj.b; }, }, }; effect(() =&gt; { console.log(newObj.a.value); }); setTimeout(() =&gt; { obj.a = 2; // 无法触发副作用函数的重新执行 }, 2000); 我们对newObj的a属性或者b属性都植入一个访问器的属性value，当去读取value的值的时候，最终读取的是响应式数据obj下面的同名属性。这样就可以与副作用函数建立起响应联系 因此我们可以封装一下结构体，提取公共的一个封装函数toRef toReffunction toRef(obj, key){ const wrapper = { get value(){ return obj[key] }, set value(val){ return obj[key] = val } } return wrapper } toRef接受两个参数 obj: 响应式数据 key: 响应式数据的一个key return: 返回一个类似与ref的一个wrapper对象 并且加入setter 这样的话，我们就可以重新定义newObj对象 const newObj = { a: toRef(obj, &#39;a&#39;), b: toRef(obj, &#39;b&#39;), } toRefs如上的toRef只能实现单一的key值转化 如果需要转化的键值很多，就需要toRefs批量转换的能力 function toRefs(obj){ const res = {}; // 使用for...in...循环遍历对象 for(const key in obj) { // 逐个调用toRef完成转换 res[key] = toRef(obj, key) } return res; } 因此如上的例子可以简化为： const data = { a: 1 }; const obj = reactive(data); const { a } = toRefs(obj); effect(() =&gt; { console.log(a.value); }); setTimeout(() =&gt; { obj.a = 2; // 重新触发读了a的副作用函数 }, 2000); 加入ref标识因为我们无论使用toRef还是toRefs转化出来的数据，在vue3中都是被标识为ref类型的数据的。所以需要在toRef中增加和如上一致的 __v_isRef标识 function toRef(obj, key) { const wrapper = { get value() { return obj[key]; }, }; // 在wrapper对象上定义一个不可枚举的属性__v_isRef，设置值为true Object.defineProperties(wrapper, &quot;__v_isRef&quot;, { value: true, enumerable: false, }); return wrapper; } 脱离ref上面的toRef包裹对象，最终生成的ref数据是需要通过’.value’属性访问 const obj = reactive({ a: 1, b: 2, }) const newObj = toRefs(obj); console.log(newObj.a.value) 在vue3中的模板内，他是存在自动脱离ref的能力 &lt;template&gt; &lt;span&gt; {{ newObj.a }} &lt;/span&gt; &lt;/template&gt; &lt;script setup&gt; const obj = reactive({ a: 1, b: 2, }) const newObj = toRefs(obj); &lt;/script&gt; 或者 &lt;script&gt; export default { setup(){ const count = ref(12121) return { count } } } &lt;/script&gt; 最终这个返回的对象都会在vue3中被处理一次，将ref的数据脱离ref 其实最终在setup里头返回的对象，会被vue3通过 proxyRefs脱离ref 实现proxyRefs结合之前加入的 __v_isRef标识，使用proxy为ref创建一个代理对象。 function proxyRefs(target){ return new Proxy(target, { get(target, key, receiver){ const value = Reflect.get(target, key, receiver) // 自动脱离ref，通过__v_isRef的标识，判断是否是ref，是的话返回value值 return value.__v_isRef ? value.value : value }, set(target, key, newValue, receiver){ // 通过target读取真实的值 const value = target[key]; // 如果是Ref， 则设置其对应的value的属性值 if(value.__v_isRef){ value.value = newValue; return true } return Reflect.set(target, key, newValue, receiver) } }) } 这样就可以实现自动脱离ref的功能 const newObj = proxyRefs({ ...toRefs(obj) }); console.log(newObj.a); // 1","tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/NollieLeo/tags/vue/"}]},{"title":"为何Vue3 Proxy 更快","date":"2022-04-21T09:46:14.000Z","path":"2022/04/21/为何Vue3-Proxy-更快/","text":"相比于Vue2.x Object.defineProperty的响应式原理，Vue3 Proxy的优势在哪里呢。以下我们从两者源码角度分析下使用Proxy的优势。 Proxy优势： ES6原生Proxy语法，更快的初始化，懒加载，不用递归的定义Object.defineProperty 支持动态的添加object新属性 支持原生array数组操作 假设有如下的响应式对象时： data() { return { a: { b: { c: { d: { e: 11 } } } } } } // 以上等价于以下代码 const data = { a: { b: { c: { d: { e: 11 } } } } } // Vue2.x Vue.observe(data) // Vue3： reactive(data) Copied! #Vue2.x Object.definePropertyvue2初始化时，会递归的调用Object.defineProperty。当第一层对象属性定义后，再会递归调用下一层属性的Object.defineProperty（为了是依赖收集）。所以在初始化时Vue2.x需要更多时间，去同步递归定义Object.defineProperty操作。 另外一个缺点也可以看出，初始化时把data的属性递归遍历收集了，当data在业务运行过程中，动态新增属性该怎么办？在Vue2.x中由于不是懒加载，所以需要用户主动告诉Vue框架，告诉哪些新增属性是要去依赖收集的，这就是Vue.set (opens new window)API的来由。同理Vue.delete (opens new window)。 以下是精简主流程的源码，Vue2.x中定义响应式对象API是：Vue.observe(data) // https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js export function observe (value: any, asRootData: ?boolean): Observer | void { let ob = new Observer(value) return ob } export class Observer { constructor (value: any) { this.walk(value) } walk (obj: Object) { const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) { defineReactive(obj, keys[i]) } } } export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean // default: false ) { const dep = new Dep() const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.setter // 同步实时：递归子层级 let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter () { const value = getter ? getter.call(obj) : val // ... dep依赖收集 return value }, set: function reactiveSetter (newVal) { setter.call(obj, newVal) // ... dep触发更新 } }) } Copied! #Vue3 Proxy处理Vue3中定义响应式对象API是：reactive(data)。 Proxy提供了对JS的元数据编程，即可以使用JS提供的语法特性，创建新的JS语法。 可以看到Vue3中定义响应式非常简单，即原生的 new Proxy(target, handlers)。此时这里没有递归调用初始化，即可看成是懒加载去依赖收集（用到才去依赖收集）。 再看看代理操作baseHandlers中get定义是如何的。 // https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/reactive.ts export function reactive(target: object) { return createReactiveObject(target) } function createReactiveObject(target: Target) { const observed = new Proxy( target, baseHandlers // {get, set, deleteProperty} ) return observed } Copied! get定义，主要用来依赖收集，同时如果属性的value为Object对象时，自定进行Proxy代理。 // https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/baseHandlers.ts const get = createGetter() function createGetter(isReadonly = false, shallow = false) { return function get(target: Target, key: string | symbol, receiver: object) { const res = Reflect.get(target, key, receiver) // ...依赖收集 // 懒加载，当访问响应式对象时，再去构造下一个Proxy(res, { getter }) if (isObject(res)) { return reactive(res) } return res } } Copied!","tags":[{"name":"proxy","slug":"proxy","permalink":"https://github.com/NollieLeo/tags/proxy/"},{"name":"vue3","slug":"vue3","permalink":"https://github.com/NollieLeo/tags/vue3/"},{"name":"Object.defineProperty","slug":"Object-defineProperty","permalink":"https://github.com/NollieLeo/tags/Object-defineProperty/"}]},{"title":"tsconfig.json全解析","date":"2022-04-21T09:42:55.000Z","path":"2022/04/21/tsconfig-json全解析/","text":"解析 TypeScript带来的类型系统以及强大的IDE支持，让前端开发也变得严谨而流畅。但TypeScript不是原生的Javascript代码，需要进行编译才能转换为Javascript代码。 tsconfig.json是编译TypeScript的配置文件，对书写TypeScript代码十分重要。因为有些选项如果你没配置，则需要严格按照TypeScript的规则来书写，对初期使用TypeScript的同学而言，稍不留神就会书写出不符合规则的代码，从而导致编译报错，打击自信心。其实早期可以通过关闭一些规则设置，从而更愉快的从js转为ts开发。笔者根据项目实战经历来解释一些常用的编译选项，文末也会附上笔者整理的所有tsconfig.json选项的解释。 1. experimentalDecorators是否启用实验性的ES装饰器。boolean类型，默认值：false。官方解释(opens new window) TypeScript和ES6中引入了Class的概念，同时在stage 2 proposal (opens new window)提出了Java等服务器端语言早就有的装饰器模式。通过引入装饰器模式，能极大简化书写代码，把一些通用逻辑封装到装饰器中。很多库都有用到该特性，比如vue-class-component 及 vuex-class等库。当你使用这些库时，必须开启experimentalDecorators。 function f() { console.log(&quot;f(): evaluated&quot;); return function (target, propertyKey: string, descriptor: PropertyDescriptor) { console.log(&quot;f(): called&quot;); } } class C { @f() method() {} } 启用 vuex-class同时需要设置strictFunctionTypes选项为false 2. strictPropertyInitialization是否类的非undefined属性已经在构造函数里初始化。 boolean类型，默认值：false 直白点，就是所有的属性值，都需要赋有初始值。建议把strictPropertyInitialization设置为false，这样就不需要定义一个变量就必须赋有初始值。对使用vuex-class库的同学，建议请把这个值设为false，绝对能省很多事。 export default class Home extend Vue{ jobId: string // 如果开启strictPropertyInitialization，则这里会报错，因为没有赋值默认值 method1() :void { console.log(this.jobId) } } 如果设置该选项为true，需要同时启用–strictNullChecks或启用–strict 3. noImplicitAny有隐含的 any类型时是否报错。boolean值，默认值：false ts是有默认推导的，同时还有any类型，所以不是每个变量或参数定义需要明确告知类型是什么。如果开启该值，当有隐含any类型时，会报错。建议初次上手TypeScript，把该选项设置为false。 // 当开启noImplicitAny时，需要隐含当any需要明确指出 arr.find(item =&gt; item.name === name) // error arr.find((item: any) =&gt; item.name === name) // ok 4. target指定编译的ECMAScript目标版本。枚举值：”ES3”， “ES5”， “ES6”/ “ES2015”， “ES2016”， “ES2017”，”ESNext”。默认值： “ES3” TypeScript是ES6的超集，所以你可以使用ES6来编写ts代码（通常我们也的确这么做）。然而，当编译ts代码时，可以把ts转为ES5或更早的js代码。所以需要选择一个编译的目标版本。vue-cli3的typescript模板，设置为“ESNext”，因为现代大部分应用项目都会使用Webpack（Parcel也很棒）进行打包，Webpack会把你的代码转换成在所有浏览器中可运行的代码。 target: “ESNext” 是指tc39最新的ES proposed features(opens new window) 5. module指定生成哪个模块系统代码。枚举值：”None”， “CommonJS”， “AMD”， “System”， “UMD”， “ES6”， “ES2015”，”ESNext”。默认值根据–target选项不同而不同，当target设置为ES6时，默认module为“ES6”，否则为“commonjs” 通常使用ES6的模块来写ts代码，然而2016年1月以前，基本上没有浏览器原生支持ES6的模块系统，所以需要转换为不同的模块系统，如：CommonJS、AMD、SystemJS等，而module选项就是指定编译使用对应的模块系统。 6. lib编译过程中需要引入的库文件的列表。string[]类型，可选的值有很多，常用的有ES5，ES6，ESNext，DOM，DOM.Iterable、WebWorker、ScriptHost等。该值默认值是根据–target选项不同而不同。当target为ES5时，默认值为[‘DOM ‘, ‘ES5’, ‘ScriptHost’];当target为ES6时，默认值为[‘DOM’, ‘ES6’, ‘DOM.Iterable’, ‘ScriptHost’] 为了在ts代码中使用ES6中的类，比如Array.form、Set、Reflect等，需要设置lib选项，在编译过程中把这些标准库引入。这样在编译过程中，如果遇到属于这些标准库的class或api时，ts编译器不会报错。 7. moduleResolution决定如何处理模块。string类型，“node”或者“classic”，默认值：“classic”。官方解释(opens new window) 说直白点，也就是遇到import { AAA } from ‘./aaa’该如何去找对应文件模块解析。对于工程项目，笔者建议大家使用node（vue-cli3 ts模板默认设置为node策略），因为这个更符合平时我们的书写习惯以及认知（平时都是webpack打包，webpack又基于node之上）。 // 在源文件/root/src/A.ts中import { b } from &quot;./moduleB&quot; // 两种解析方式查找文件方式不同 // classic模块解析方式 1. /root/src/moduleB.ts 2. /root/src/moduleB.d.ts // node模块解析方式 1. /root/src/moduleB.ts 2. /root/src/moduleB.tsx 3. /root/src/moduleB.d.ts 4. /root/src/moduleB/package.json (if it specifies a &quot;types&quot; property) 5. /root/src/moduleB/index.ts 6. /root/src/moduleB/index.tsx 7. /root/src/moduleB/index.d.ts 8. paths模块名或路径映射的列表。Object值 这是一个非常有用的选项，比如我们经常使用‘@/util/help’来代替’./src/util/help’，省的每次在不同层级文件import模块时,都纠结于是’./‘还是’../‘。该选项告诉编译器遇到匹配的值时，去映射的路径下加载模块。 { &quot;baseUrl&quot;: &quot;.&quot;, // 注意：baseUrl不可少 &quot;paths&quot;: { // 映射列表 &quot;@/*&quot;: [ &quot;src/*&quot; ], &quot;moduleA&quot;: [ &quot;src/libs/moduleA&quot; ] } } // in ts code import Setting from &#39;@/components/Setting.vue&#39; // 模块实际位置: src/components/Setting.vue import TestModule from &#39;moduleA/index.js&#39; // 模块实际位置: src/libs/moduleA/index.js 9. strictNullChecks是否启用严格的 null检查模式。boolean值，默认值：false 未处理的null和undefined经常会导致BUG的产生，所以TypeScript包含了strictNullChecks选项来帮助我们减少对这种情况的担忧。当启用了strictNullChecks，null和undefined获得了它们自己各自的类型null和undefined。开启该模式有助于发现并处理可能为undefined的赋值。如果是正式项目，笔者建议开启该选项；如果只是练手TypeScirpt，可以关闭该选项，不然所有可能为null/undefined的赋值，都需要写联合类型。 // 未开启strictNullChecks，number类型包含了null和undefined类型 let foo: number = 123; foo = null; // Okay foo = undefined; // Okay // 开启strictNullChecks let foo: string[] | undefined = arr.find(key =&gt; key === &#39;test&#39;) // foo.push(&#39;1&#39;) // error - &#39;foo&#39; is possibly &#39;undefined&#39; foo &amp;&amp; foo.push(&#39;1&#39;) // okay 注意：启用 –strict相当于启用 –noImplicitAny, –noImplicitThis, –alwaysStrict, –strictNullChecks, –strictFunctionTypes和–strictPropertyInitialization 10. noUnusedLocals有未使用的变量时，是否抛出错误。boolean值，默认值： false 顾名思义，当发现变量定义但没有使用时，编译不报错。eslint的rule中也有该条，建议正式项目将该选项开启，设置为true，使得代码干净整洁。 11. noUnusedParameters有未使用的参数时，是否抛出错误。boolean值，默认值： false 建议正式项目开启该选项，设置为true，理由同上。 12. allowJs是否允许编译javascript文件。boolean值，默认值：false 如果设置为true，js后缀的文件也会被typescript进行编译。 13. typeRoots和types默认所有可见的”@types”包会在编译过程中被包含进来。如果指定了typeRoots，只有typeRoots下面的包才会被包含进来。如果指定了types，只有被列出来的npm包才会被包含进来。详细内容可看此处(opens new window) 可以指定”types”: []来禁用自动引入@types包 14. files、include和exclude编译文件包含哪些文件以及排除哪些文件。 未设置include时，编译器默认包含当前目录和子目录下所有的TypeScript文件（.ts, .d.ts 和 .tsx）。如果allowJs被设置成true，JS文件（.js和.jsx）也被包含进来。exclude排除那些不需要编译的文件或文件夹。 { &quot;compilerOptions&quot;: {}, &quot;include&quot;: [ &quot;src/**/*&quot; ], &quot;exclude&quot;: [ &quot;node_modules&quot;, &quot;**/*.spec.ts&quot; ] } 配置项{ &quot;compilerOptions&quot;: { /* 基本选项 */ &quot;target&quot;: &quot;es5&quot;, // 指定 ECMAScript 目标版本: &#39;ES3&#39; (default), &#39;ES5&#39;, &#39;ES2015&#39;, &#39;ES2016&#39;, &#39;ES2017&#39;, or &#39;ESNEXT&#39;（&quot;ESNext&quot;表示最新的ES语法，包括还处在stage X阶段） &quot;module&quot;: &quot;commonjs&quot;, // 指定使用模块: &#39;commonjs&#39;, &#39;amd&#39;, &#39;system&#39;, &#39;umd&#39; or &#39;es2015&#39; &quot;lib&quot;: [], // 指定要包含在编译中的库文件 &quot;allowJs&quot;: true, // 允许编译 javascript 文件 &quot;checkJs&quot;: true, // 报告 javascript 文件中的错误 &quot;jsx&quot;: &quot;preserve&quot;, // 指定 jsx 代码的生成: &#39;preserve&#39;, &#39;react-native&#39;, or &#39;react&#39; &quot;declaration&quot;: true, // 生成相应的 &#39;.d.ts&#39; 文件 &quot;sourceMap&quot;: true, // 生成相应的 &#39;.map&#39; 文件 &quot;outFile&quot;: &quot;./&quot;, // 将输出文件合并为一个文件 &quot;outDir&quot;: &quot;./&quot;, // 指定输出目录 &quot;rootDir&quot;: &quot;./&quot;, // 用来控制输出目录结构 --outDir. &quot;removeComments&quot;: true, // 删除编译后的所有的注释 &quot;noEmit&quot;: true, // 不生成输出文件 &quot;importHelpers&quot;: true, // 从 tslib 导入辅助工具函数 &quot;isolatedModules&quot;: true, // 将每个文件做为单独的模块 （与 &#39;ts.transpileModule&#39; 类似）. /* 严格的类型检查选项 */ &quot;strict&quot;: true, // 启用所有严格类型检查选项 &quot;noImplicitAny&quot;: true, // 在表达式和声明上有隐含的 any类型时报错 &quot;strictNullChecks&quot;: true, // 启用严格的 null 检查 &quot;noImplicitThis&quot;: true, // 当 this 表达式值为 any 类型的时候，生成一个错误 &quot;alwaysStrict&quot;: true, // 以严格模式检查每个模块，并在每个文件里加入 &#39;use strict&#39; /* 额外的检查 */ &quot;noUnusedLocals&quot;: true, // 有未使用的变量时，抛出错误 &quot;noUnusedParameters&quot;: true, // 有未使用的参数时，抛出错误 &quot;noImplicitReturns&quot;: true, // 并不是所有函数里的代码都有返回值时，抛出错误 &quot;noFallthroughCasesInSwitch&quot;: true, // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿） /* 模块解析选项 */ &quot;moduleResolution&quot;: &quot;node&quot;, // 选择模块解析策略： &#39;node&#39; (Node.js) or &#39;classic&#39; (TypeScript pre-1.6)。默认是classic &quot;baseUrl&quot;: &quot;./&quot;, // 用于解析非相对模块名称的基目录 &quot;paths&quot;: {}, // 模块名到基于 baseUrl 的路径映射的列表 例如：&quot;@/*&quot;: [&quot;src/*&quot;] &quot;rootDirs&quot;: [], // 根文件夹列表，其组合内容表示项目运行时的结构内容 &quot;typeRoots&quot;: [], // 包含类型声明的文件列表 &quot;types&quot;: [], // 需要包含的类型声明文件名列表 &quot;allowSyntheticDefaultImports&quot;: true, // 允许从没有设置默认导出的模块中默认导入。 /* Source Map Options */ &quot;sourceRoot&quot;: &quot;./&quot;, // 指定调试器应该找到 TypeScript 文件而不是源文件的位置 &quot;mapRoot&quot;: &quot;./&quot;, // 指定调试器应该找到映射文件而不是生成文件的位置 &quot;inlineSourceMap&quot;: true, // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件 &quot;inlineSources&quot;: true, // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性 /* 其他选项 */ &quot;experimentalDecorators&quot;: true, // 启用装饰器 &quot;emitDecoratorMetadata&quot;: true, // 为装饰器提供元数据的支持 &quot;strictFunctionTypes&quot;: false // 禁用函数参数双向协变检查。 }, /* 指定编译文件或排除指定编译文件 */ &quot;include&quot;: [ &quot;src/**/*&quot; ], &quot;exclude&quot;: [ &quot;node_modules&quot;, &quot;**/*.spec.ts&quot; ], &quot;files&quot;: [ &quot;core.ts&quot;, &quot;sys.ts&quot; ], // 从另一个配置文件里继承配置 &quot;extends&quot;: &quot;./config/base&quot;, // 让IDE在保存文件的时候根据tsconfig.json重新生成文件 &quot;compileOnSave&quot;: true // 支持这个特性需要Visual Studio 2015， TypeScript1.8.4以上并且安装atom-typescript插件 }","tags":[{"name":"tsconfig","slug":"tsconfig","permalink":"https://github.com/NollieLeo/tags/tsconfig/"}]},{"title":"vue2~vue3迁移记录","date":"2022-04-16T02:59:12.000Z","path":"2022/04/16/vue2-vue3迁移记录/","text":"记录vue2到vue3版本迁移事项 官方迁移文档 api变化全局api变化new Vue —&gt; createApp 🚩 ➕ vue2中没有app 的概念，通过Vue的统一构造函数进行全局的配置，单页应用中无法创建多个不同全局配置的根应用（会造成全局配置污染） vue3中有了app概念，通过createApp创建返回的实例暴露全局api，解决了vue2中的问题 Vue2 import Vue from &quot;vue&quot;; import App from &#39;./App.vue&#39; new Vue({ render: (h) =&gt; h(App) }).$mount(&quot;#app&quot;); Vue3 createApp 生成一个app实例，该实例拥有全局的可配置上下文 import { createApp } from &#39;vue&#39; import App from &#39;./App.vue&#39; const app = createApp(App).mount(&#39;#app&#39;); 所以现在所有全局会改变Vue行为的api都改到了app应用实例上了 internal Apis 🚩文档 vue2中不少global-api是作为静态函数直接挂在构造函数上的，例如Vue.nextTick()，如果我们从未在代码中用过它们，就会形成所谓的dead code，这类global-api造成的dead code无法使用webpack的tree-shaking排除掉。 vue3中做了相应的变化，将它们抽取成为独立函数，这样打包工具的摇树优化可以将这些dead code排除掉。 Vue2 import Vue from &#39;vue&#39;; Vue.nextTick(()=&gt;{}) Vue3 import { nextTick } from &#39;vue&#39; nextTick(() =&gt; {}) 官方文档列出受影响的api code/wengblog/NollieLeo.github.io/source/_posts/vue2-vue3迁移记录/image-20220416125617961.png app.configglobalProperties 🚩➕ 添加可在程序内的任何组件实例中访问的全局属性。 Vue2 import Vue from &#39;vue&#39; Vue.prototype.$http = axios vue3 // Vue3 const app = Vue.createApp({}) app.config.globalProperties.$http = axios devtools 配置是否允许 vue-devtools 检查代码。开发版本默认为 true，生产版本默认为 false。生产版本设为 true 可以启用检查。 - Vue.config.devtools = true + app.config.devtools = true errorHandler- Vue.config.errorHandler = function (err, vm, info) { // handle error // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子 // 只在 2.2.0+ 可用 } + app.config.errorHandler = (err, vm, info) =&gt; { // handle error // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子 // 这里能发现错误 } 指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。 错误追踪服务 Sentry 和 Bugsnag 都通过此选项提供了官方支持。 warnHandler- Vue.config.warnHandler = function (msg, vm, trace) { // `trace` 是组件的继承关系追踪 } + app.config.warnHandler = function(msg, vm, trace) { // `trace` 是组件的继承关系追踪 } 为 Vue 的运行时警告赋予一个自定义处理函数。注意这只会在开发者环境下生效，在生产环境下它会被忽略。 isCustomElement ➕ 替代掉Vue2.x的ignoredElements - Vue.config.ignoredElements = [ // 用一个 `RegExp` 忽略所有“ion-”开头的元素 // 仅在 2.5+ 支持 /^ion-/ ] // 一些组件以&#39;ion-&#39;开头将会被解析为自定义组件 + app.config.isCustomElement = tag =&gt; tag.startsWith(&#39;ion-&#39;) 指定一个方法来识别在Vue之外定义的自定义组件(例如，使用Web Component API)。如果组件符合这个条件，它就不需要本地或全局注册，Vue也不会抛出关于Unknown custom element的警告 注意，这个函数中不需要匹配所有原生HTML和SVG标记—Vue解析器会自动执行此检查 optionMergeStrategiesconst app = Vue.createApp({ mounted() { console.log(this.$options.hello) } }) app.config.optionMergeStrategies.hello = (parent, child, vm) =&gt; { return `Hello, ${child}` } app.mixin({ hello: &#39;Vue&#39; }) // &#39;Hello, Vue 定义自定义选项的合并策略。 合并策略接收在父实例options和∗∗子实例∗∗options和子实例options和∗∗子实例∗∗options，分别作为第一个和第二个参数。上下文Vue实例作为第三个参数传递 【自定义选项合并策略】mixinconst app = Vue.createApp({ custom: &#39;hello!&#39; }) app.config.optionMergeStrategies.custom = (toVal, fromVal) =&gt; { console.log(fromVal, toVal) // =&gt; &quot;goodbye!&quot;, undefined // =&gt; &quot;hello!&quot;, &quot;goodbye!&quot; return fromVal || toVal } app.mixin({ custom: &#39;goodbye!&#39;, created() { console.log(this.$options.custom) // =&gt; &quot;hello!&quot; } }) optionMergeStrategies先获取到子实例的$options的mixin而没有父实例【custom第一次改变从undefined到goodbye—&gt;打印”goodbye!”, undefined】 父实例的options替换掉子实例的options替换掉子实例的options替换掉子实例的options【custom第二次从goodbye到hello!—&gt;打印了”hello”, “goodbye!”】 最后在打印app.config.optionMergeStrategies.custom返回的父实例的$options 无论如何this.options.custom最后会返回合并策略的return的值【使用场景利用父子组件的options.custom最后会返回合并策略的return的值【使用场景利用父子组件的options.custom最后会返回合并策略的return的值【使用场景利用父子组件的options,然后返回计算等操作得到所需要的值】optionMergeStrategies合并$options变化 performance- Vue.config.performance=true; + app.config.performance=true; 设置为 true 以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪。只适用于开发模式和支持 performance.mark API 的浏览器上。 app.directive 教程文档 注册或获取全局指令。 import { createApp } from &#39;vue&#39; const app = createApp({}) // 注册 app.directive(&#39;my-directive&#39;, { // 指令的生命周期 // 在绑定元素的父组件被挂载之前调用 beforeMount(el, binding, vnode) {}, // 在挂载绑定元素的父组件时调用 mounted(el, binding, vnode) {}, // 在更新包含组件的VNode之前调用 beforeUpdate(el, binding, vnode, prevNode) {}, // 组件的VNode及其子组件的VNode更新之后调用 updated(el, binding, vnode, prevNode) {}, // 在卸载绑定元素的父组件之前调用 beforeUnmount(el, binding, vnode) {}, // 在卸载绑定元素的父组件时调用 unmounted(el, binding, vnode) {} }) // 注册 (指令函数) app.directive(&#39;my-directive&#39;, (el, binding, vnode, prevNode) =&gt; { // 这里将会被 `mounted` 和 `updated` 调用 }) // getter，返回已注册的指令 const myDirective = app.directive(&#39;my-directive&#39;) el: 指令绑定到的元素。这可以用来直接操作DOM。 binding【包含下列属性的对象】 instance：使用指令的组件的实例 value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot;中，绑定值为 2 oldValue：指令绑定的前一个值，仅在 beforeUpdate 和 updated 钩子中可用。无论值是否改变都可用 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot; modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true } dir：一个对象，在注册指令时作为参数传递; 举个例子，看下面指令 app.directive(&#39;focus&#39;, { mounted(el) { el.focus() } }) dir就是下面的对象 { mounted(el) { el.focus() } } vnode 编译生成的虚拟节点 prevNode 前一个虚拟节点，仅在beforeUpdate和updated钩子中可用 tips:除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行 app.unmount 🚩➕ 在所提供的DOM元素上卸载应用程序实例的根组件 import { createApp } from &#39;vue&#39; const app = createApp({}) // 做一些必要的准备 app.mount(&#39;#my-app&#39;) // 应用程序将在挂载后5秒被卸载 setTimeout(() =&gt; app.unmount(&#39;#my-app&#39;), 5000) app.component Vue2.x【注册或获取全局组件。注册还会自动使用给定的 id 设置组件的名称】 // 注册组件，传入一个选项对象 (自动调用 Vue.extend) Vue.component(&#39;my-component&#39;, { /* ... */ }) // 获取注册的组件 (始终返回构造器) var MyComponent = Vue.component(&#39;my-component&#39;) Vue3【注册或获取全局组件. 注册还会自动使用给定的 name组件 设置组件的名称】全局组件 基本vue2写法一致 import { createApp } from &#39;vue&#39; const app = createApp({}) // 注册组件，传入一个选项对象 app.component(&#39;my-component&#39;, { /* ... */ }) // 获取注册的组件 (始终返回构造器) const MyComponent = app.component(&#39;my-component&#39;, {}) watch 以.分割的表达式不再被watch支持，可以使用计算函数作为w*atc*h支持，可以使用计算函数作为watch参数实现。 Vue2 watch: { &quot;data.id&quot;(val) { }, }, Vue3 const data = reactive({ id:121 }); watch(data.id,()=&gt;{}) emits ➕ 官方文档 emits 可以是数组或对象 触发自定义事件 如果emits是对象，则允许我们配置和事件验证。验证函数应返回布尔值，以表示事件参数是否有效。 依赖注入provide/inject 与vue2中使用方法没有什么很大的差异，但是亮点是可以提供相应式的数据 基础使用方法看文档 响应式方法 🚩➕例如： import { ref, reactive } from &#39;vue&#39; // 提供者 setup() { const book = reactive({ title: &#39;Vue 3 Guide&#39;, author: &#39;Vue Team&#39; }) const year = ref(&#39;2020&#39;) /*提供reactive响应式*/ provide(&#39;book&#39;, book) /*提供ref响应式*/ provide(&#39;year&#39;, year) } 弊端提供相应式的方法之后，子组建就可以尝试对这个引用值进行修改，从而导致单向数据流通的紊乱 为了避免这种情况，基于provide进行封装 /* * @Author: 翁恺敏 * @Date: 2022-04-10 16:11:32 * @LastEditors: 翁恺敏 * @LastEditTime: 2022-04-16 15:21:11 * @FilePath: /vue3-vite-test/src/hooks/useProvide.ts * @Description: provide （observerable provide） */ import { provide, readonly, reactive, ref, isReactive } from &quot;vue&quot;; import forEach from &quot;lodash/forEach&quot;; const useProvide = (shouldReactive: Boolean = true) =&gt; { const handleProvide = (providers: Record&lt;string, any&gt;): void =&gt; { forEach(providers, (value, key) =&gt; { let provideValue; const isFunction = typeof value === &quot;function&quot;; if (!isFunction) { provideValue = shouldReactive &amp;&amp; !isReactive(value) ? ref(value) : value; } provide(key, isFunction ? provideValue : readonly(provideValue)); }); }; return handleProvide; }; export default useProvide; defineAsyncComponent(异步组件)生命周期函数与 2.x 版本生命周期相对应的组合式 API 🚩➕ beforeCreate -&gt; 使用 setup() created -&gt; 使用 setup() beforeMount -&gt; onBeforeMount mounted -&gt; onMounted beforeUpdate -&gt; onBeforeUpdate updated -&gt; onUpdated beforeDestroy -&gt; onBeforeUnmount destroyed -&gt; onUnmounted errorCaptured -&gt; onErrorCaptured 非组合式api只是改了名字 内置指令变化v-model 🚩 官方文档 组件使用vue2 — v-model &lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt; &lt;!-- 简写: --&gt; &lt;ChildComponent :value=&quot;pageTitle&quot; @input=&quot;pageTitle = $event&quot; /&gt; 如果要将属性或事件名称更改为其他名称，则需要在 ChildComponent 组件中添加 model 选项： &lt;!-- ParentComponent.vue --&gt; &lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt; // ChildComponent.vue export default { model: { prop: &#39;title&#39;, event: &#39;change&#39; }, props: { // 这将允许 `value` 属性用于其他用途 value: String, // 使用 `title` 代替 `value` 作为 model 的 prop title: { type: String, default: &#39;Default title&#39; } } } 所以，在这个例子中 v-model 的简写如下： &lt;ChildComponent :title=&quot;pageTitle&quot; @change=&quot;pageTitle = $event&quot; /&gt; Vue2 — v-bind.sync 在某些情况下，我们可能需要对某一个 prop 进行“双向绑定”(除了前面用 v-model 绑定 prop 的情况)。建议使用 update:myPropName 抛出事件。例如，对于在上一个示例中带有 title prop 的 ChildComponent，我们可以通过下面的方式将分配新 value 的意图传达给父级： this.$emit(&#39;update:title&#39;, newValue) 如果需要的话，父级可以监听该事件并更新本地 data property。例如： &lt;ChildComponent :title=&quot;pageTitle&quot; @update:title=&quot;pageTitle = $event&quot; /&gt; 为了方便起见，我们可以使用 .sync 修饰符来缩写，如下所示： &lt;ChildComponent :title.sync=&quot;pageTitle&quot; /&gt; Vue3 — v-model &lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt; &lt;!-- 简写: --&gt; &lt;ChildComponent :modelValue=&quot;pageTitle&quot; @update:modelValue=&quot;pageTitle = $event&quot; /&gt; &lt;ChildComponent v-model:title=&quot;pageTitle&quot; /&gt; &lt;!-- 简写: --&gt; &lt;ChildComponent :title=&quot;pageTitle&quot; @update:title=&quot;pageTitle = $event&quot; /&gt; v-is 🚩➕ V-is 仅限于indom的模版 Vue3中只能使用is在内置的component组件上面 vue2 &lt;table&gt; &lt;tr :is=&quot;&#39;my-component&#39;&quot;&gt;&lt;/tr&gt; &lt;/table&gt; vue3 :is不再适用于indom的模版 &lt;table&gt; &lt;tr v-is=&quot;&#39;my-component&#39;&quot;&gt;&lt;/tr&gt; &lt;/table&gt; v-slot 🚩➕ 插槽在vue3中统一了vue2的slot和scope-slot Vue2 &lt;!-- 子组件中：--&gt; &lt;slot name=&quot;title&quot;&gt;&lt;/slot&gt; &lt;!-- 父组件中：--&gt; &lt;template slot=&quot;title&quot;&gt; &lt;h1&gt;歌曲：成都&lt;/h1&gt; &lt;template&gt; 如果我们要在 slot 上面绑定数据，可以使用作用域插槽，实现如下： // 子组件 &lt;slot name=&quot;content&quot; :data=&quot;data&quot;&gt;&lt;/slot&gt; export default { data(){ return{ data:[&quot;走过来人来人往&quot;,&quot;不喜欢也得欣赏&quot;,&quot;陪伴是最长情的告白&quot;] } } } &lt;!-- 父组件中使用 --&gt; &lt;template slot=&quot;content&quot; slot-scope=&quot;scoped&quot;&gt; &lt;div v-for=&quot;item in scoped.data&quot;&gt;{{item}}&lt;/div&gt; &lt;template&gt; Vue3 在 Vue2.x 中具名插槽和作用域插槽分别使用slot和slot-scope来实现， 在 Vue3.0 中将slot和slot-scope进行了合并同意使用。 Vue3.0 中v-slot： &lt;!-- 父组件中使用 --&gt; &lt;template v-slot:content=&quot;scoped&quot;&gt; &lt;div v-for=&quot;item in scoped.data&quot;&gt;{{item}}&lt;/div&gt; &lt;/template&gt; &lt;!-- 也可以简写成： --&gt; &lt;template #content=&quot;{data}&quot;&gt; &lt;div v-for=&quot;item in data&quot;&gt;{{item}}&lt;/div&gt; &lt;/template&gt; 自定义指令变化 🚩➕vue3中指令api和组件保持一致，具体表现在： bind → beforeMount inserted → mounted beforeUpdate: new! 元素自身更新前调用, 和组件生命周期钩子很像 update → removed! 和updated基本相同，因此被移除之，使用updated代替。 componentUpdated → updated beforeUnmount new! 和组件生命周期钩子相似, 元素将要被移除之前调用。 unbind → unmounted 内置组件teleport 🚩➕源码 Props to - string 必填属性，必须是一个有效的query选择器，或者是元素(如果在浏览器环境中使用）。中的内容将会被放置到指定的目标元素中 &lt;!-- 正确的 --&gt; &lt;teleport to=&quot;#some-id&quot; /&gt; &lt;teleport to=&quot;.some-class&quot; /&gt; /*元素*/ &lt;teleport to=&quot;[data-teleport]&quot; /&gt; &lt;!-- 错误的 --&gt; &lt;teleport to=&quot;h1&quot; /&gt; &lt;teleport to=&quot;some-string&quot; /&gt; disabled - boolean 这是一个可选项 ，做一个是可以用来禁用的功能，这意味着它的插槽内容不会移动到任何地方，而是按没有teleport组件一般来呈现【默认为false】 &lt;teleport to=&quot;#popup&quot; :disabled=&quot;displayVideoInline&quot;&gt; &lt;h1&gt;999999&lt;/h1&gt; &lt;/teleport&gt; 注意，这将移动实际的DOM节点，而不是销毁和重新创建，并且还将保持任何组件实例是活动的。所有有状态HTML元素(比如一个正在播放的视频)将保持它们的状态。【控制displayVideoInline并不是销毁重建，它保持实例是存在的，不会被注销】 Suspense 🚩➕ 官方文档 官方文档目前还是标注为试验性 该 &lt;suspense&gt; 组件提供了另一个方案，允许将等待过程提升到组件树中处理，而不是在单个组件中。 自带两个 slot 分别为 default、fallback。顾名思义，当要加载的组件不满足状态时,Suspense 将回退到 fallback状态一直到加载的组件满足条件，才会进行渲染。 Suspense.vue &lt;template&gt; &lt;button @click=&quot;loadAsyncComponent&quot;&gt;点击加载异步组件&lt;/button&gt; &lt;Suspense v-if=&quot;loadAsync&quot;&gt; &lt;template #default&gt; &lt;!-- 加载对应的组件 --&gt; &lt;MAsynComp&gt;&lt;/MAsynComp&gt; &lt;/template&gt; &lt;template #fallback&gt; &lt;div class=&quot;loading&quot;&gt;&lt;/div&gt; &lt;/template&gt; &lt;/Suspense&gt; &lt;/template&gt; &lt;script&gt; import { ref, defineAsyncComponent } from &#39;vue&#39; export default { components: { MAsynComp: defineAsyncComponent(() =&gt; import(&#39;./AsynComp.vue&#39;)), }, setup() { const loadAsync = ref(false) const loadAsyncComponent = () =&gt; { loadAsync.value = true } return { loadAsync, loadAsyncComponent, } }, } &lt;/script&gt; &lt;style lang=&quot;less&quot; scoped&gt; button { padding: 12px 12px; background-color: #1890ff; outline: none; border: none; border-radius: 4px; color: #fff; cursor: pointer; } .loading { position: absolute; width: 36px; height: 36px; top: 50%; left: 50%; margin: -18px 0 0 -18px; background-image: url(&#39;../assets/loading.png&#39;); background-size: 100%; animation: rotate 1.4s linear infinite; } @keyframes rotate { from { transform: rotate(0); } to { transform: rotate(360deg); } } &lt;/style&gt; AsynComp.vue &lt;template&gt; &lt;h1&gt;this is async component&lt;/h1&gt; &lt;/template&gt; &lt;script&gt; import { setup } from &#39;vue&#39; export default { name: &#39;AsyncComponent&#39;, async setup() { const sleep = (time) =&gt; { return new Promise((reslove, reject) =&gt; { setTimeout(() =&gt; { reslove() }, time) }) } await sleep(3000) //模拟数据请求 }, } &lt;/script&gt; Fragments 🚩➕Vue3.0组件中可以允许有多个根组件，避免了多个没必要的div渲染 &lt;template&gt; &lt;div&gt;头部&lt;/div&gt; &lt;div&gt;内容&lt;/div&gt; &lt;/template&gt; 这样做的好处： 少了很多没有意义的div 可以实现平级递归，对实现tree组件有很大帮助 相应式系统 🚩🚩🚩响应式系统 APIreactivedesc: 接收一个普通对象然后返回该普通对象的响应式代理【等同于 2.x 的 Vue.observable()】 ssss tips:Proxy对象是目标对象的一个代理器，任何对目标对象的操作（实例化，添加/删除/修改属性等等），都必须通过该代理器。因此我们可以把来自外界的所有操作进行拦截和过滤或者修改等操作 响应式转换是“深层的”：会影响对象内部所有嵌套的属性。基于 ES2015 的 Proxy 实现，返回的代理对象不等于原始对象。建议仅使用代理对象而避免依赖原始对象 reactive 类的 api 主要提供了将复杂类型的数据处理成响应式数据的能力，其实这个复杂类型是要在object array map set weakmap weakset 这五种之中 因为是组合函数【对象】，所以必须始终保持对这个所返回对象的引用以保持响应性【不能解构该对象或者展开】例如 const { x, y } = useMousePosition()或者return { ...useMousePosition() } function useMousePosition() { const pos = reactive({ x: 0, y: 0, }) return pos } toRefs API 用来提供解决此约束的办法——它将响应式对象的每个 property 都转成了相应的 ref【把对象转成了ref】。 function useMousePosition() { const pos = reactive({ x: 0, y: 0, }) return toRefs(pos) } // x &amp; y 现在是 ref 形式了! const { x, y } = useMousePosition() ref接受一个参数值并返回一个响应式且可改变的 ref 对象。ref 对象拥有一个指向内部值的单一属性 .value const count = ref(0) console.log(count.value) // 0 如果传入 ref 的是一个对象，将调用 reactive 方法进行深层响应转换 陷阱 setup 中return返回会自动解套【在模板中不需要.value】 ref 作为 reactive 对象的 property 被访问或修改时，也将自动解套 .value const count = ref(0) /*当做reactive的对象属性----解套*/ const state = reactive({ count, }) /* 不需要.value*/ console.log(state.count) // 0 /*修改reactive的值*/ state.count = 1 /*修改了ref的值*/ console.log(count.value) // 1 注意如果将一个新的 ref 分配给现有的 ref， 将替换旧的 ref /*创建一个新的ref*/ const otherCount = ref(2) /*赋值给reactive的旧的ref，旧的会被替换掉*/ state.count = otherCount /*修改reactive会修改otherCount*/ console.log(state.count) // 2 /*修改reactive会count没有被修改 */ console.log(count.value) // 1 嵌套在 reactive Object 中时，ref 才会解套。从 Array 或者 Map 等原生集合类中访问 ref 时，不会自动解套【自由数据类型是Object才会解套，array map set weakmap weakset集合类 访问 ref 时，不会自动解套】 const arr = reactive([ref(0)]) // 这里需要 .value console.log(arr[0].value) const map = reactive(new Map([[&#39;foo&#39;, ref(0)]])) // 这里需要 .value console.log(map.get(&#39;foo&#39;).value) 心智负担上 ref vs reactive 在普通 JavaScript 中区别声明基础类型变量与对象变量时一样区别使用 ref 和 reactive 所有的地方都用 reactive，然后记得在组合函数返回响应式对象时使用 toRefs。这降低了一些关于 ref 的心智负担 readonly传入一个对象（响应式或普通）或 ref，返回一个原始对象的只读代理。一个只读的代理是“深层的”，对象内部任何嵌套的属性也都是只读的【返回一个永远不会变的只读代理】【场景可以参数比对等】 const original = reactive({ count: 0 }) const copy = readonly(original) watchEffect(() =&gt; { // 依赖追踪 console.log(copy.count) }) // original 上的修改会触发 copy 上的侦听 original.count++ // 无法修改 copy 并会被警告 copy.count++ // warning! reactive响应式系统工具集isProxy 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理 isReactive 检查一个对象是否是由 reactive 创建的响应式代理 import { reactive, isReactive } from &#39;vue&#39; const state = reactive({ name: &#39;John&#39; }) console.log(isReactive(state)) // -&gt; true 如果这个代理是由 readonly 创建的，但是又被 reactive 创建的另一个代理包裹了一层，那么同样也会返回 true import { reactive, isReactive, readonly } from &#39;vue&#39; const state = reactive({ name: &#39;John&#39; }) // 用readonly创建一个只读响应式对象plain const plain = readonly({ name: &#39;Mary&#39; }) //readonly创建的，所以isReactive为false console.log(isReactive(plain)) // -&gt; false // reactive创建的响应式代理对象包裹一层readonly,isReactive也是true,isReadonly也是true const stateCopy = readonly(state) console.log(isReactive(stateCopy)) // -&gt; true isReadonly 检查一个对象是否是由 readonly 创建的只读代理 reactive高级响应式系统APItoRaw 返回由 reactive 或 readonly 方法转换成响应式代理的普通对象。这是一个还原方法，可用于临时读取，访问不会被代理/跟踪，写入时也不会触发更改。不建议一直持有原始对象的引用【**不建议赋值给任何变量**】。请谨慎使用 被toRaw之后的对象是没有被代理/跟踪的的普通对象 const foo = {} const reactiveFoo = reactive(foo) console.log(toRaw(reactiveFoo) === foo) // true console.log(toRaw(reactiveFoo) !== reactiveFoo) // true markRaw显式标记一个对象为“永远不会转为响应式代理”，函数返回这个对象本身。 【markRaw传入对象，返回的值是永远不会被转为响应式代理的】 const foo = markRaw({ name: &#39;Mary&#39; }) console.log(isReactive(reactive(foo))) // false 被 markRaw 标记了，即使在响应式对象中作属性，也依然不是响应式的 const bar = reactive({ foo }) console.log(isReactive(bar.foo)) // false markRaw注意点 markRaw和 shallowXXX 一族的 API允许选择性的覆盖reactive或者readonly 默认创建的 “深层的” 特性【响应式】/或者使用无代理的普通对象 设计这种「浅层读取」有很多原因 一些值的实际上的用法非常简单，并没有必要转为响应式【例如三方库的实例/省市区json/Vue组件对象】 当渲染一个元素数量庞大，但是数据是不可变的，跳过 Proxy 的转换可以带来性能提升 这些 API 被认为是高级的，是因为这种特性仅停留在根级别，所以如果你将一个嵌套的，没有 markRaw 的对象设置为 reactive 对象的属性，在重新访问时，你又会得到一个 Proxy 的版本，在使用中最终会导致标识混淆的严重问题：执行某个操作同时依赖于某个对象的原始版本和代理版本（标识混淆在一般使用当中应该是非常罕见的，但是要想完全避免这样的问题，必须要对整个响应式系统的工作原理有一个相当清晰的认知）。 const foo = markRaw({ nested: {}, }) const bar = reactive({ // 尽管 `foo` 己经被标记为 raw 了, 但 foo.nested 并没有 nested: foo.nested, }) console.log(foo.nested === bar.nested) // false foo.nested没有被标记为(永远不会转为响应式代理)，导致最后的值一个reactive shallowReactive只为某个对象的私有（第一层）属性创建浅层的响应式代理，不会对“属性的属性”做深层次、递归地响应式代理，而只是保留原样【第一层是响应式代理，深层次只保留原样(不具备响应式代理)】 const state = shallowReactive({ foo: 1, nested: { bar: 2, }, }) // 变更 state 的自有属性是响应式的【第一层次响应式】 state.foo++ // ...但不会深层代理【深层次不是响应式】(渲染性能) isReactive(state.nested) // false state.nested.bar++ // 非响应式 shallowReadonly类似于shallowReactive，区别是： 第一层将会是响应式代理【第一层修改属性会失败】，属性为响应式 深层次的对象属性可以修改，属性不是响应式 const state = shallowReadonly({ foo: 1, nested: { bar: 2, }, }) // 变更 state 的自有属性会失败 state.foo++ // ...但是嵌套的对象是可以变更的 isReadonly(state.nested) // false state.nested.bar++ // 嵌套属性依然可修改 ref 响应式系统工具集unrefunref是val = isRef(val) ? val.value : val 的语法糖 unref(ref(0))===unref(0)===0 返回number function useFoo(x: number | Ref&lt;number&gt;) { const unwrapped = unref(x) // unwrapped 一定是 number 类型 } toReftoRef 可以用来为一个 reactive 对象的属性【某个属性区别toRefs每一个属性】创建一个 ref。这个 ref 可以被传递并且能够保持响应性 const state = reactive({ foo: 1, bar: 2, }) //reactive获取单个属性转为ref【fooRef只是一个代理】 const fooRef = toRef(state, &#39;foo&#39;) fooRef.value++ console.log(state.foo) // 2 state.foo++ console.log(fooRef.value) // 3 toRefs把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref ，和响应式对象 property 一一对应 const state = reactive({ foo: 1, bar: 2, }) const stateAsRefs = toRefs(state) /* stateAsRefs 的类型如下: { foo: Ref&lt;number&gt;, bar: Ref&lt;number&gt; } */ // ref 对象 与 原属性的引用是 &quot;链接&quot; 上的 state.foo++ console.log(stateAsRefs.foo) // 2 stateAsRefs.foo.value++ console.log(state.foo) // 3 可以通过toRefs返回可解构的reactive，因为toRefs包裹之后返回一一对应的ref属性 function useFeatureX() { const state = reactive({ foo: 1, bar: 2, }) // 对 state 的逻辑操作 // 返回时将属性都转为 ref return toRefs(state) } export default { setup() { // 可以解构，不会丢失响应性 const { foo, bar } = useFeatureX() return { foo, bar, } }, } isRef检查一个值是否为一个 ref 对象 ref 高级响应式系统APIcustomRef用于自定义一个 ref，可以显式地控制依赖追踪和触发响应，接受一个工厂函数，两个参数分别是用于追踪的 track 与用于触发响应的 trigger，并返回一个一个带有 get 和 set 属性的对象【实际上就是手动 track追踪 和 trigger触发响应】 以下代码可以使得v-model防抖 function useDebouncedRef(value, delay = 200) { let timeout return customRef((track, trigger) =&gt; { return { get() { /*初始化手动追踪依赖讲究什么时候去触发依赖收集*/ track() return value }, set(newValue) { /*修改数据的时候会把上一次的定时器清除【防抖】*/ clearTimeout(timeout) timeout = setTimeout(() =&gt; { /*把新设置的数据给到ref数据源*/ value = newValue /*再有依赖追踪的前提下触发响应式*/ trigger() }, delay) }, } }) } setup() { return { /*暴露返回的数据加防抖*/ text: useDebouncedRef(&#39;hello&#39;), } } shallowRef创建一个 ref ，将会追踪它的 .value 更改操作，但是并不会对变更后的 .value 做响应式代理转换（即变更不会调用 reactive） 前面我们说过如果传入 ref 的是一个对象，将调用 reactive 方法进行深层响应转换,通过shallowRef创建的ref,将不会调用reactive【对象不会是响应式的】 const refOne = shallowRef({}); refOne.value = { id: 1 }; refOne.id == 20; console.log(isReactive(refOne.value),refOne.value);//false { id: 1 } triggerRef 【与shallowRef配合】手动执行与shallowRef相关的任何效果 const shallow = shallowRef({ greet: &#39;Hello, world&#39; }) // 第一次运行打印 &quot;Hello, world&quot; watchEffect(() =&gt; { console.log(shallow.value.greet) }) // 这不会触发效果，因为ref是shallow shallow.value.greet = &#39;Hello, universe&#39; // 打印 &quot;Hello, universe&quot; triggerRef(shallow) Composition APIsetupsetup 函数是一个新的组件选项。作为在组件内使用 Composition API 的入口点 注意 setup 返回的 ref 在模板中会自动解开，不需要写 .value【setup 内部需要.value】 调用时机 创建组件实例，然后初始化 props ，紧接着就调用setup 函数。从生命周期钩子的视角来看，它会在 beforeCreate 钩子之前被调用 如果 setup 返回一个对象，则对象的属性将会被合并到组件模板的渲染上下文 参数 props 作为其第一个参数 注意 props 对象是响应式的，watchEffect 或 watch 会观察和响应 props 的更新 不要解构 props 对象，那样会使其失去响应性 export default { props: { name: String, }, setup(props) { console.log(props.name) watchEffect(() =&gt; { console.log(`name is: ` + props.name) }) }, } 第二个参数提供了一个上下文对象【从原来 2.x 中 this 选择性地暴露了一些 property（attrs/emit/slots）】 attrs 和 slots 都是内部组件实例上对应项的代理，可以确保在更新后仍然是最新值。所以可以解构，无需担心后面访问到过期的值 为什么props作为第一个参数？ 组件使用 props 的场景更多，有时候甚至只使用 props 将 props 独立出来作为第一个参数，可以让 TypeScript 对 props 单独做类型推导，不会和上下文中的其他属性相混淆。这也使得 setup 、 render 和其他使用了 TSX 的函数式组件的签名保持一致 this 在 setup() 中不可用。由于 setup() 在解析 2.x 选项前被调用，setup() 中的 this 将与 2.x 选项中的 this 完全不同。同时在 setup() 和 2.x 选项中使用 this 时将造成混乱 setup(props, { attrs }) { // 一个可能之后回调用的签名 function onClick() { console.log(attrs.foo) // 一定是最新的引用，没有丢失响应性 } }","tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/NollieLeo/tags/vue/"},{"name":"vite","slug":"vite","permalink":"https://github.com/NollieLeo/tags/vite/"}]},{"title":"进程通信(electron/node)","date":"2022-03-26T10:51:07.000Z","path":"2022/03/26/进程通信-electron-node/","text":"进程通信不同进程之间因为可用的内存不同，所以要通过一个中间介质通信。 信号量 如果是简单的标记，通过一个数字来表示，放在 PCB 的一个属性里，这叫做信号量，比如锁的实现就可以通过信号量。 这种信号量的思想我们写前端代码也经常用，比如实现节流的时候，也要加一个标记变量。 管道 但是信号量不能传递具体的数据啊，传递具体数据还得用别的方式。比如我们可以通过读写文件的方式来通信，这就是管道，如果是在内存中的文件，叫做匿名管道，没有文件名，如果是真实的硬盘的文件，是有文件名的，叫做命名管道。 文件需要先打开，然后再读和写，之后再关闭，这也是管道的特点。管道是基于文件的思想封装的，之所以叫管道，是因为只能一个进程读、一个进程写，是单向的（半双工）。而且还需要目标进程同步的消费数据，不然就会阻塞住。 这种管道的方式实现起来很简单，就是一个文件读写，但是只能用在两个进程之间通信，只能同步的通信。其实管道的同步通信也挺常见的，就是 stream 的 pipe 方法。 消息队列 管道实现简单，但是同步的通信比较受限制，那如果想做成异步通信呢？加个队列做缓冲（buffer）不就行了，这就是消息队列。 消息队列也是两个进程之间的通信，但是不是基于文件那一套思路，虽然也是单向的，但是有了一定的异步性，可以放很多消息，之后一次性消费。 共享内存 管道、消息队列都是两个进程之间的，如果多个进程之间呢？ 我们可以通过申请一段多进程都可以操作的内存，叫做共享内存，用这种方式来通信。各进程都可以向该内存读写数据，效率比较高。 共享内存虽然效率高、也能用于多个进程的通信，但也不全是好处，因为多个进程都可以读写，那么就很容易乱，要自己控制顺序，比如通过进程的信号量（标记变量）来控制。 共享内存适用于多个进程之间的通信，不需要通过中间介质，所以效率更高，但是使用起来也更复杂。 上面说的这些几乎就是本地进程通信的全部方式了，为什么要加个本地呢？ ipc、rpc、lpc进程通信就是 ipc（Inter-Process Communication），两个进程可能是一台计算机的，也可能网络上的不同计算机的进程，所以进程通信方式分为两种： 本地过程调用 LPC（local procedure call）、远程过程调用 RPC（remote procedure call）。 本地过程调用就是我们上面说的信号量、管道、消息队列、共享内存的通信方式，但是如果是网络上的，那就要通过网络协议来通信了，这个其实我们用的比较多，比如 http、websocket。 所以，当有人提到 ipc 时就是在说进程通信，可以分为本地的和远程的两种来讨论。 远程的都是基于网络协议封装的，而本地的都是基于信号量、管道、消息队列、共享内存封装出来的，比如我们接下来要探讨的 electron 和 nodejs。 electron 进程通信electron 会先启动主进程，然后通过 BrowserWindow 创建渲染进程，加载 html 页面实现渲染。这两个进程之间的通信是通过 electron 提供的 ipc 的 api。 ipcMain、ipcRenderer 主进程里面通过 ipcMain 的 on 方法监听事件 import { ipcMain } from ``&#39;electron&#39;``;` `ipcMain.on(``&#39;异步事件&#39;``, (event, arg) =&gt; {`` ``event.sender.send(``&#39;异步事件返回&#39;``, ``&#39;yyy&#39;``);``})渲染进程里面通过 ipcRenderer 的 on 方法监听事件，通过 send 发送消息 import { ipcRenderer } from ``&#39;electron&#39;``;` `ipcRender.on(``&#39;异步事件返回&#39;``, ``function` `(event, arg) {`` ``const message = `异步消息: ${arg}```})` `ipcRenderer.send(``&#39;异步事件&#39;``, ``&#39;xxx&#39;``)api 使用比较简单，这是经过 c++ 层的封装，然后暴露给 js 的事件形式的 api。 我们可以想一下它是基于哪种机制实现的呢？ 很明显有一定的异步性，而且是父子进程之间的通信，所以是消息队列的方式实现的。 remote 除了事件形式的 api 外，electron 还提供了远程方法调用 rmi （remote method invoke）形式的 api。 其实就是对消息的进一步封装，也就是根据传递的消息，调用不同的方法，形式上就像调用本进程的方法一样，但其实是发消息到另一个进程来做的，和 ipcMain、ipcRenderer 的形式本质上一样。 比如在渲染进程里面，通过 remote 来直接调用主进程才有的 BrowserWindow 的 api。 const { BrowserWindow } = require(``&#39;electron&#39;``).remote;` `let win = ``new` `BrowserWindow({ width: 800, height: 600 });``win.loadURL(``&#39;&#39;``);小结一下，electron 的父子进程通信方式是基于消息队列封装的，封装形式有两种，一种是事件的方式，通过 ipcMain、ipcRenderer 的 api 使用，另一种则是进一步封装成了不同方法的调用（rmi），底层也是基于消息，执行远程方法但是看上去像执行本地方法一样。 nodejsnodejs 提供了创建进程的 api，有两个模块： c 和 cluster。很明显，一个是用于父子进程的创建和通信，一个是用于多个进程。 child_process child_process 提供了 spawn、exec、execFile、fork 的 api，分别用于不同的进程的创建： spawn、exec 如果想通过 shell 执行命令，那就用 spawn 或者 exec。因为一般执行命令是需要返回值的，这俩 api 在返回值的方式上有所不同。 spawn 返回的是 stream，通过 data 事件来取，exec 进一步分装成了 buffer，使用起来简单一些，但是可能会超过 maxBuffer。 const { spawn } = require(``&#39;child_process&#39;``);` `var` `app = spawn(``&#39;node&#39;``,``&#39;main.js&#39;` `{env:{}});` `app.stderr.on(``&#39;data&#39;``,``function``(data) {`` ``console.log(``&#39;Error:&#39;``,data);``});` `app.stdout.on(``&#39;data&#39;``,``function``(data) {`` ``console.log(data);``});其实 exec 是基于 spwan 封装出来的，简单场景可以用，有的时候要设置下 maxBuffer。 const { exec } = require(``&#39;child_process&#39;``);` `exec(``&#39;find . -type f&#39;``, { maxBuffer: 1024*1024 }(err, stdout, stderr) =&gt; {`` ``if` `(err) {`` ``console.error(`exec error: ${err}`); ``return``;`` ``} `` ``console.log(stdout);``});execFile 除了执行命令外，如果要执行可执行文件就用 execFile 的 api： const { execFile } = require(``&#39;child_process&#39;``);` `const child = execFile(``&#39;node&#39;``, [``&#39;--version&#39;``], (error, stdout, stderr) =&gt; {`` ``if` `(error) { ``throw` `error; }`` ``console.log(stdout);``});fork 还有如果是想执行 js ，那就用 fork： const { fork } = require(``&#39;child_process&#39;``); ` `const xxxProcess = fork(``&#39;./xxx.js&#39;``); ``xxxProcess.send(``&#39;111111&#39;``); ``xxxProcess.on(``&#39;message&#39;``, sum =&gt; { `` ``res.end(``&#39;22222&#39;``); ``});小结 简单小结一下 child_process 的 4 个 api： 如果想执行 shell 命令，用 spawn 和 exec，spawn 返回一个 stream，而 exec 进一步封装成了 buffer。除了 exec 有的时候需要设置下 maxBuffer，其他没区别。 如果想执行可执行文件，用 execFile。 如果想执行 js 文件，用 fork。 child_process 的进程通信 说完了 api 我们来说下 child_process 创建的子进程怎么和父进程通信，也就是怎么做 ipc。 pipe 首先，支持了 pipe，很明显是通过管道的机制封装出来的，能同步的传输流的数据。 const { spawn } = require(&#39;child_process&#39;); const find = spawn(&#39;cat&#39;, [&#39;./aaa.js&#39;]); const wc = spawn(&#39;wc&#39;, [&#39;-l&#39;]); find.stdout.pipe(wc.stdin); 比如上面通过管道把一个进程的输出流传输到了另一个进程的输入流，和下面的 shell 命令效果一样： cat ./aaa.js | wc -lmessage spawn 支持 stdio 参数，可以设置和父进程的 stdin、stdout、stderr 的关系，比如指定 pipe 或者 null。还有第四个参数，可以设置 ipc，这时候就是通过事件的方式传递消息了，很明s显，是基于消息队列实现的。 const { spawn } = require(&#39;child_process&#39;); const child = spawn(&#39;node&#39;, [&#39;./child.js&#39;], { stdio: [&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;, &#39;ipc&#39;]}); child.on(&#39;message&#39;, (m) =&gt; { console.log(m);}); child.send(&#39;this is weng&#39;); 而 fork 的 api 创建的子进程自带了 ipc 的传递消息机制，可以直接用。 const { fork } = require(``&#39;child_process&#39;``); ` `const xxxProcess = fork(``&#39;./xxx.js&#39;``); ``xxxProcess.send(``&#39;111111&#39;``); ``xxxProcess.on(``&#39;message&#39;``, sum =&gt; { `` ``res.end(``&#39;22222&#39;``); ``});cluster cluster 不再是父子进程了，而是更多进程，也提供了 fork 的 api。 比如 http server 会根据 cpu 数启动多个进程来处理请求。 import cluster from ``&#39;cluster&#39;``;``import http from ``&#39;http&#39;``;``import { cpus } from ``&#39;os&#39;``;``import process from ``&#39;process&#39;``;` `const numCPUs = cpus().length;` `if` `(cluster.isPrimary) {`` ``for` `(let i = 0; i &lt; numCPUs; i++) {`` ``cluster.fork();`` ``}``} ``else` `{`` ``const server = http.createServer((req, res) =&gt; {`` ``res.writeHead(200);`` ``res.end(``&#39;hello worldn&#39;``);`` ``})`` ` ` ``server.listen(8000);`` ` ` ``process.on(``&#39;message&#39;``, (msg) =&gt; {`` ``if` `(msg === ``&#39;shutdown&#39;``) {`` ``server.close();`` ``}`` ``});``}它同样支持了事件形式的 api，用于多个进程之间的消息传递，因为多个进程其实也只是多个父子进程的通信，子进程之间不能直接通信，所以还是基于消息队列实现的。 共享内存 子进程之间通信还得通过父进程中转一次，要多次读写消息队列，效率太低了，就不能直接共享内存么？ 现在 nodejs 还是不支持的，可以通过第三方的包 shm-typed-array 来实现，感兴趣可以看一下。 总结进程包括代码、数据和 PCB，是程序的一次执行的过程，PCB 记录着各种执行过程中的信息，比如分配的资源、执行到的地址、用于通信的数据结构等。 进程之间需要通信，可以通过信号量、管道、消息队列、共享内存的方式。 信号量就是一个简单的数字的标记，不能传递具体数据。 管道是基于文件的思想，一个进程写另一个进程读，是同步的，适用于两个进程。 消息队列有一定的 buffer，可以异步处理消息，适用于两个进程。 共享内存是多个进程直接操作同一段内存，适用于多个进程，但是需要控制访问顺序。 这四种是本地进程的通信方式，而网络进程则基于网络协议的方式也可以做进程通信。 进程通信叫做 ipc，本地的叫做 lpc，远程的叫 rpc。 其中，如果把消息再封装一层成具体的方法调用，叫做 rmi，效果就像在本进程执行执行另一个进程的方法一样。 electron 和 nodejs 都是基于上面的操作系统机制的封装： elctron 支持 ipcMain 和 ipcRenderer 的消息传递的方式，还支持了 remote 的 rmi 的方式。 nodejs 有 child_process 和 cluster 两个模块和进程有关，child_process 是父子进程之间，cluster 是多个进程： child_process 提供了用于执行 shell 命令的 spawn、exec，用于执行可执行文件的 execFile，用于执行 js 的 fork。提供了 pipe 和 message 两种 ipc 方式。 cluster 也提供了 fork，提供了 message 的方式的通信。 当然，不管封装形式是什么，都离不开操作系统提供的信号量、管道、消息队列、共享内存这四种机制。","tags":[{"name":"electron","slug":"electron","permalink":"https://github.com/NollieLeo/tags/electron/"},{"name":"node","slug":"node","permalink":"https://github.com/NollieLeo/tags/node/"}]},{"title":"eslint rules常用配置项","date":"2022-02-27T08:19:53.000Z","path":"2022/02/27/eslint-rules常用配置项/","text":"{ &quot;no-alert&quot;: 0,//禁止使用alert confirm prompt &quot;no-array-constructor&quot;: 2,//禁止使用数组构造器 &quot;no-bitwise&quot;: 0,//禁止使用按位运算符 &quot;no-caller&quot;: 1,//禁止使用arguments.caller或arguments.callee &quot;no-catch-shadow&quot;: 2,//禁止catch子句参数与外部作用域变量同名 &quot;no-class-assign&quot;: 2,//禁止给类赋值 &quot;no-cond-assign&quot;: 2,//禁止在条件表达式中使用赋值语句 &quot;no-console&quot;: 2,//禁止使用console &quot;no-const-assign&quot;: 2,//禁止修改const声明的变量 &quot;no-constant-condition&quot;: 2,//禁止在条件中使用常量表达式 if(true) if(1) &quot;no-continue&quot;: 0,//禁止使用continue &quot;no-control-regex&quot;: 2,//禁止在正则表达式中使用控制字符 &quot;no-debugger&quot;: 2,//禁止使用debugger &quot;no-delete-var&quot;: 2,//不能对var声明的变量使用delete操作符 &quot;no-div-regex&quot;: 1,//不能使用看起来像除法的正则表达式/=foo/ &quot;no-dupe-keys&quot;: 2,//在创建对象字面量时不允许键重复 {a:1,a:1} &quot;no-dupe-args&quot;: 2,//函数参数不能重复 &quot;no-duplicate-case&quot;: 2,//switch中的case标签不能重复 &quot;no-else-return&quot;: 2,//如果if语句里面有return,后面不能跟else语句 &quot;no-empty&quot;: 2,//块语句中的内容不能为空 &quot;no-empty-character-class&quot;: 2,//正则表达式中的[]内容不能为空 &quot;no-empty-label&quot;: 2,//禁止使用空label &quot;no-eq-null&quot;: 2,//禁止对null使用==或!=运算符 &quot;no-eval&quot;: 1,//禁止使用eval &quot;no-ex-assign&quot;: 2,//禁止给catch语句中的异常参数赋值 &quot;no-extend-native&quot;: 2,//禁止扩展native对象 &quot;no-extra-bind&quot;: 2,//禁止不必要的函数绑定 &quot;no-extra-boolean-cast&quot;: 2,//禁止不必要的bool转换 &quot;no-extra-parens&quot;: 2,//禁止非必要的括号 &quot;no-extra-semi&quot;: 2,//禁止多余的冒号 &quot;no-fallthrough&quot;: 1,//禁止switch穿透 &quot;no-floating-decimal&quot;: 2,//禁止省略浮点数中的0 .5 3. &quot;no-func-assign&quot;: 2,//禁止重复的函数声明 &quot;no-implicit-coercion&quot;: 1,//禁止隐式转换 &quot;no-implied-eval&quot;: 2,//禁止使用隐式eval &quot;no-inline-comments&quot;: 0,//禁止行内备注 &quot;no-inner-declarations&quot;: [2, &quot;functions&quot;],//禁止在块语句中使用声明（变量或函数） &quot;no-invalid-regexp&quot;: 2,//禁止无效的正则表达式 &quot;no-invalid-this&quot;: 2,//禁止无效的this，只能用在构造器，类，对象字面量 &quot;no-irregular-whitespace&quot;: 2,//不能有不规则的空格 &quot;no-iterator&quot;: 2,//禁止使用__iterator__ 属性 &quot;no-label-var&quot;: 2,//label名不能与var声明的变量名相同 &quot;no-labels&quot;: 2,//禁止标签声明 &quot;no-lone-blocks&quot;: 2,//禁止不必要的嵌套块 &quot;no-lonely-if&quot;: 2,//禁止else语句内只有if语句 &quot;no-loop-func&quot;: 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以） &quot;no-mixed-requires&quot;: [0, false],//声明时不能混用声明类型 &quot;no-mixed-spaces-and-tabs&quot;: [2, false],//禁止混用tab和空格 &quot;linebreak-style&quot;: [0, &quot;windows&quot;],//换行风格 &quot;no-multi-spaces&quot;: 1,//不能用多余的空格 &quot;no-multi-str&quot;: 2,//字符串不能用\\换行 &quot;no-multiple-empty-lines&quot;: [1, {&quot;max&quot;: 2}],//空行最多不能超过2行 &quot;no-native-reassign&quot;: 2,//不能重写native对象 &quot;no-negated-in-lhs&quot;: 2,//in 操作符的左边不能有! &quot;no-nested-ternary&quot;: 0,//禁止使用嵌套的三目运算 &quot;no-new&quot;: 1,//禁止在使用new构造一个实例后不赋值 &quot;no-new-func&quot;: 1,//禁止使用new Function &quot;no-new-object&quot;: 2,//禁止使用new Object() &quot;no-new-require&quot;: 2,//禁止使用new require &quot;no-new-wrappers&quot;: 2,//禁止使用new创建包装实例，new String new Boolean new Number &quot;no-obj-calls&quot;: 2,//不能调用内置的全局对象，比如Math() JSON() &quot;no-octal&quot;: 2,//禁止使用八进制数字 &quot;no-octal-escape&quot;: 2,//禁止使用八进制转义序列 &quot;no-param-reassign&quot;: 2,//禁止给参数重新赋值 &quot;no-path-concat&quot;: 0,//node中不能使用__dirname或__filename做路径拼接 &quot;no-plusplus&quot;: 0,//禁止使用++，-- &quot;no-process-env&quot;: 0,//禁止使用process.env &quot;no-process-exit&quot;: 0,//禁止使用process.exit() &quot;no-proto&quot;: 2,//禁止使用__proto__属性 &quot;no-redeclare&quot;: 2,//禁止重复声明变量 &quot;no-regex-spaces&quot;: 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/ &quot;no-restricted-modules&quot;: 0,//如果禁用了指定模块，使用就会报错 &quot;no-return-assign&quot;: 1,//return 语句中不能有赋值表达式 &quot;no-script-url&quot;: 0,//禁止使用javascript:void(0) &quot;no-self-compare&quot;: 2,//不能比较自身 &quot;no-sequences&quot;: 0,//禁止使用逗号运算符 &quot;no-shadow&quot;: 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名 &quot;no-shadow-restricted-names&quot;: 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用 &quot;no-spaced-func&quot;: 2,//函数调用时 函数名与()之间不能有空格 &quot;no-sparse-arrays&quot;: 2,//禁止稀疏数组， [1,,2] &quot;no-sync&quot;: 0,//nodejs 禁止同步方法 &quot;no-ternary&quot;: 0,//禁止使用三目运算符 &quot;no-trailing-spaces&quot;: 1,//一行结束后面不要有空格 &quot;no-this-before-super&quot;: 0,//在调用super()之前不能使用this或super &quot;no-throw-literal&quot;: 2,//禁止抛出字面量错误 throw &quot;error&quot;; &quot;no-undef&quot;: 1,//不能有未定义的变量 &quot;no-undef-init&quot;: 2,//变量初始化时不能直接给它赋值为undefined &quot;no-undefined&quot;: 2,//不能使用undefined &quot;no-unexpected-multiline&quot;: 2,//避免多行表达式 &quot;no-underscore-dangle&quot;: 1,//标识符不能以_开头或结尾 &quot;no-unneeded-ternary&quot;: 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false; &quot;no-unreachable&quot;: 2,//不能有无法执行的代码 &quot;no-unused-expressions&quot;: 2,//禁止无用的表达式 &quot;no-unused-vars&quot;: [2, {&quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;after-used&quot;}],//不能有声明后未被使用的变量或参数 &quot;no-use-before-define&quot;: 2,//未定义前不能使用 &quot;no-useless-call&quot;: 2,//禁止不必要的call和apply &quot;no-void&quot;: 2,//禁用void操作符 &quot;no-var&quot;: 0,//禁用var，用let和const代替 &quot;no-warning-comments&quot;: [1, { &quot;terms&quot;: [&quot;todo&quot;, &quot;fixme&quot;, &quot;xxx&quot;], &quot;location&quot;: &quot;start&quot; }],//不能有警告备注 &quot;no-with&quot;: 2,//禁用with &quot;array-bracket-spacing&quot;: [2, &quot;never&quot;],//是否允许非空数组里面有多余的空格 &quot;arrow-parens&quot;: 0,//箭头函数用小括号括起来 &quot;arrow-spacing&quot;: 0,//=&gt;的前/后括号 &quot;accessor-pairs&quot;: 0,//在对象中使用getter/setter &quot;block-scoped-var&quot;: 0,//块语句中使用var &quot;brace-style&quot;: [1, &quot;1tbs&quot;],//大括号风格 &quot;callback-return&quot;: 1,//避免多次调用回调什么的 &quot;camelcase&quot;: 2,//强制驼峰法命名 &quot;comma-dangle&quot;: [2, &quot;never&quot;],//对象字面量项尾不能有逗号 &quot;comma-spacing&quot;: 0,//逗号前后的空格 &quot;comma-style&quot;: [2, &quot;last&quot;],//逗号风格，换行时在行首还是行尾 &quot;complexity&quot;: [0, 11],//循环复杂度 &quot;computed-property-spacing&quot;: [0, &quot;never&quot;],//是否允许计算后的键名什么的 &quot;consistent-return&quot;: 0,//return 后面是否允许省略 &quot;consistent-this&quot;: [2, &quot;that&quot;],//this别名 &quot;constructor-super&quot;: 0,//非派生类不能调用super，派生类必须调用super &quot;curly&quot;: [2, &quot;all&quot;],//必须使用 if(){} 中的{} &quot;default-case&quot;: 2,//switch语句最后必须有default &quot;dot-location&quot;: 0,//对象访问符的位置，换行的时候在行首还是行尾 &quot;dot-notation&quot;: [0, { &quot;allowKeywords&quot;: true }],//避免不必要的方括号 &quot;eol-last&quot;: 0,//文件以单一的换行符结束 &quot;eqeqeq&quot;: 2,//必须使用全等 &quot;func-names&quot;: 0,//函数表达式必须有名字 &quot;func-style&quot;: [0, &quot;declaration&quot;],//函数风格，规定只能使用函数声明/函数表达式 &quot;generator-star-spacing&quot;: 0,//生成器函数*的前后空格 &quot;guard-for-in&quot;: 0,//for in循环要用if语句过滤 &quot;handle-callback-err&quot;: 0,//nodejs 处理错误 &quot;id-length&quot;: 0,//变量名长度 &quot;indent&quot;: [2, 4],//缩进风格 &quot;init-declarations&quot;: 0,//声明时必须赋初值 &quot;key-spacing&quot;: [0, { &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true }],//对象字面量中冒号的前后空格 &quot;lines-around-comment&quot;: 0,//行前/行后备注 &quot;max-depth&quot;: [0, 4],//嵌套块深度 &quot;max-len&quot;: [0, 80, 4],//字符串最大长度 &quot;max-nested-callbacks&quot;: [0, 2],//回调嵌套深度 &quot;max-params&quot;: [0, 3],//函数最多只能有3个参数 &quot;max-statements&quot;: [0, 10],//函数内最多有几个声明 &quot;new-cap&quot;: 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用 &quot;new-parens&quot;: 2,//new时必须加小括号 &quot;newline-after-var&quot;: 2,//变量声明后是否需要空一行 &quot;object-curly-spacing&quot;: [0, &quot;never&quot;],//大括号内是否允许不必要的空格 &quot;object-shorthand&quot;: 0,//强制对象字面量缩写语法 &quot;one-var&quot;: 1,//连续声明 &quot;operator-assignment&quot;: [0, &quot;always&quot;],//赋值运算符 += -=什么的 &quot;operator-linebreak&quot;: [2, &quot;after&quot;],//换行时运算符在行尾还是行首 &quot;padded-blocks&quot;: 0,//块语句内行首行尾是否要空行 &quot;prefer-const&quot;: 0,//首选const &quot;prefer-spread&quot;: 0,//首选展开运算 &quot;prefer-reflect&quot;: 0,//首选Reflect的方法 &quot;quotes&quot;: [1, &quot;single&quot;],//引号类型 `` &quot;&quot; &#39;&#39; &quot;quote-props&quot;:[2, &quot;always&quot;],//对象字面量中的属性名是否强制双引号 &quot;radix&quot;: 2,//parseInt必须指定第二个参数 &quot;id-match&quot;: 0,//命名检测 &quot;require-yield&quot;: 0,//生成器函数必须有yield &quot;semi&quot;: [2, &quot;always&quot;],//语句强制分号结尾 &quot;semi-spacing&quot;: [0, {&quot;before&quot;: false, &quot;after&quot;: true}],//分号前后空格 &quot;sort-vars&quot;: 0,//变量声明时排序 &quot;space-after-keywords&quot;: [0, &quot;always&quot;],//关键字后面是否要空一格 &quot;space-before-blocks&quot;: [0, &quot;always&quot;],//不以新行开始的块{前面要不要有空格 &quot;space-before-function-paren&quot;: [0, &quot;always&quot;],//函数定义时括号前面要不要有空格 &quot;space-in-parens&quot;: [0, &quot;never&quot;],//小括号里面要不要有空格 &quot;space-infix-ops&quot;: 0,//中缀操作符周围要不要有空格 &quot;space-return-throw-case&quot;: 2,//return throw case后面要不要加空格 &quot;space-unary-ops&quot;: [0, { &quot;words&quot;: true, &quot;nonwords&quot;: false }],//一元运算符的前/后要不要加空格 &quot;spaced-comment&quot;: 0,//注释风格要不要有空格什么的 &quot;strict&quot;: 2,//使用严格模式 &quot;use-isnan&quot;: 2,//禁止比较时使用NaN，只能用isNaN() &quot;valid-jsdoc&quot;: 0,//jsdoc规则 &quot;valid-typeof&quot;: 2,//必须使用合法的typeof的值 &quot;vars-on-top&quot;: 2,//var必须放在作用域顶部 &quot;wrap-iife&quot;: [2, &quot;inside&quot;],//立即执行函数表达式的小括号风格 &quot;wrap-regex&quot;: 0,//正则表达式字面量用小括号包起来 &quot;yoda&quot;: [2, &quot;never&quot;]//禁止尤达条件 }","tags":[{"name":"eslint","slug":"eslint","permalink":"https://github.com/NollieLeo/tags/eslint/"}]},{"title":"electron学习记录","date":"2022-01-12T06:58:10.000Z","path":"2022/01/12/electron学习记录/","text":"electron核心模块 code/wengblog/NollieLeo.github.io/source/_posts/electron学习记录/WeChat2314efdd8331a8e89163bc315a1a25a4.png 快速搭建demo官方demo快速搭建（electron-quick-template）git地址 # Clone this repository git clone https://github.com/electron/electron-quick-start # Go into the repository cd electron-quick-start # Install dependencies npm install # Run the app npm start 搭建vue + electron使用electron-vue 中文文档 # 安装 vue-cli 和 脚手架样板代码 npm install -g vue-cli vue init simulatedgreg/electron-vue my-project # 安装依赖并运行你的程序 cd my-project yarn # 或者 npm install yarn run dev # 或者 npm run dev 使用vue cli自带的可视化创建项目 vue cli有很多插件化的东西可以用 # 打开可视化界面 vue ui 如图： 然后点新增一个 code/wengblog/NollieLeo.github.io/source/_posts/electron学习记录image-20220112153922959.png 嗯对，继续，想选啥选啥 code/wengblog/NollieLeo.github.io/source/_posts/electron学习记录image-20220112154019140.png 然后就在下载了 code/wengblog/NollieLeo.github.io/source/_posts/electron学习记录image-20220112154214278.png 然后插件中搜索 vue-cli-plugin-electron-builder, 安装他 或者使用 vue add electron-builder安装 code/wengblog/NollieLeo.github.io/source/_posts/electron学习记录image-20220112154326504.png 接下来直接就：就ok了 npm run electron:serve {% image /Users/leo/Desktop/weng's 'image-20220112154639191' 'code/wengblog/NollieLeo.github.io/source/_posts/electron学习记录\\image-20220112154639191.png' %} 如何调试主进程 基于vscode通过ws协议进行调试，之后通过端口就可进入调试的页面，就形容调试node vscode调试官方文档 使用electron自带的 插件 electron-debug 在dev文件中引入 ![image-20220115143454095](/Users/leo/Desktop/weng’s code/weng’blog/NollieLeo.github.io/source/_posts/electron学习记录\\image-20220115143454095.png) 在主进程中引入 ![image-20220115143536900](/Users/leo/Desktop/weng’s code/weng’blog/NollieLeo.github.io/source/_posts/electron学习记录\\image-20220115143536900.png) 启动之后呢就能看到终端打印了这句话 {% image /Users/leo/Desktop/weng's 'image-20220115143611685' 'code/wengblog/NollieLeo.github.io/source/_posts/electron学习记录\\image-20220115143611685.png' %} 打开chrome://devices就ok了 使用electron-vue + vscode配置vscode 找到左侧一个虫子一样的图标 ![image-20220115112806086](/Users/leo/Desktop/weng’s code/weng’blog/NollieLeo.github.io/source/_posts/electron学习记录\\image-20220115112806086.png) 选择上面的下拉面板，添加配置（这里是node，就选择nodejs） ![image-20220115112904875](/Users/leo/Desktop/weng’s code/weng’blog/NollieLeo.github.io/source/_posts/electron学习记录\\image-20220115112904875.png) vscode会自动创建一个文件 .vscode/路径下的launch.json文件。 launch.json 基于electron-vue的配置（以下配置再用electron-vue的时候复制进去吧） { &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Electron Main&quot;, &quot;program&quot;: &quot;${workspaceFolder}/.electron-vue/dev-runner.js&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;skipFiles&quot;: [ &quot;&lt;node_internals&gt;/**&quot; ], &quot;type&quot;: &quot;node&quot;, &quot;autoAttachChildProcesses&quot;: true, &quot;protocol&quot;: &quot;inspector&quot; } ] } 这里的program指的是调试的入口文件，如果是用 官方的快速 模板搭建的话，就是main.js，而electron-vue则得是.electron-vue/dev-runner.js文件 修改electron-vue相关配置文件webpack.main.config.js 再electron-vue搭建的目录.electron-vue下的webpack.main.config.js 添加配置 code/wengblog/NollieLeo.github.io/source/_posts/electron学习记录image-20220115121624744.png dev-runner.js 再electron-vue搭建的目录.electron-vue下的dev-runner.js 把 .electron-vue/dev-runner.js 里以下报错代码注释掉。 // // detect yarn or npm and process commandline args accordingly // if (process.env.npm_execpath.endsWith(&#39;yarn.js&#39;)) { // args = args.concat(process.argv.slice(3)) // } else if (process.env.npm_execpath.endsWith(&#39;npm-cli.js&#39;)) { // args = args.concat(process.argv.slice(2)) // } 这样是为了避免控制台报错 code/wengblog/NollieLeo.github.io/source/_posts/electron学习记录image-20220115121919211.png 开始调试打开vscode 通过快捷方式F5或者手动点击头部菜单 的 运行中的调试就可以开始了 这时候就能在调试控制台看到这句话 code/wengblog/NollieLeo.github.io/source/_posts/electron学习记录image-20220115122235932.png 我们打开浏览器输入chrome://inspect/#devices code/wengblog/NollieLeo.github.io/source/_posts/electron学习记录image-20220115122309093.png 点击inspect就能看到文件了，这时候直接打断点就OK （正在调试的文件是有绿色的小点点） code/wengblog/NollieLeo.github.io/source/_posts/electron学习记录image-20220115122412302.png 倘若第一次调试，则需要点击上方的添加文件按钮将目录添加到调试工具当中 code/wengblog/NollieLeo.github.io/source/_posts/electron学习记录image-20220115122506756.png vue-cli + vue-cli-plugin-electron-builder 调试官方文档 调试demo地址 其他调试的launch.json配置{ &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { //方式一 &quot;name&quot;: &quot;Debug Main Process&quot;, &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;timeout&quot;: 60000, //避免出现can not connect to the target错误 &quot;runtimeExecutable&quot;: &quot;${workspaceFolder}/node_modules/.bin/electron&quot;, &quot;windows&quot;: { &quot;runtimeExecutable&quot;: &quot;${workspaceFolder}/node_modules/.bin/electron.cmd&quot; }, &quot;args&quot; : [&quot;.&quot;], &quot;env&quot;: { &quot;NODE_ENV&quot;: &quot;development&quot; }, &quot;protocol&quot;: &quot;inspector&quot; }, { //方式二 &quot;name&quot;: &quot;Attach&quot;, &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;attach&quot;, &quot;port&quot;: 5858, &quot;sourceMaps&quot;: true, &quot;address&quot;: &quot;localhost&quot;, &quot;timeout&quot;: 60000 //避免出现can not connect to the target错误 } ] } 进程之间的通信 官方文档： ipcMain ipcRenderer webContents 主线程 到 渲染线程 通过 mainWin.webContents.send 来发送 —&gt;ipcRenderer.on 来监听 渲染线程 到 主线程 需要通过 ipcRenderer.send发送 —&gt; ipcMain.on来监听 原理electron使用mojo的框架完成进程间通信的工作 mojo框架提供了一套地层的ipc实现，包括 消息管道，数据管道，共享缓存缓冲区等等。 electron在api.mojom文件中定义了相关的通信接口描述文件 源码 其中比较重要的就是 ElectronRenderer 和 ElectronApiIPC 这两个定义，与主进程和渲染进程通信有关 在编译Electron源码的过程，mojo框架会把这些通信描述文件转义为具体的实现代码 之后shell\\renderer\\api\\electron_api_ipc_renderer.cc和shell\\browser\\api\\electron_api_web_contents.cc这两个c++文件都会去引用这个编译之后的文件（shell\\common\\api\\api.mojom.h）头文件。 在我们js代码中使用 await ipcRenderer.invoke(&#39;event&#39;,&#39;message&#39;); 其实地层走的就是shell\\renderer\\api\\electron_api_ipc_renderer.cc 这段代码除了创建一个 Promise 对象之外，还执行了 electron_brower_remote对象（Mojo的通信对象）的invoke的方法 之后mojo会组织消息，把这个消息发给主进程，并执行了 electron_api_web_contents.cc 中WebContents::Invoke的方法 这个方法会发射一个名字为-ipc-invoke的事件，把渲染进程传递过来的数据都发射出去，之后和这个事件会触发位于 lib/browser/api/web-contents/ts的ts代码中 {% image /Users/leo/Desktop/weng's 'image-20220327113128169' 'code/wengblog/NollieLeo.github.io/source/_posts/electron学习记录/image-20220327113128169.png' %} 这个逻辑当中，electron会去查找一个map对象 是否注册了当前的处理逻辑，有的话执行用户代码，否则异常 invoke之后会把处理的结果返回渲染进程（基于mojo的进程通信，实现代码shell/brower/api/event.cc） 我们在调用ipcMain.handle 方法为主进程注册某事件的处理逻辑时候，实际上执行了 /lib/brower/ipc-main-tmpl.ts 就是将用户的处理逻辑包装起来存放到map对象当中，这就对应了上述的invoke触发的时候，做的事情了。 大致是通信的基本逻辑 渲染进程和主进程异步通信ipcRenderer.send + ipcMain.on/oncerenderer.js (渲染进程文件) import { ipcRenderer } from &#39;electron&#39;; function handleMessage(){ ipcRenderer.send(&#39;renderer-to-main&#39;, &#39;this is weng&#39;) } main.js (主进程) import { ipcMain } from &#39;electron&#39;; ipcMain.on(&#39;renderer-to-main&#39;, (event, message)=&gt;{ console.log(&#39;this is a message from weng&#39;, message) }) 假如主进程需要回复渲染进程的消息 主进程可以通过 event.reply 回复异步消息，然后前提是渲染进程也需要监听这个事件 renderer.js import { ipcRenderer } from &#39;electron&#39;; function handleMessage(){ ipcRenderer.send(&#39;renderer-to-main&#39;, &#39;this is weng&#39;) } ipcRenderer.on(&#39;main-to-renderer&#39;,(event, message)=&gt;{ console.log(&#39;reply to weng&#39;, message); // 给翁恺敏发消息 }) Main.js import { ipcMain } from &#39;electron&#39;; ipcMain.on(&#39;renderer-to-main&#39;, (event, message)=&gt;{ console.log(&#39;this is a message from weng&#39;, message) event.reply(&#39;main-to-renderer&#39;, &quot;给翁恺敏发消息&quot;); }) 1、主进程通过 ipcMain.on 来监听渲染进程的消息； 2、主进程接收到消息后，可以回复消息，也可以不回复。如果回复的话，通过 event.reply 发送另一个事件，渲染进程监听这个事件得到回复结果。如果不回复消息的话，渲染进程将接着执行 ipcRenderer.send 之后的代码。 上面提到过了, send 这样的方式，主进程可以给回复，也可以不给回复，但是得通过 event.replay。如果此时你试图用 return 的方式传递返回值的话，结果并不能达到你的预期。 ipcMain.handle/handleOnce + ipcRenderer.invoke 这是另外一种通信手段 main.js // main.js const { ipcMain } = require(&#39;electron&#39;); // 返回的数据将会被promise包裹 ipcMain.handle(&#39;render-invoke-to-main&#39;, async (event, message) =&gt; { console.log(`receive message from render: ${message}`) const result = await asyncWork(); return result; // 假如需要回复渲染进程直接return就行 }) const asyncWork = async () =&gt; { return new Promise(resolve =&gt; { setTimeout(() =&gt; { resolve(&#39;延迟 2 秒获取到主进程的返回结果&#39;) }, 2000) }) } renderer.js // render.js const { ipcRenderer } = require(&#39;electron&#39;); async function invokeMessageToMain() { const replyMessage = await ipcRenderer.invoke(&#39;render-invoke-to-main&#39;, &#39;我是渲染进程通过 invoke 发送的消息&#39;); console.log(&#39;replyMessage&#39;, replyMessage); } 1、主进程通过 ipcMain.handle 来处理渲染进程发送的消息； 2、主进程接收到消息后，可以回复消息，也可以不回复。如果回复消息的话，可以通过 return 给渲染进程回复消息；如果不回复消息的话，渲染进程将接着执行 ipcRenderer.invoke 之后的代码。 3、渲染进程异步等待主进程的回应， invoke 的返回值是一个 Promise&lt;pending&gt; 。 window.webContents.send 这种方式依赖于 webContents 对象，它是我们在项目中新建窗口时，产生的窗口对象上的一个属性。 // 窗口在完成加载时，通过 webContents.send 给渲染进程发送消息 window.webContents.on(&#39;did-finish-load&#39;, () =&gt; { window.webContents.send(&#39;main-send-to-render&#39;, &#39;启动完成了&#39;) }) 之前我们通过渲染进程监听主进程的事件 // render.js const { ipcRenderer } = require(&#39;electron&#39;); ipcRenderer.on(&#39;main-send-to-render&#39;, (event, message) =&gt; { console.log(`receive message from main: ${message}`) }) 渲染进程和主进程的同步通信ipcRenderer.sendSync + ipcMain.on/oncerenderer.js // render.js const { ipcRenderer } = require(&#39;electron&#39;); function sendSyncMessageToMain() { const replyMessage = ipcRenderer.sendSync(&#39;render-send-sync-to-main&#39;, &#39;我是渲染进程通过 syncSend 发送给主进程的消息&#39;); console.log(&#39;replyMessage&#39;, replyMessage); // &#39;主进程回复的消息&#39; } Main.js // main.js const { ipcMain } = require(&#39;electron&#39;); ipcMain.on(&#39;render-send-sync-to-main&#39;, (event, message) =&gt; { console.log(`receive message from render: ${message}`) event.returnValue = &#39;主进程回复的消息&#39;; }) 1、主进程通过 ipcMain.on 来处理渲染进程发送的消息； 2、主进程通过 event.returnValue 回复渲染进程消息； 3、如果 event.returnValue 不为 undefined 的话，渲染进程会等待 sendSync 的返回值才执行后面的代码； 4、请保证 event.returnValue是有值的，否则会造成非预期的影响。 上面的案例，主进程绑定的处理函数是一个同步的，我们将它换为异步的来看看： // main.js const { ipcMain } = require(&#39;electron&#39;); ipcMain.on(&#39;render-send-sync-to-main&#39;, async (event, message) =&gt; { console.log(`receive message from render: ${message}`) const result = await asyncWork(); event.returnValue = result; }) const asyncWork = async () =&gt; { return new Promise(resolve =&gt; { setTimeout(() =&gt; { resolve(&#39;延迟 2 秒获取到主进程的返回结果&#39;) }, 2000) }) } 这次我们在执行完一个异步函数 asyncWork 之后再给 event.returnValue 赋值。 结果发现渲染进程那边会在 2 秒之后才打印： &quot;replyMessage 延迟 2 秒获取到主进程的返回结果&quot; 而且对于渲染进程，以下两种写法，结果都是一样的： // render.js const { ipcRenderer } = require(&#39;electron&#39;); function sendSyncMessageToMain() { const replyMessage = ipcRenderer.sendSync(&#39;render-send-sync-to-main&#39;, &#39;我是渲染进程通过 syncSend 发送给主进程的消息&#39;); console.log(&#39;replyMessage&#39;, replyMessage); // &#39;replyMessage 延迟 2 秒获取到主进程的返回结果&#39;&#39; } // 或者改用 async 函数 async function sendSyncMessageToMain() { const replyMessage = await ipcRenderer.sendSync(&#39;render-send-sync-to-main&#39;, &#39;我是渲染进程发送给主进程的同步消息&#39;); console.log(&#39;replyMessage&#39;, replyMessage); // &#39;replyMessage 延迟 2 秒获取到主进程的返回结果&#39; } 也就是说，不论渲染进程在接收 sendSync 结果的时候，是不是用 await 等待，都会等待结果返回后才向下执行。但如果你已经确定你的请求是一个异步的话，建议还是使用 invoke 去发送消息，这里出于两点原因考虑： 1、方法名 sendSync 就很符合语义，发送同步消息； 2、请求执行的明明是异步代码，但是如果你用 const replyMessage = ipcRenderer.sendSync(&#39;xxx&#39;) 方式来获取响应信息，会很奇怪。 OKK，上面的第四点谈到了，请保证 event.returnValue 是有值的，否则会照成非预期的影响。让我们也来写个例子： // render.js const { ipcRenderer } = require(&#39;electron&#39;); function sendSyncMessageToMain() { const replyMessage = ipcRenderer.sendSync(&#39;render-send-sync-to-main&#39;, &#39;我是渲染进程通过 syncSend 发送给主进程的消息&#39;); console.log(&#39;replyMessage&#39;, replyMessage); // replyMessage {error: &quot;reply was never sent&quot;} console.log(&#39;next&#39;); // 这里也会执行 } // main.js ipcMain.on(&#39;render-send-sync-to-main&#39;, async (event, message) =&gt; { console.log(`receive message from render: ${message}`) }) 在上面的例子中，主进程那边不对 event.returnValue 做处理，在渲染进程这边将会得到一个错误： {error: &quot;reply was never sent&quot;} 虽然 next 也会打印，但是如果你再想去发送一次 render-send-sync-to-main 你会发现页面已经卡了… 渲染进程与渲染进程(窗口与窗口)的通讯ipcRenderer.sendTo + ipcRenderer.on 举个例子：B窗口给你A窗口发送消息 窗口A ipcRenderer.on(&#39;B-to-A&#39;,(event,message)=&gt;{ console.log(message) }) 窗口B const A_ID = ipcRenderer.sendSync(&#39;getWinId&#39;, &#39;A&#39;) ipcRenderer.sendTo(A_ID,&#39;B-to-A&#39;,&#39;我是来自B窗口的消息&#39;) 渲染进程和webview的通讯ipcRenderer.sendToHost + webview.addEventListener(“ipc-message”)渲染进程 const webview = document.querySelector(&#39;webview&#39;); webview.addEventListener(&#39;ipc-message&#39;,(event, message)=&gt;{ console.log(message) }) webview.send(&#39;rende-to-webview&#39;,&#39;发给webview里头的界面&#39;); // 给webview发消息 webview内嵌的页面 import { ipcRenderer } from &#39;electron&#39;; ipcRenderer.on(&#39;send-to&#39;,(event,args)=&gt;{ console.log(&#39;收到渲染进程发来的消息&#39;,args); ipcRenderer.sendToHost(&#39;message&#39;, &#39;我是webview发过来的消息&#39;) }) webview + preload协议 提供桥接方法通过利用webview的preload属性 preload preload其实是相当于一个页面运行其他脚本之前，先加载的指定脚本 有一点需要注意的是，webview的preload属性接受的是asar和file协议，注入js脚本 preload.js import { ipcRenderer } from &#39;electron&#39;; const Bridge = { ...各种方法或者什么参数 sayHi(data){ ipcRenderer.send(&#39;some-event&#39;, dataÏ) } } global.Bridge = Bridge; // 将Bridge的对象注入到全局对象上，webview打开的时候指的就是window webview内嵌的页面 const myBridge = window.Bridge; myBridge.sayHi(&#39;我是webview&#39;) 处理地址 const localPreloadFile = `file://${require(&#39;path&#39;).resolve(&#39;./preload.js&#39;)}` webview.setAtrribute(&#39;preload&#39;,preloadFileÏ) 通过桥接的方法，实现electron的通信机制的转发，进而实现webview和渲染进程之间的沟通 进程统一实现方案（暂未完善）import events from &quot;events&quot;; import { ipcRenderer, ipcMain, webContents } from &quot;electron&quot;; const PIPE_EVENT = &quot;__eventPipe&quot;; class Eventer { constructor() { this.instance = new events.EventEmitter(); this.instance.setMaxListeners(20); this.initEventPipe(); } /** * @description: 初始化管道配置 */ initEventPipe() { if (ipcRenderer) { ipcRenderer.on(PIPE_EVENT, (e, { eventName, eventArgs }) =&gt; { this.instance.emit(eventName, eventArgs); }); } if (ipcMain) { ipcMain.handle(PIPE_EVENT, (e, { eventName, eventArgs }) =&gt; { this.instance.emit(eventName, eventArgs); webContents.getAllWebContents().forEach((wc) =&gt; { if (wc.id !== e.sender.id) { wc.send(PIPE_EVENT, { eventName, eventArgs }); } }); }); } } /** * @description: 监听事件 * @param {*} eventName 事件名称 * @param {*} callBack 回调 * @return {*} */ on(eventName, callBack) { this.instance.on(eventName, callBack); } /** * @description: 事件触发 * @param {*} eventName * @param {*} eventArgs */ emit(eventName, eventArgs) { this.instance.emit(eventName, eventArgs); if (ipcMain) { webContents.getAllWebContents().forEach((wc) =&gt; { wc.send(PIPE_EVENT, { eventName, eventArgs }); }); } if (ipcRenderer) { ipcRenderer.invoke(PIPE_EVENT, { eventName, eventArgs }); } } } const event = new Eventer(); export default event; 主进程 import eventer from &#39;@/common/eventer&#39;; eventer.on(&#39;my-event&#39;, (args)=&gt;{ console.log(args) }) 渲染进程 import eventer from &#39;@/common/eventer&#39;; eventer.emit(&#39;my-event&#39;,(args)=&gt;{ console.log(args); }) 一些使用记录按键配置https://www.electronjs.org/zh/docs/latest/api/accelerator 渲染进程和webview的通信const webview = document.querySelector(&#39;webview&#39;); webview.addEventListener(&#39;dom-ready&#39;,()=&gt;{}); webview.addEventListener(&#39;ipc-message&#39;, ()=&gt;{ webview.send(&#39;sth&#39;) }) ipcRenderer.sendToHost(&#39;sth&#39;) // preload const preloadFile = &#39;file://&#39; + require(&#39;path&#39;).resolve(&#39;./preload.js&#39;); webview.setAttribute(&#39;preload&#39;, preloadFile); // 客户端 const clientSocket = io(&#39;http://127.0.0.1:3000/&#39;) menu（应用菜单）const menuTemplate = [ IS_MAC &amp;&amp; { label: &quot;ismac&quot; }, // macOS下第一个标签是应用程序名字,所以这里是为了兼容mac的 { label: &quot;选项&quot;, submenu: [ { label: &quot;退出&quot;, role: &quot;quit&quot;, }, { label: &quot;我的博客&quot;, click: createBlogWin, }, isDevelopment &amp;&amp; { label: &quot;打开devTool&quot;, click: createDevTool, accelerator: &quot;CommandOrControl + shift + i&quot;, }, ].filter(Boolean), }, { type: &quot;separator&quot; }, // mac下无效 { label: &quot;文件&quot;, submenu: [ { label: &quot;子菜单&quot;, click: () =&gt; { // 调用了dialog（弹窗模块），演示效果 dialog.showMessageBoxSync({ type: &quot;info&quot;, title: &quot;提示&quot;, message: &quot;点击了子菜单&quot;, }); }, }, ], }, ].filter(Boolean); const menu = Menu.buildFromTemplate(menuTemplate); Menu.setApplicationMenu(menu); 比较要注意的就是mac的第一个菜单被系统设置为了应用的名称等等 所以最上面的数组加了一行mac相关的是配 cookie基本使用const { remote } from &#39;electron&#39;; const getCookie = async (name)=&gt; { let cookie = await remote.session.defautlSession.cookies.get({name}); if(cookie.length) return cookies[0].value; else return &#39;&#39; } const setCookie = async (cookie) =&gt; { await remote.session.defautlSession.cookies.set(cookie) } defaultSession是当前浏览器会话的对象实例，也可以通过window.webContents.session获取session对象 删除浏览器缓存await remote.session.defaultSession.cookie.clearStorageData({ storages: &#39;localstorage, cookie&#39; // 删除localStroage中和cookie的缓存数据 }) storages的参数可以查看 官方文档 判断操作系统类型 process.platform 文档 import { platform } from &#39;process&#39;; console.log(`This platform is ${platform}`); ‘aix’ ‘darwin’ ‘linux’ ‘freebsd’ ‘openbsd’ ‘sunos’ ‘win32’ BrowserWindowwebSecurity官方 禁用同源策略 (通常用来测试网站)，设置false禁用网站的同源政策 禁用 webSecurity 将会禁止同源策略并且将 allowRunningInsecureContent 属性置 true。 换句话说，这将使得来自其他站点的非安全代码被执行。 net请求库（原生） 主进程 官方使用文档 dialog（系统对话框） 主进程使用 官方使用文档 *使用webview（不稳定） 假如要在页面中使用webview的话，需要设置BrowserWindow 初始化的时候的配置 webviewTag: true 官方建议文档 官方使用文档 main.js const win = new BrowserWindow({ width: 800, height: 600, webPreferences: { nodeIntegration: true, contextIsolation: false, webviewTag: true } }) electron项目中常用的库mousetrap按键事件的监听库，监听网页的按键事件 SQLite持久化数据推荐二次封装库 node-sqlite3 三次封装库 knextjs lowdb和electron-store小型的数据存储工具 离谱的坑控制台打印乱码 这种情况是由于控制台输出的不是UTF-8的编码格式 code/wengblog/NollieLeo.github.io/source/_posts/electron学习记录image-20220112210828647.png 解决： 执行start的脚本中加入 &quot;start&quot;: &quot;chcp 65001 &amp;&amp; ....&quot; electron的包装不上解决：将electron包的源改为国内的源： .npmrc文件中强制指定源 electron_mirror=&quot;https://npm.taobao.org/mirrors/electron/&quot;","tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/NollieLeo/tags/vue/"},{"name":"electron","slug":"electron","permalink":"https://github.com/NollieLeo/tags/electron/"}]},{"title":"手写promise allSettled","date":"2021-12-13T08:06:06.000Z","path":"2021/12/13/手写promise-allSettled/","text":"Promise allSettled// Promise allSettled Promise._allSettled = function (taskArr) { return new Promise((resolve, reject) =&gt; { const result = []; // 结果数组 let count = 0; // 计数，当count等于taskArr的长度的时候，说明都处理完这些promise了 taskArr.forEach((task, index) =&gt; { if (!(task instanceof Promise)) task = Promise.resolve(task); task.then((value) =&gt; { result[index] = { status: &#39;fullfilled&#39;, value } count++; if (count === taskArr.length) { resolve(result) } }, (reason) =&gt; { result[index] = { status: &#39;rejected&#39;, reason } count++; if (count === taskArr.length) { resolve(result) } }) }) }) } Promise._allSettled([ () =&gt; &#39;我不是一个promise&#39;, Promise.resolve(12121), new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(&#39;motherfucker&#39;) }, 4000); }), new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(&#39;hello&#39;) }, 3000); }) ]).then((data) =&gt; { console.log(data); })","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"}]},{"title":"手写promise race","date":"2021-12-13T07:59:30.000Z","path":"2021/12/13/手写promise-race/","text":"Promise Race// Promise race实现 Promise._race = function (taskArr) { return new Promise((resolve, reject) =&gt; { for (const iterator of taskArr) { Promise.resolve(iterator).then((data) =&gt; { resolve(data); }, (err) =&gt; { reject(err); return }) } }) }","tags":[{"name":"Promise","slug":"Promise","permalink":"https://github.com/NollieLeo/tags/Promise/"}]},{"title":"手写primise all","date":"2021-12-13T06:25:01.000Z","path":"2021/12/13/手写primise-all/","text":"手写Promise all// Promise all的实现 Promise._all = function (tasks) { return new Promise((resolve, reject) =&gt; { if (!tasks || !tasks.length) { return [] } // 结果数组 let result = []; // 做数量记录 let count = 0; for (let i = 0; i &lt; tasks.length; i++) { const element = tasks[i]; // 当前的任务 Promise.resolve(element).then( // 需要用Promise包裹以防止当前task并不是用Promise封装的 (data) =&gt; { result[i] = data; if (++count === tasks.length) { resolve(result) } }, (err) =&gt; { reject(err); return; }) } }) } Promise._all([ Promise.resolve(11211), Promise.resolve(21213212312), new Promise((resolve) =&gt; setTimeout(() =&gt; { resolve(&#39;延时&#39;) }, 1000)) ]).then((data) =&gt; { console.log(data); })","tags":[{"name":"Promise","slug":"Promise","permalink":"https://github.com/NollieLeo/tags/Promise/"}]},{"title":"手写JS并发控制（asyncPool）","date":"2021-12-13T05:57:51.000Z","path":"2021/12/13/手写JS并发控制（asyncPool）/","text":"并发控制// limiteNum: 并发数目 // tasks: 需要处理的任务列表 // iteraterFn: 完成的处理函数 // 并发控制任务 const ayncPool = async (limiteNum, tasks, iteraterFn) =&gt; { // 所有的任务队列 const rect = []; // 正在进行的任务队列 const pendingTasks = []; // 这里使用for of而不是用foreach的原因是 // forEach await 时候并不会停止遍历 for (const task of tasks) { // 这里对外层的结束处理函数包裹一层promise let promiseTask = Promise.resolve().then(() =&gt; iteraterFn(task, tasks)); // rect去存储了promiseTask rect.push(promiseTask); if (limiteNum &lt;= tasks.length) { const excutingTask = promiseTask.then(() =&gt; pendingTasks.splice(pendingTasks.indexOf(excutingTask), 1)) pendingTasks.push(excutingTask) if (pendingTasks.length &gt;= limiteNum) { // 这里去获取跑的最快的一个task await Promise.race(pendingTasks); } } } return Promise.all(rect) } const iterater = (i) =&gt; { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(i); console.log(i); }, i); }) } ayncPool(2, [1000, 5000, 3000, 2000], iterater).then((data) =&gt; { console.log(data) })","tags":[{"name":"Primise","slug":"Primise","permalink":"https://github.com/NollieLeo/tags/Primise/"},{"name":"all","slug":"all","permalink":"https://github.com/NollieLeo/tags/all/"},{"name":"race","slug":"race","permalink":"https://github.com/NollieLeo/tags/race/"}]},{"title":"手写发布订阅","date":"2021-12-13T03:14:56.000Z","path":"2021/12/13/手写发布订阅/","text":"// 发布订阅 class EventEmitter { constructor() { this.cache = {} } // 订阅事件 on(name, callback, once = false) { if (!this.cache[name]) { this.cache[name] = [] } this.cache[name].push({ callback, once }) } // 只订阅一次 once(name, callback) { this.on(name, callback, true) } // 发布 emit(name, ...rest) { if (!this.cache[name]) { return } this.cache[name].forEach((param, index) =&gt; { const { once, callback } = param; if (once) { this.cache[name].splice(index, 1); if (!this.cache[name]?.length) delete this.cache[name] } callback.call(this, ...rest) }) } // 取消订阅 off(name, callback) { if (!name) { this.cache = {}; return; } if (!callback) { delete this.cache[name]; return } if (!this.cache[name]) { return } const i = this.cache[name].findIndex((f) =&gt; f.callback === callback) this.cache[name].splice(i, 1); if (!this.cache[name].length) delete this.cache[name] } }","tags":[{"name":"EventEmitter","slug":"EventEmitter","permalink":"https://github.com/NollieLeo/tags/EventEmitter/"},{"name":"发布订阅","slug":"发布订阅","permalink":"https://github.com/NollieLeo/tags/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/"}]},{"title":"手写curry","date":"2021-12-13T03:02:58.000Z","path":"2021/12/13/手写curry/","text":"要求实现如下 const add = (a, b, c) =&gt; a + b + c; const a1 = currying(add, 1); const a2 = a1(2); console.log(a2(3)) // 6 // curry pro function curryPro(fn, ...outerProps) { function curried(...middleProps) { const concatArr = [...middleProps]; if (concatArr.length &gt;= fn.length) { return fn.call(this, ...concatArr) } return function (...innerProps) { return curried.call(this, ...concatArr.concat(innerProps)) } } if(outerProps.length){ return curried(...outerProps); } return curried }","tags":[{"name":"curry","slug":"curry","permalink":"https://github.com/NollieLeo/tags/curry/"}]},{"title":"手写compose","date":"2021-12-13T02:40:26.000Z","path":"2021/12/13/手写compose/","text":"compose简介compose就是执行一系列的任务（函数），比如有以下任务队列 let tasks = [step1, step2, step3, step4] 每一个step都是一个步骤，按照步骤一步一步的执行到结尾，这就是一个compose compose在函数式编程中是一个很重要的工具函数，在这里实现的compose有三点说明 第一个函数是多元的（接受多个参数），后面的函数都是单元的（接受一个参数） 执行顺序的自右向左的 所有函数的执行都是同步的 还是用一个例子来说，比如有以下几个函数 let init = (...args) =&gt; args.reduce((ele1, ele2) =&gt; ele1 + ele2, 0) let step2 = (val) =&gt; val + 2 let step3 = (val) =&gt; val + 3 let step4 = (val) =&gt; val + 4 这几个函数组成一个任务队列 steps = [step4, step3, step2, init] 使用compose组合这个队列并执行 let composeFunc = compose(...steps) console.log(composeFunc(1, 2, 3)) 执行过程 6 -&gt; 6 + 2 = 8 -&gt; 8 + 3 = 11 -&gt; 11 + 4 = 15所以流程就是从init自右到左依次执行，下一个任务的参数是上一个任务的返回结果，并且任务都是同步的，这样就能保证任务可以按照有序的方向和有序的时间执行。 手写// compose function compose(...args) { const fnArr = Array.from(args); let result; return function composer(...rest) { const current = fnArr.shift(); result = current.call(this, ...rest); if (!fnArr.length) { return result } return composer(result) } }","tags":[{"name":"compose","slug":"compose","permalink":"https://github.com/NollieLeo/tags/compose/"}]},{"title":"深拷贝最新优化代码","date":"2021-12-12T07:46:41.000Z","path":"2021/12/12/深拷贝最新优化代码/","text":"const map = new WeakMap() const handleArrAndObject = (varias) =&gt; { const constructor = Object.getPrototypeOf(varias).constructor; const object = new constructor(); for (const key in varias) { if (Object.hasOwnProperty.call(varias, key)) { const element = varias[key]; object[key] = deepClone(element) } } return object; } const handleMap = (varias) =&gt; { const constructor = Object.getPrototypeOf(varias).constructor; const currentMap = new constructor(); varias.forEach((value, key) =&gt; { currentMap.set(deepClone(key), deepClone(value)) }) return currentMap } const handleSet = (varias) =&gt; { const constructor = Object.getPrototypeOf(varias).constructor; const currentSet = new constructor(); varias.forEach((value) =&gt; { currentSet.set(deepClone(value)) }) return currentSet } const handleRegx = (varias) =&gt; { const constructor = Object.getPrototypeOf(varias).constructor; const { flags, source } = varias; const currentRegx = new constructor(source, flags); return currentRegx; } const handleOthers = (varias) =&gt; { const constructor = Object.getPrototypeOf(varias).constructor; return new constructor(Object.prototype.valueOf.call(varias)); } const handleFn = (vaira) =&gt; { return vaira; } const cloneMap = { &#39;[object Array]&#39;: handleArrAndObject, &#39;[object Object]&#39;: handleArrAndObject, &#39;[object Map]&#39;: handleMap, &#39;[object WeakMap]&#39;: handleMap, &#39;[object Set]&#39;: handleSet, &#39;[object WeakSet]&#39;: handleSet, &#39;[object RegExp]&#39;: handleRegx, &#39;[object Function]&#39;: handleFn, } const getStringType = (varias) =&gt; { return Object.prototype.toString.call(varias); } const getCloneVarias = (varias) =&gt; { let fn = handleOthers; const stringType = getStringType(varias); if (cloneMap.hasOwnProperty(stringType)) { fn = cloneMap[stringType] } return fn?.(varias); } const isObject = (target) =&gt; { return typeof target === &quot;object&quot; &amp;&amp; target !== null; } function deepClone(obj) { if (!isObject(obj)) { return obj; } if (map.get(obj)) { return obj } map.set(obj, true) return getCloneVarias(obj) } const obj = { arr: [1212, 121], name: &#39;weng&#39;, name2: new String(&#39;weng&#39;), map: new Map(), set: new Set(), date: Date.now(), regexp: new RegExp(), string: new String(), sayHi: () =&gt; { }, sayMyName: function () { } } obj.target = obj; const obj3 = deepClone(obj); obj3.arr[1] = &#39;wahahahah&#39;; console.log(obj, obj3)","tags":[{"name":"深拷贝","slug":"深拷贝","permalink":"https://github.com/NollieLeo/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"}]},{"title":"自定义loader记录","date":"2021-10-10T08:01:49.000Z","path":"2021/10/10/自定义loader记录/","text":"调试loader1. 准备好自己的webpack和loader这里我用的项目是我自己的 webpack template 2. vscode配置debug配置文件按照这个步骤配置完会生成一个.vscode文件夹下面有个launch.json文件 然后替换它 { &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Webpack Debug&quot;, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;runtimeExecutable&quot;: &quot;npm&quot;, &quot;runtimeArgs&quot;: [ &quot;run&quot;, &quot;debug&quot; ], &quot;port&quot;: 5858 } ] } 利用以上配置信息，我们创建了一个 Webpack Debug 的调试任务。当运行该任务的时候，会在当前工作目录下执行 npm run debug 命令。因此，接下来我们需要在 package.json 文件中增加 debug 命令，具体内容如下所示： { &quot;scripts&quot;: { &quot;debug&quot;: &quot;webpack --config build/webpack.dev.js&quot; } } 3. 把自定义loader写道自己的rule里头 image-20211010161220568 然后打断点 image-20211010161333822 4.启动调试 image-20211010161437329","tags":[{"name":"webpack","slug":"webpack","permalink":"https://github.com/NollieLeo/tags/webpack/"},{"name":"loader","slug":"loader","permalink":"https://github.com/NollieLeo/tags/loader/"}]},{"title":"自定义脚手架搭建记录","date":"2021-09-05T02:41:37.000Z","path":"2021/09/05/自定义脚手架搭建记录/","text":"首先先知道有哪些工具可以用 名称 简介 commander 命令行自定义指令 inquirer 命令行询问用户问题，记录回答结果 chalk 控制台输出内容样式美化 ora 控制台 loading 样式 figlet 控制台打印 logo easy-table 控制台输出表格 download-git-repo 下载远程模版 fs-extra 系统fs模块的扩展，提供了更多便利的 API，并继承了fs模块的 API cross-spawn 支持跨平台调用系统上的命令 plop 轻量级快速构建模板 参考文章前端黑科技篇章之plop，让你也拥有自己的脚手架 从 0 构建自己的脚手架/CLI知识体系","tags":[{"name":"commander","slug":"commander","permalink":"https://github.com/NollieLeo/tags/commander/"},{"name":"nodejs","slug":"nodejs","permalink":"https://github.com/NollieLeo/tags/nodejs/"},{"name":"plop","slug":"plop","permalink":"https://github.com/NollieLeo/tags/plop/"},{"name":"inquirer","slug":"inquirer","permalink":"https://github.com/NollieLeo/tags/inquirer/"},{"name":"ora","slug":"ora","permalink":"https://github.com/NollieLeo/tags/ora/"},{"name":"figlet","slug":"figlet","permalink":"https://github.com/NollieLeo/tags/figlet/"},{"name":"easy-table","slug":"easy-table","permalink":"https://github.com/NollieLeo/tags/easy-table/"}]},{"title":"前端面试知识整理","date":"2021-08-30T15:30:21.000Z","path":"2021/08/30/前端面试知识整理/","text":"整合版手撕钉钉前端考试卷，offer，拿来吧你~ React「2021」高频前端面试题汇总之React篇（上） 「2021」高频前端面试题汇总之React篇（下） html「2021」高频前端面试题汇总之HTML篇 html篇–这可能是目前较为全面的html面试知识点了吧 JS篇javascript篇–1.6万字带你回忆那些遗忘的JS知识点 「2021」高频前端面试题汇总之JavaScript篇（上） 「2021」高频前端面试题汇总之JavaScript篇（下） JS手写篇 CSS「2021」高频前端面试题汇总之CSS篇 css篇–100道近两万字帮你巩固css知识点 前端响应式布局原理与方案（详细版） 模块化详解模块化 TypeScript一份不可多得的 TS 学习指南（1.8W字） TypeScript 高级用法 手撕ts面试题——不能不掌握的ts高级特性（三） typescript不能不掌握的高级特性（二） webpack「吐血整理」再来一打Webpack面试题 package.json你真的了解package.json吗？来看看吧，这可能是最全的package解析 网络字节跳动最爱考的前端面试题：计算机网络基础 HTTP/HTTPS「查缺补漏」巩固你的HTTP知识体系 TCP(建议收藏)TCP协议灵魂之问，巩固你的网路底层基础 前端跨域九种跨域方式实现原理（完整版） 前端安全前端安全系列（一）：如何防止XSS攻击？ 前端安全系列之二：如何防止CSRF攻击？ 前端面试查漏补缺–(七) XSS攻击与CSRF攻击 浏览器垃圾回收机制「硬核JS」你真的了解垃圾回收机制吗 前端性能优化SEOSEO","tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"React源码学习-render阶段-update递归-part7","date":"2021-08-29T09:08:37.000Z","path":"2021/08/29/React源码学习-render阶段-update递归-part7/","text":"","tags":[{"name":"React","slug":"React","permalink":"https://github.com/NollieLeo/tags/React/"},{"name":"React render","slug":"React-render","permalink":"https://github.com/NollieLeo/tags/React-render/"}]},{"title":"React源码学习-render阶段-mount递归-part6","date":"2021-08-23T13:53:25.000Z","path":"2021/08/23/React源码学习-render阶段-mount递归-part6/","text":"这里说一下 mount时候的beginWork和completeWork的流程吧 mount递归断点调试render阶段的递阶段起点是beginWork，归阶段的起点是completeWork，那我们就在源码上打断点。 image-20210823220759254 image-20210823220834921 应用demo如下 image-20210823223552306 刷新页面正式进入调试。 1.发现第一次进入页面beginWork中，current有值，并且此时的tag是等于3的，之前说的我们在createFiberRoot的那个阶段这个tag也等于三，我们不妨猜测这个tag为3指的是 fiberRootNode image-20210823221225561 找到react-reconciler包下的ReactWorkTag，可以看到tag = 3对应的是叫 HostRoot的tag image-20210823222916683 2.点击下一个断点 我们发现current的值为null（之前说过，只有根节点才存在current值，而其他节点只存在workInProgress） image-20210823223122090 且当前节点的elementType为function App()，也就是写的一个app函数 image-20210823223335090 之后就是div了，然后是div的子节点header 之后又想走header的子节点title（其实这里算不上是子节点，只是个文本节点，react对文本节点进行了优化，无自己的beginWork，react会对只有唯一一个文本子节点的节点，做了优化，这样这个文本节点无自己的fiber节点，也就是不走beginWork） 因为header的文本节点不算，所以直接进入了header节点的completeWork的阶段 image-20210823224738688 之后header 归阶段结束，会去找header的sibling，也就是兄弟节点，兄弟节点进入beginWork（递阶段） 就这样以此往复深度优先遍历 之后走完main，发现main无兄弟了，就开始走main父节点的completeWork阶段也就是div，然后就这样一直走，走到了App的completeWork然后走到了 rootFiber结束 这时候一个render阶段就结束了 beginWork做了啥？这里我们以 走到第二步的div节点举例子 image-20210823233545095 1. 依照tag判断component类型首先根据当前的workInProgress的tag进入不同的Component处理逻辑 这里的div节点，tag为5，进入的是 HostComponent的处理逻辑 image-20210823234419849 2. updateHostComponents$1首先会对一些参数做赋值操作，之后用isDirectTextChild字段判断当前节点是否只有一个文本节点（上面提到了），如果是，则不会去创建这个文本节点的fiber，算是react的一个优化手段 image-20210823235701602 3. reconcileChildren从名字可以看出这个玩意应该是reconciler调试器的比较重要的函数。这个函数就是用来创建当前节点的子节点的 对于mount的组件，他会创建新的子Fiber节点 对于update的组件，他会将当前组件与该组件在上次更新时对应的Fiber节点比较（也就是俗称的Diff算法），将比较的结果生成新Fiber节点 image-20210824000029762 如果当前不存在current就走mountChildFibers，否者就走reconcileChildFibers 也就是说存在current的时候是整个应用的根节点了 我们找到ReactChildFiber这个文件 找到reconcileChildFibers和 mountChildFibers image-20210826215700516 从代码可以看出，和beginWork一样，他也是通过current === null ?区分mount与update。 发现这两个走的都是同一个函数，只是参数不一样 4. 打上不一样的effectTag或者直接return上面的 childReconciler的参数 代表的是否追踪副作用 例如下面的这个deleteChild函数是表示删除当前节点的子节点的操作 function deleteChild(returnFiber: Fiber, childToDelete: Fiber): void { if (!shouldTrackSideEffects) { // Noop. return; } const deletions = returnFiber.deletions; if (deletions === null) { returnFiber.deletions = [childToDelete]; returnFiber.flags |= ChildDeletion; } else { deletions.push(childToDelete); } } 如果说需要追踪副作用的话，会给删除节点的fiber打上一个flags 搜索reactFiberFlags文件看这些Flags都有些啥 众所周知，render阶段不会操作dom的，commit阶段才会，所以render阶段这个flags的操作只是为了为fiber打上tag告诉后续这个节点要进行什么操作 为什么是二进制掩码格式的flags呢？这里有一种情况 举个例子： 当一个fiber节点需要插入并且需要更新属性的话 那就得绑定2个flags，一个是 Update一个是 Placement 这里用二进制的话就可以直接进行按位 或的操作 const effectTag = NoEffect; effectTag |= Update; effectTag |= Placement; (effectTag &amp; PlacementAndUpdate) !== NoEffect; // true 无论如何最终，都会走到reconcileChildFibers这个方法里头，而这个方法是写在 ChildReconciler函数的，总而言之就是加了一层去判断是否要追踪副作用。 5. reconcileChildFibers地址 这个方法中会判断当前child的类型，进而对不同的类型做不一样的操作 主要分为两个大类 type === ‘object’ type === ‘string’ 当然最需要细分的就是为object的情况，里头还包括了child是children等情形 我们走到object里头细看一下，假设我们现在走到了一个节点是这样的 &lt;header&gt; &lt;span&gt;title&lt;/span&gt; &lt;/header&gt; 那他就会去调用 reconcileSingleElement的方法 image-20210829105504513 最终这个方法会走到createFiberFromElement 也就是通过reactElement的数据创建一个fiber节点 image-20210829110028352 并且这个方法内部会调用一个方法叫做``createFiberFromTypeAndProps` image-20210829110240512 在这个方法的内部会根据当前的component type去走不同的逻辑 image-20210829110319749 这里呢直接将fibertag 赋值为了HostComponent 接下来去创建对应的fiber节点，调用createFiber，也就是 new了一个 FiberNode，这里头的属性在Fiber那篇讲了一下。 image-20210829110436790 总结最终他会生成新的子Fiber节点并赋值给workInProgress.child，作为本次beginWork返回值 ，并作为下次performUnitOfWork执行时workInProgress的传参。 要注意的点是，当你调用reconcileChildFibers时候子节点可能是一个数组，这种情况react仍然是只针对数组的第一个元素创建fiber ​ completeWork做了啥？1. 根据fiber节点的tag进入不同的case这里首先进入completeWork阶段的时候span标签 function App() { return ( &lt;div className=&quot;node1&quot;&gt; &lt;header&gt; &lt;span&gt;title&lt;/span&gt; &lt;/header&gt; &lt;main&gt; main &lt;p&gt;test&lt;/p&gt; &lt;/main&gt; &lt;/div&gt; ); } 这里是span 标签所以先进入 HostComponent的case逻辑 image-20210829152900269 事先判断current是否是空，首次渲染非fiberRoot不存current 接下来比较重要的是创建一个dom叫做createInstance image-20210829153657555 2. createInstance image-20210829160429387 createInstance会去 通过 createElement创建一个dom元素 这里domElement就是一个span 之后返回一个instance去执行appendAllChidren函数，由于span是我们第一个创建的元素，所以append会被跳过 image-20210829161632571 3. 保存创建出来的dom到fiber节点的stateNode中workInProgress.stateNode = instance; 4. 将属性绑定到创建出来的dom元素上执行finalizerInitialChildren, 将所有的属性绑到我们新创建的dom元素上面，到这里一个节点span的completework就大致完成了 image-20210829161958750 image-20210829162021263 ⭐appendAllChildren逻辑appendAllChildren的原理是，主要是将已经创建好的fiber节点挂载到当前的节点下。 这也就是为什么之前上面的span的标签第一次创建的时候不走这个的逻辑的原因 走到了APP时候，就构建了一颗完整的fiber树了","tags":[{"name":"React","slug":"React","permalink":"https://github.com/NollieLeo/tags/React/"},{"name":"React render","slug":"React-render","permalink":"https://github.com/NollieLeo/tags/React-render/"}]},{"title":"React源码学习-render阶段-part5","date":"2021-08-22T09:44:31.000Z","path":"2021/08/22/React源码学习-render阶段简介-part5/","text":"之前fiber那边说过，当我们第一次创建完了整个应用的根节点（fiberRootNode的时候，我们就进入首屏渲染的阶段） 通过sheduleUpdateOnFiber去调度更新，调度成功之后会走performSyncWorkOnRoot，也就是说从根节点开始执行这次的更新。 这时候也肯定是没有一个workInProgress的fiber tree的，所以从根节点出发，去触发更新（第一次构建tree）操作 image-20210822213436338 协调器工作主要是入口是 workSyncLoop，递阶段开始于某个fiber其beginWork，归阶段则是调用completeWork 这里我们说一下协调器的工作，渲染器后面讲（渲染器这里我们只要知道它是将变化的节点渲染到视图上，所以分为渲染到视图-之前-中-之后） image-20210822215752746 因此协调器工作开始到结束，我们称呼为 render阶段， 渲染器开始到结束，称呼为commit阶段 整个流程就是首屏渲染了 render阶段流程概览首先我们先看调用栈里头render阶段是从哪里开始的呢？ image-20210822181130206 render阶段开始于performSyncWorkOnRoot或performConcurrentWorkOnRoot方法的调用。这取决于本次更新是同步更新还是异步更新。 之后调用workSyncLoop或者workLoopConcurrent // performSyncWorkOnRoot会调用该方法 function workLoopSync() { while (workInProgress !== null) { performUnitOfWork(workInProgress); } } // performConcurrentWorkOnRoot会调用该方法 function workLoopConcurrent() { while (workInProgress !== null &amp;&amp; !shouldYield()) { performUnitOfWork(workInProgress); } } 上面所说的workInProgress tree构建的过程从这里正式开始 代码中的workInProgress 代表的是当前已经创建的workInProgress Fiber performUnitOfWork方法会创建下一个Fiber节点并赋值给workInProgress，并将workInProgress与已创建的Fiber节点连接起来构成Fiber树。 我们知道Fiber Reconciler是从Stack Reconciler重构而来，通过遍历的方式实现可中断的递归 所以具体我们看看performUnitOfWork的工作可以分为两部分：“递”和“归”。 ”递“阶段 首先从rootFiber开始向下深度优先遍历。为遍历到的每个Fiber节点调用beginWork方法 该方法会根据传入的Fiber节点创建子Fiber节点，并将这两个Fiber节点连接起来。 当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。 “归”阶段在“归”阶段会调用completeWork处理Fiber节点。 当某个Fiber节点执行完completeWork，如果其存在兄弟Fiber节点（即fiber.sibling !== null），会进入其兄弟Fiber的“递”阶段。 如果不存在兄弟Fiber，会进入父级Fiber的“归”阶段。 “递”和“归”阶段会交错执行直到“归”到rootFiber。至此，render阶段的工作就结束了。 总结总体来说递归阶段是下面这段伪代码描述的一样 function performUnitOfWork(fiber) { // 执行beginWork if (fiber.child) { performUnitOfWork(fiber.child); } // 执行completeWork if (fiber.sibling) { performUnitOfWork(fiber.sibling); } } 根据Fiber的那一讲解咱们可以知道，我们的react中可以最多存在两棵fiber树，一个是workInProgress一个是current，咱们在首次mount的时候是，是没有current的，只是在内存中通过整个应用的根fiberRootNode去构建workinprogess tree 之后update的时候是存在current的tree的 所以这两个阶段的“递”和“归”流程是各不一样的 因此我们接下来按照 mount 和update触发去解释“递归”","tags":[{"name":"React","slug":"React","permalink":"https://github.com/NollieLeo/tags/React/"},{"name":"React render","slug":"React-render","permalink":"https://github.com/NollieLeo/tags/React-render/"}]},{"title":"React源码学习-jsx的理解-part4","date":"2021-08-21T14:26:48.000Z","path":"2021/08/21/React源码学习-jsx的理解-part4/","text":"jsx理解 JSX和Fiber节点不是同一个东西 。 React Component 和 React Element 也不是一个东西。 从编译来看JSX在babel中会被编译成React.createElement（这也就是为什么需要手动import React from &#39;react&#39;的原因了） 但是在17之后不需要手动引入了 看这篇 如下图： image-20210822155213907 JSX并不是只能被编译为React.createElement方法，你可以通过@babel/plugin-transform-react-jsx (opens new window)插件显式告诉Babel编译时需要将JSX编译为什么函数的调用（默认为React.createElement）。 比如在preact (opens new window)这个类React库中，JSX会被编译为一个名为h的函数调用。 React.createElementReact.createElement地址 createElement(type, config, children) type: react component类型 config：react component 的一些属性 children：它的子孙react component 执行步骤 进来createElement我们会发现它定义了一些字段，这些字段都是我们比较常用的 之后我们对传进来的config进行校验，我们会发现他做了几个合法性的校验，并且对相对应的变量进行赋值 hasValidRef：对config中的ref做合法性校验 hasValidKey：对config中的key做合法性校验 遍历config中的属性，将除了保留属性之外的其他属性赋值给Props（就是内部的一个中间对象） 保留属性有哪些呢？ 可以看到react把，ref，key都提出来了，单独的作为 ReactElement函数的参数传递（这个下面说） 接下来处理type中的defaultProps，这里也能明白，因为我们经常需要给class的组件的一些参数设置默认的属性值 接下来我们走入ReactElement函数 可以发现，它最终返回了一个Element对象 const ReactElement = function(type, key, ref, self, source, owner, props) { ...... const element = { // 标记这是个 React Element $$typeof: REACT_ELEMENT_TYPE, // 这个是react component的类型 type: type, key: key, ref: ref, props: props, _owner: owner, }; return element; }; 这里要注意，其中` $$typeof`这个参数很重要，主要是用来[isValidElement](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react/src/ReactElement.js#L547)函数来判断这个element是不是合法的react element ```js export function isValidElement(object) { return ( typeof object === &#39;object&#39; &amp;&amp; object !== null &amp;&amp; object.$$typeof === REACT_ELEMENT_TYPE ); } 可以看到，$$typeof === REACT_ELEMENT_TYPE的非null对象就是一个合法的React Element。换言之，在React中，所有JSX在运行时的返回结果（即React.createElement()的返回值）都是React Element。 React Component在React中，我们常使用ClassComponent与FunctionComponent构建组件。 class AppClass extends React.Component { render() { return &lt;p&gt;111&lt;/p&gt; } } console.log(&#39;这是ClassComponent：&#39;, AppClass); console.log(&#39;这是Element：&#39;, &lt;AppClass/&gt;); function AppFunc() { return &lt;p&gt;222&lt;/p&gt;; } console.log(&#39;这是FunctionComponent：&#39;, AppFunc); console.log(&#39;这是Element：&#39;, &lt;AppFunc/&gt;); 我们可以从Demo控制台打印的对象看出，ClassComponent对应的Element的type字段为AppClass自身。 FunctionComponent对应的Element的type字段为AppFunc自身，如下所示： { $$typeof: Symbol(react.element), key: null, props: {}, ref: null, type: ƒ AppFunc(), _owner: null, _store: {validated: false}, _self: null, _source: null } JSX与Fiber节点从上面的内容我们可以发现，JSX是一种描述当前组件内容的数据结构，他不包含组件schedule、reconcile、render所需的相关信息。 比如如下信息就不包括在JSX中： 组件在更新中的优先级 组件的state 组件被打上的用于Renderer的标记 这些内容都包含在Fiber节点中。 所以，在组件mount时，Reconciler根据JSX描述的组件内容生成组件对应的Fiber节点。 在update时，Reconciler将JSX与Fiber节点保存的数据对比，生成组件对应的Fiber节点，并根据对比结果为Fiber节点打上标记。","tags":[{"name":"React","slug":"React","permalink":"https://github.com/NollieLeo/tags/React/"},{"name":"jsx","slug":"jsx","permalink":"https://github.com/NollieLeo/tags/jsx/"}]},{"title":"React源码学习-fiber原理-part3","date":"2021-08-21T09:17:17.000Z","path":"2021/08/21/React源码学习-fiber原理-part3/","text":"Fiber架构官方回答什么是fiber Fiber并不是计算机术语中的新名词，他的中文翻译叫做纤程，与进程（Process）、线程（Thread）、协程（Coroutine）同为程序执行过程。 在很多文章中将纤程理解为协程的一种实现。在JS中，协程的实现便是Generator。 所以，我们可以将纤程(Fiber)、协程(Generator)理解为代数效应思想在JS中的体现。 React Fiber可以理解为： React内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。 其中每个任务更新单元为React Element对应的Fiber节点。 Fiber架构心智模型 React核心团队成员Sebastian Markbåge (opens new window)（React Hooks的发明者）曾说：我们在React中做的就是践行代数效应（Algebraic Effects）。 代数效应这篇文章可以好好看看 代数效应能够将副作用从函数逻辑中分离，使函数关注点保持纯粹。 就比如我们平时用await来等待一个值的返回 async function getData(){ const res = await loadData(); return res; } 代数效应相当于，我关注的是 await loadData()能给我什么东西，而不是关注他里头是异步还是同步，怎么处理这个数据的； 代数效应 in React在react中有个结合Suspense的例子 Suspense Demo 而我们日常用hooks，例如useState什么的，我们不需要关注函数组件的这个state状态是怎么处理的，我们只要知道这个东西能干嘛就行。 为什么不用Generator新老架构那片说过，React16之后引入了一个 scheduler（调度器），并且重构了Reconciler（协调器），就是为了将react的老一套同步更新 的架构变成 *异步可中断 *的 异步可中断更新可以理解为：更新在执行过程中可能会被打断（浏览器时间分片用尽或有更高优任务插队），当可以继续执行时恢复之前执行的中间状态。 缺点： generator它具有传染性和async await一样，就像你用async的函数那东西，你需要写await一样 中间状态上下文相关，可以看看这个 解释 Fiber实现原理Fiber含义首先我们要明白： react15的时候采用递归方式去执行，数据保存在递归调用栈中，故被称为stack reconciler react16 的reconciler 基于 fiber节点实现的，故称为 fiber reconciler 一个 React Element 对应一个Fiber节点 作为静态结构理解 — 保存了该组件类型（原生/类组件/函数组件/…），以及对应dom节点信息 作为动态结构理解 — 每个Fiber保存了本次更新中该组件改变的状态，要执行的工作（插入/删除/更新…） Fiber数据结构Fiber数据结构 function FiberNode( tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode, ) { // 作为静态数据结构的属性 this.tag = tag; this.key = key; this.elementType = null; this.type = null; this.stateNode = null; // 用于连接其他Fiber节点形成Fiber树 this.return = null; this.child = null; this.sibling = null; this.index = 0; this.ref = null; this.pendingProps = pendingProps; this.memoizedProps = null; this.updateQueue = null; this.memoizedState = null; this.dependencies = null; this.mode = mode; // 作为动态的工作单元的属性 this.effectTag = NoEffect; this.subtreeTag = NoSubtreeEffect; this.deletions = null; this.nextEffect = null; this.firstEffect = null; this.lastEffect = null; // 调度优先级相关 this.lanes = NoLanes; this.childLanes = NoLanes; // 指向该fiber在另一次更新时对应的fiber， current tree中的fiber节点和workinprogress tree的fiber节点连接 this.alternate = null; } Fiber节点之间关系Fiber节点之间是通过以下三个属性建立起连接的 // 指向父级Fiber节点 this.return = null; // 指向子Fiber节点 this.child = null; // 指向右边第一个兄弟Fiber节点 this.sibling = null; 比如下面的代码和对应的Fiber树如下： function App(){ return ( &lt;div&gt; &lt;span&gt;hello world&lt;/span&gt; &lt;a&gt; weng &lt;span/&gt; &lt;/a&gt; &lt;/div&gt; ) } image-20210821213628488 这里需要提一下，为什么父级指针叫做return而不是parent或者father呢？因为作为一个工作单元，return指节点执行完completeWork（后面会说）后会返回的下一个节点。子Fiber节点及其兄弟节点完成工作后会返回其父级节点，所以用return指代父级节点。 作为静态的数据结构作为一种静态的数据结构，保存了组件相关的信息： // Fiber对应组件的类型 Function/Class/Host... this.tag = tag; // key属性 this.key = key; // 大部分情况同type，某些情况不同，比如FunctionComponent使用React.memo包裹 this.elementType = null; // 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName this.type = null; // Fiber对应的真实DOM节点 this.stateNode = null; 作为动态的工作单元作为动态的工作单元，Fiber中如下参数保存了本次更新相关的信息，我们会在后续的更新流程中使用到具体属性时再详细介绍 // 保存本次更新造成的状态改变相关信息 this.pendingProps = pendingProps; this.memoizedProps = null; this.updateQueue = null; this.memoizedState = null; this.dependencies = null; this.mode = mode; // 保存本次更新会造成的DOM操作 this.effectTag = NoEffect; this.nextEffect = null; this.firstEffect = null; this.lastEffect = null; 如下两个字段保存调度优先级相关的信息，会在学习Scheduler时说 // 调度优先级相关 this.lanes = NoLanes; this.childLanes = NoLanes; Fiber工作原理首先，上面说了，Fiber节点直接会构成一棵Fiber树，并且存有节点以及各种信息每个Fiber。 所以一个Fiber是根据一个dom或者说React Element的出来的，那么树的结构也和dom或者组件树相同。 主要 更新 工作原理，这里用到了一个叫做 双缓存的技术 what is 双缓存？当我们用canvas绘制动画，每一帧绘制前都会调用ctx.clearRect清除上一帧的画面。 如果当前帧画面计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。 为了解决这个问题，我们可以在内存中绘制当前帧动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。 这种在内存中构建并直接替换的技术叫做双缓存 。 React使用“双缓存”来完成Fiber树的构建与替换——对应着DOM树的创建与更新。 Fiber树和双缓存 React中最多会同时存在两棵Fiber树 Current Fiber 树：当前显示在屏幕面前的树 workInProgress Fiber 树：正在内存中构建的树 current Fiber树中的Fiber节点被称为current fiber，workInProgress Fiber树中的Fiber节点被称为workInProgress fiber，他们通过alternate属性连接。 currentFiber.alternate === workInProgressFiber; workInProgressFiber.alternate === currentFiber; React应用的根节点通过使current指针在不同Fiber树的rootFiber间切换来完成current Fiber树指向的切换。 即当workInProgress Fiber树构建完成交给Renderer渲染在页面上后，应用根节点的current指针指向workInProgress Fiber树，此时workInProgress Fiber树就变为current Fiber树。 每次状态更新都会产生新的workInProgress Fiber树，通过current与workInProgress的替换，完成DOM更新。 mount时候考虑如下例子： function App() { const [num, add] = useState(0); return ( &lt;p onClick={() =&gt; add(num + 1)}&gt;{num}&lt;/p&gt; ) } ReactDOM.render(&lt;App/&gt;, document.getElementById(&#39;root&#39;)); 首次执行ReactDOM.render会创建fiberRootNode（源码中叫fiberRoot）和rootFiber。其中fiberRootNode是整个应用的根节点，rootFiber是``所在组件树的根节点。 之所以要区分fiberRootNode与rootFiber，是因为在应用中我们可以多次调用ReactDOM.render渲染不同的组件树，他们会拥有不同的rootFiber。但是整个应用的根节点只有一个，那就是fiberRootNode。 fiberRootNode的current会指向当前页面上已渲染内容对应Fiber树，即current Fiber树。 rootFiber 由于是首屏渲染，页面中还没有挂载任何DOM，所以fiberRootNode.current指向的rootFiber没有任何子Fiber节点（即current Fiber树为空）。 接下来进入render阶段，根据组件返回的JSX在内存中依次创建Fiber节点并连接在一起构建Fiber树，被称为workInProgress Fiber树。（下图中右侧为内存中构建的树，左侧为页面显示的树） 在构建workInProgress Fiber树时会尝试复用current Fiber树中已有的Fiber节点内的属性，在首屏渲染时只有rootFiber存在对应的current fiber（即rootFiber.alternate）。 workInProgressFiber workInProgressFiberFinish update时 接下来我们点击p节点触发状态改变，这会开启一次新的render阶段并构建一棵新的workInProgress Fiber 树。 wipTreeUpdate 这个决定是否复用的过程就是Diff算法，后面会说 workInProgress Fiber 树在render阶段完成构建后进入commit阶段渲染到页面上。渲染完毕后，workInProgress Fiber 树变为current Fiber 树。 currentTreeUpdate 查看源码中的FiberRootNode上面曾说到，我们首次创建react的应用的时候会创建整个应用的一个根节点 叫做 FiberRootNode 然后每次调用render方法都会创建当前组件的一个根节点叫做 rootFiber 这里我们验证以下这个 FiberRootNode image-20210821223750870 图中圈出的部分就是react应用首次运行时候，创建一个应用根节点FiberRootNode的过程 我们顺着调用栈找到这个创建的调用方法 creatFiberRoot — createFiber（创建应用根的方法） image-20210821224000472 找到源码，打个断点 image-20210822153431608 刷新页面之后 image-20210822153527527 发现首次渲染，创建fiberRoot节点，这个tag为3，那么代表什么意思呢？ 我们可以在它右边的调用栈中找到上层函数createHostRootFiber image-20210822153638347 其实发现这个tag，也就是这里的HostRoot值为3","tags":[{"name":"React","slug":"React","permalink":"https://github.com/NollieLeo/tags/React/"},{"name":"React fiber","slug":"React-fiber","permalink":"https://github.com/NollieLeo/tags/React-fiber/"}]},{"title":"React源码学习","date":"2021-08-16T05:52:58.000Z","path":"2021/08/16/React源码学习-入口-part1/","text":"官方： React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式 卡颂react深度解析 首先学习一个框架的源码或者库的源码，我们都要从他们的入口函数出手。而react这个js库就是从ReactDOM.render入手的 前言：React的快速响应是什么意思呢？ 遇到大量计算不会让页面掉帧或者导致卡顿（这里要想到每秒60帧（HZ），每帧16.6ms） 也就是说在一帧里头做了太多的计算工作了，这里具体要去看看浏览器渲染进程里头的js线程和GUI线程怎么做操作的，目前有一个兼容性不是很好的调度api叫做requestIdelCallback是用来申请浏览器调度的，但是react除了这个因为其他种种原因肯定不能用这个，所以在16之后自己实现了调度方案，也就是下面要说的scheduler 网络请求数据返回后才能进行操作，因此不能快速响应（这里涉及到用户体验上面，意思就是想要让用户把这种异步的请求，自我感知成同步的，也就是说我根本没反应过来，你这个居然就可以用了的意思） 两类对应着 CPU的瓶颈 IO的瓶颈 所以我们引出： react是如何从这两个方面进行优化的呢？ CPU瓶颈加入我们一个页面中需要一次性渲染30k个dom元素 function App() { const len = 3000; return ( &lt;ul&gt; {Array(len).fill(0).map((_, i) =&gt; &lt;li&gt;{i}&lt;/li&gt;)} &lt;/ul&gt; ); } const rootEl = document.querySelector(&quot;#root&quot;); ReactDOM.render(&lt;App/&gt;, rootEl); 而大部分目前设备浏览器刷新比率都是60HZ（每秒60帧），16.6ms刷新一帧 而， JS可以操作DOM，GUI渲染线程与JS线程是互斥的， JS脚本执行和浏览器布局、绘制不能同时执行。 在每16.6ms时间内，需要完成如下工作： JS脚本执行 ----- 样式布局 ----- 样式绘制当JS执行时间过长，超出了16.6ms，这次刷新就没有时间执行样式布局和样式绘制了。 在Demo中，由于组件数量繁多（3000个），JS脚本执行时间过长，页面掉帧，造成卡顿。 可以从打印的执行堆栈图看到，JS执行时间为73.65ms，远远多于一帧的时间 如何解决这个问题呢？ 答案是：在浏览器每一帧的时间中，预留一些时间给JS线程，React利用这部分时间更新组件（可以看到，在源码 (opens new window)中，预留的初始时间是5ms）。 当预留的时间不够用时，React将线程控制权交还给浏览器使其有时间渲染UI，React则等待下一帧时间到来继续被中断的工作。 这种将长任务分拆到每一帧中，像蚂蚁搬家一样一次执行一小段任务的操作，被称为时间切片（time slice） 接下来我们开启Concurrent Mode // 通过使用ReactDOM.unstable_createRoot开启Concurrent Mode // ReactDOM.render(&lt;App/&gt;, rootEl); ReactDOM.unstable_createRoot(rootEl).render(&lt;App/&gt;); 此时我们的长任务被拆分到每一帧不同的task中，JS脚本执行时间大体在5ms左右，这样浏览器就有剩余时间执行样式布局和样式绘制，减少掉帧的可能性。 所以，解决CPU瓶颈的关键是实现时间切片，而时间切片的关键是：将同步的更新变为可中断的异步更新。 IO瓶颈网络延迟是前端开发者无法解决的。如何在网络延迟客观存在的情况下，减少用户对网络延迟的感知？ React给出的答案是将人机交互研究的结果整合到真实的 UI 中 (opens new window)。 这里我们以业界人机交互最顶尖的苹果举例，在IOS系统中： 点击“设置”面板中的“通用”，进入“通用”界面： 作为对比，再点击“设置”面板中的“Siri与搜索”，进入“Siri与搜索”界面： 事实上，点击“通用”后的交互是同步的，直接显示后续界面。而点击“Siri与搜索”后的交互是异步的，需要等待请求返回后再显示后续界面。但从用户感知来看，这两者的区别微乎其微。 这里的窍门在于：点击“Siri与搜索”后，先在当前页面停留了一小段时间，这一小段时间被用来请求数据。 当“这一小段时间”足够短时，用户是无感知的。如果请求时间超过一个范围，再显示loading的效果。 试想如果我们一点击“Siri与搜索”就显示loading效果，即使数据请求时间很短，loading效果一闪而过。用户也是可以感知到的。 为此，React实现了Suspense (opens new window)功能及配套的hook——useDeferredValue (opens new window)。 而在源码内部，为了支持这些特性，同样需要将同步的更新变为可中断的异步更新。 总结通过以上内容，我们可以看到，React为了践行“构建快速响应的大型 Web 应用程序”理念做出的努力。 其中的关键是解决CPU的瓶颈与IO的瓶颈。而落实到实现上，则需要将同步的更新变为可中断的异步更新。 新老React架构对比（15 vs 16++） 为什么react16要对15进行内部重构呢？ Fiber架构官方回答什么是fiber","tags":[{"name":"React","slug":"React","permalink":"https://github.com/NollieLeo/tags/React/"}]},{"title":"团队规范以及解决方法","date":"2021-08-12T14:35:15.000Z","path":"2021/08/12/团队规范常用包/","text":"我们在平时日常开发的时候, 肯定是要制定一套项目规范，去进行团队的开发代码管理的，因此需要涉及到很多方面；比如eslint代码规则检查，husky这种为npm script提供git的钩子的，lint-staged结合husky，然后使用commitlint去规范提交代码消息等等 代码检查huskyts-linteslintlint-stagedcommitlinthttps://github.com/conventional-changelog/commitlint https://commitlint.js.org/#/reference-rules?id=references-empty","tags":[{"name":"webpack","slug":"webpack","permalink":"https://github.com/NollieLeo/tags/webpack/"}]},{"title":"bug记录以及解决方案","date":"2021-08-12T01:45:16.000Z","path":"2021/08/12/bug记录以及解决方案/","text":"Electron chrome devtools Error message “DevTools failed to load SourceMap: Could not load content for chrome-extension://…” PostCss Error: PostCSS plugin autoprefixer requires PostCSS 8. Update PostCSS or downgrade this plugin。 https://blog.csdn.net/qq_38385108/article/details/108693404 VScode 解决VSCODE”因为在此系统上禁止运行脚本”报错 https://blog.csdn.net/larpland/article/details/101349586 UMI 解决umi项目引入React无智能提示，报错“React”指 UMD 全局，但当前文件是模块。请考虑改为添加导入。ts(2686)的问题。 eslint Oops! Something went wrong! No files matching the pattern &quot;./src/assets/scripts/**/*.js&quot; were found.解决方法 ‘lodash’ should be listed in the project’s dependencies, not devDependencies.eslintimport/no-extraneous-dependencies 解决方法 webpack5 Webpack 5 - Uncaught ReferenceError: process is not defined huskyhusky &gt; commit-msg hook failed (add –no-verify to bypass) img 解决方法 commitlint.config.js的编码修改为UTF-8","tags":[{"name":"bugs","slug":"bugs","permalink":"https://github.com/NollieLeo/tags/bugs/"}]},{"title":"eslint在vscode中不生效的原因","date":"2021-08-12T01:44:34.000Z","path":"2021/08/12/eslint在vscode中不生效的原因/","text":"检查是否配置以下内容 package.json中是否配置了eslint依赖 工程目录下是否有.eslintrc.js和.eslintignore文件 2.查看vscode是否安装了eslint插件并启用 setting.json里是否有eslint的配置项 vscode状态栏 eslitn是否开启，显示打勾状态 5.备注：vscode状态栏显示禁用或者报错都会导致eslint不生效 解决方法：以上两种情况点击状态栏上eslint分别弹出以下弹窗，点击allow按钮即可","tags":[{"name":"eslint","slug":"eslint","permalink":"https://github.com/NollieLeo/tags/eslint/"}]},{"title":"babel","date":"2021-08-07T02:37:22.000Z","path":"2021/08/07/babel/","text":"@babel/plugin-transform-runtimebabel官方提供的一个插件，作用是减少冗余的代码。 例如： class extend 的语法在转换后会在ES5的代码里头注入_extend辅助函数用于实现继承 这导致每个使用class extend语法的文件都会被注入重复的_extends辅助函数代码 因此这个插件可以将这个注入函数改成require的形式导入语句来减少代码文件大小 需要和babel-runtime结合使用 babel-loaderhttps://www.npmjs.com/package/babel-loader 这个包允许使用 Babel 和 webpack 转译 JavaScript 文件。 @babel/coreBabel 编译器核心。 @babel/preset-envhttps://babel.dev/docs/en/babel-preset-env @babel/preset-env 是一个智能预设，它允许您使用最新的 JavaScript，而无需对目标环境需要哪些语法转换（以及可选的浏览器 polyfill）进行微观管理。 @babel/runtime@babel/runtime 是一个包含 Babel 模块化运行时助手和 regenerator-runtime 版本的库。 @babel/eslint-parserESLint 的默认解析器和核心规则仅支持最新的最终 ECMAScript 标准，不支持 Babel 提供的实验性（如新特性）和非标准（如 Flow 或 TypeScript 类型）语法 @babel/eslint-parser 是一个解析器，它允许 ESLint 在 Babel 转换的源代码上运行。 在.eslintrc.js配置 module.exports = { parser: &quot;@babel/eslint-parser&quot;, }; 有些新东西可能还得用上@babel/eslint-plugin","tags":[{"name":"webpack","slug":"webpack","permalink":"https://github.com/NollieLeo/tags/webpack/"}]},{"title":"常用plugins","date":"2021-08-05T13:40:40.000Z","path":"2021/08/05/常用plugins/","text":"CSScss-minimizer-webpack-plugin压缩css文件，webpack5以上 mini-css-extract-pluginmini-csss-extract-plugin 这个插件将 CSS 提取到单独的文件中。它为每个包含 CSS 的 JS 文件创建一个 CSS 文件。它支持按需加载 CSS 和 SourceMaps。 它建立在新的 webpack v5 功能之上，并且需要 webpack 5 才能工作。 提供了一个loader，通过MiniCsseExtractPlugin.loader配置loader使用 有时候我们会摒弃style-loader的代码去发布线上代码，直接用这个插件的原因是因为 css-separating css抽离成文件可以，让js和css并行加载，提前解析css postcss-preset-envpostcss-preset-env PostCSS Preset Env 允许您将现代 CSS 转换为大多数浏览器可以理解的内容，根据您的目标浏览器或运行时环境确定您需要的 polyfill。 autoprefixerPostCSS 插件，用于解析 CSS 并使用 Can I Use 中的值向 CSS 规则添加供应商前缀。它由 Google 推荐并用于 Twitter 和阿里巴巴。 Autoprefixer 将使用基于当前浏览器流行度和属性支持的数据为您应用前缀 列如：在postcss.config.js中 module.exports = { plugins: [ [ require(&quot;autoprefixer&quot;)({ overrideBrowserslist: [ &quot;last 2 versions&quot;, &quot;Firefox ESR&quot;, &quot;&gt; 1%&quot;, &quot;ie &gt;= 8&quot;, &quot;iOS &gt;= 8&quot;, &quot;Android &gt;= 4&quot;, ], }) ], ], }; 当然在webpack中也需要配置postcss-loader这个loader是执行所有postcss的插件的关键loader htmlHtmlWebpackPluginhttps://www.npmjs.com/package/html-webpack-plugin 这是一个 webpack 插件，它简化了 HTML 文件的创建以服务于你的 webpack 包。这对于在文件名中包含哈希值的 webpack 包特别有用，该哈希值会更改每次编译。 您可以让插件为您生成 HTML 文件，使用 lodash 模板提供您自己的模板或使用您自己的加载器。 jsterser-webpack-plugin使用该插件来压缩js的代码 如果你使用的是 webpack v5 或以上版本，你不需要安装这个插件。webpack v5 自带最新的 terser-webpack-plugin。如果使用 webpack v4，则必须安装 terser-webpack-plugin v4 的版本。 静态资源复制静态资源有些时候有些第三方的 js 插件没有提供 npm 包，只提供了一个 cdn 地址或者一份文件需要自己下载下来。通常我们下载下来之后放在我们的 public/js 目录下面，然后 public/index.html 文件里直接用 script 标签引入。这个时候不管是 npm run dev 开发时，还是 npm run build:pro 构建后，这个 js 文件都是找不到的 copy-webpack-plugin 打包分析相关webpack-bundle-analyzerhttps://www.npmjs.com/package/webpack-bundle-analyzer webpack-bundle-analyzer 是打包分析神器，可以看到每个包的大小，以及是否有包被重复打包。 speed-measure-webpack-pluginhttps://www.npmjs.com/package/speed-measure-webpack-plugin 这个插件帮助我们分析整个打包的总耗时，以及每一个loader 和每一个 plugins 构建所耗费的时间，从而帮助我们快速定位到可以优化 Webpack 的配置。 代码检查代码检测肯定不当当针对于代码的，我们可以在装了如下的几个plugin之后可以基于git为项目接入git hook，这里推荐使用husky来进行提交前的代码检测 husky eslint-webpack-pluginhttps://www.npmjs.com/package/eslint-webpack-plugin 针对于js的代码进行代码检测，使用 eslint 来查找和修复 JavaScript 代码中的问题 当然用这个之前肯定是要装eslint的 通常react的项目需要结合eslint-config-airbnb， eslint-plugin-import, eslint-plugin-react, eslint-plugin-react-hooks, eslint-plugin-jsx-a11y, 当然你可以结合husky为commit之前提供lint指令hooks，然后使用lint-staged提供运行时候的lint stylelinthttps://github.com/stylelint/stylelint/blob/HEAD/docs/user-guide/get-started.md 这玩意基于postCss, 能检查任何PostCss能解析的代码","tags":[{"name":"webpack","slug":"webpack","permalink":"https://github.com/NollieLeo/tags/webpack/"}]},{"title":"常用loader","date":"2021-08-05T12:50:16.000Z","path":"2021/08/05/常用loader/","text":"以下讲的都是针对webpack5版本的 CSScss-loaderscss-loader webpack识别不了css的代码，所以需要一个css-loader去加载css的文件 style-loaderstyle-loader 将css（以字符串形式）注入到js的代码当中（相当于做了存储），不会额外生成一个CSS文件，之后通过网页的js的操作的时候生成dom（style标签）插入到html中，是一个动态的过程 优点将css的代码直接放到js当中，不会生成独立css文件，有缓存作用 缺点js文件变大，网页加载时间变长（可以考虑单独抽离css文件，异步加载） postcss-loaderpostcss-loader 使用 PostCSS 处理 CSS 的加载器。一般需要配合postCSS的一堆plugin去使用，可以自动为css加上前缀去适配不同浏览器规则，使用css-next的语法等等 tsawesome-typescript-loaderts-loader为什么有时候不用ts的loader去编译ts而是直接用babel呢 静态文件file-loader可以将js和css中导入图片的语句替换成正确的地址，同时将文件输出到对应的位置 url-loader可以将文件内容经过编码之后注入js或者css当中 原因也是显而易见的，再http1.x中，浏览器会对每个域名下的TCP链接做限制，如果图片很多再服务端的话，可能会造成一种情况，请求很多，TCP连接很多，图片请求就很慢，所以直接转成base64就能大大减少请求次数 当然这块大文件还是不建议转base64的 webpack 5内置了这些玩意，所以咱们可以直接用webpack5里头的东西了 assests mini-svg-data-urihttps://www.npmjs.com/package/mini-svg-data-uri 该工具将 SVG 转换为最紧凑、可压缩的数据：支持 SVG 的浏览器可以容忍的 URI。结果如下所示（169 字节）： 比起转成base64的会小一些，还有那些直接转成url的 svg-sprite-loaderhttps://www.npmjs.com/package/svg-sprite-loader#why-its-cool svg-sprite-loader 将加载的 svg 图片拼接成 雪碧图，放到页面中，其它地方通过 复用 一般用在菜单的Icon显示以及搭建一些UI的字体库的时候需要用的到 raw-loaderhttps://www.npmjs.com/package/raw-loader 可以将文本文件的内容读取出来注入js或者css中 Source Mapsource-map-loaderhttps://www.npmjs.com/package/source-map-loader 使用这个loader去加载别的包的sourcemap方便自己的调试 代码检查","tags":[{"name":"webpack","slug":"webpack","permalink":"https://github.com/NollieLeo/tags/webpack/"},{"name":"loader","slug":"loader","permalink":"https://github.com/NollieLeo/tags/loader/"}]},{"title":"webpack记录","date":"2021-08-05T12:24:49.000Z","path":"2021/08/05/webpack记录/","text":"前置包webpack-clihttps://github.com/webpack/webpack-cli/issues webpack-dev-server将 webpack 与提供实时重新加载的开发服务器一起使用。这应该仅用于开发。它在底层使用 webpack-dev-middleware，它提供对 webpack 资产的快速内存访问。 source map 配置详情 优化手段output浏览器缓存，就是进入某个网站后，加载的静态资源被浏览器缓存，再次进入该网站后，将直接拉取缓存资源，加快加载速度。 webpack 支持根据资源内容，创建 hash id，当资源内容发生变化时，将会创建新的 hash id。 配置 JS bundle hash，webpack.js 配置方式如下： module.exports = { // 输出 output: { // 仅在生产环境添加 hash filename: ctx.isEnvProduction ? &#39;[name].[contenthash].bundle.js&#39; : &#39;[name].bundle.js&#39;, }, } tree shaking js的shaking看这个 原理 loader优化 使用babel-loader可以开启缓存，在第2次编译时，直接使用缓存，不用重新编译，缓存一般只适用于开发环境 使用include或exclude适当缩小loader的适用范围，让其更快找到要解析的文件，开发和生产环境皆适用 module: { rules: [ { test: /\\.(js|jsx|ts|tsx)$/i, use: [&#39;babel-loader?cacheDirectory&#39;], exclude: /node_modules/, include: /src/, }, ] } 压缩 css 文件使用css-minimizer-webpack-plugin const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;); module.exports = { optimization: { minimizer: [ new CssMinimizerPlugin({ parallel: 4, }), ], } } 输出结果不携带路径信息默认 webpack 会在输出的 bundle 中生成路径信息，将路径信息删除可小幅提升构建速度。 module.exports = { output: { pathinfo: false, }, }; }React的优化 可以使用 react-refresh-webpack-plugin 这个plugin来实现react组件的热更新 优化 resolve 配置1. aliasalias 可以创建 import 或 require 的别名，用来简化模块引入。 2. extensions根据项目中的文件类型，定义 extensions，以覆盖 webpack 默认的 extensions，加快解析速度。 由于 webpack 的解析顺序是从左到右，因此要将使用频率高的文件类型放在左侧，如下我将 tsx 放在最左侧。 webpack.common.js 配置方式如下： module.exports = { resolve: { extensions: [&#39;.tsx&#39;, &#39;.js&#39;], // 因为我的项目只有这两种类型的文件，如果有其他类型，需要添加进去。 } } 3. modulesmodules 表示 webpack 解析模块时需要解析的目录。 指定目录可缩小 webpack 解析范围，加快构建速度。 webpack.common.js 配置方式如下： module.exports = { modules: [ &#39;node_modules&#39;, paths.appSrc, ] } 4. symlinks如果项目不使用 symlinks（例如 npm link 或者 yarn link），可以设置 resolve.symlinks: false，减少解析工作量。 webpack.common.js 配置方式如下： module.exports = { resolve: { symlinks: false, }, }缓存 webpack5之前 利用 cache-loader 将结果缓存中磁盘中；利用 hard-source-webpack-plugin 将结果缓存在 node_modules/.cache 下提升二次打包速度；利用 DllReferencePlugin 将变化不频繁的第三方库提前单独打包成动态链接库，提升真正业务代码的打包速度 然而。。webpack5自带了配置项 开发环境 webpack.dev.js cache: { type: &#39;memory&#39; }, 复制代码 生产环境 webpack.pro.js cache: { type: &#39;filesystem&#39;, buildDependencies: { config: [__filename] } }, 打包时清除上次构建产物打包目录下面可能会存在大量上次打包留下来的产物，时间长了就会有很多无用的代码 webpack5.20之前这里推荐使用CleanWebpackPlugin 之后就可以用output.clean为true清除 js代码压缩webpack5之前我们是需要terser-webpack-plugin这个包的并且需要以下配置 const TerserPlugin = require(&#39;terser-webpack-plugin&#39;) module.exports = { // ...other config optimization: { minimize: !isDev, minimizer: [ new TerserPlugin({ extractComments: false, terserOptions: { compress: { pure_funcs: [&#39;console.log&#39;] } } }) ] } 但是webpack5自带了代码压缩 // webpack.config.js中 module.exports = { optimization: { usedExports: true, //只导出被使用的模块 minimize : true // 启动压缩 } } 当然你如果需要自定义的话也可以安装这个插件，然后自定义配置 const TerserPlugin = require(&#39;terser-webpack-plugin&#39;); module.exports = { optimization: { minimizer: [ new TerserPlugin({ parallel: 4, terserOptions: { parse: { ecma: 8, }, compress: { ecma: 5, warnings: false, comparisons: false, inline: 2, }, mangle: { safari10: true, }, output: { ecma: 5, comments: false, ascii_only: true, }, }, }), ] } } 合并模块 普通打包只是将一个模块最终放到一个单独的立即执行函数中，如果你有很多模块，那么就有很多立即执行函数。concatenateModules 可以要所有的模块都合并到一个函数里面去。 热更新 自动刷新 是指在修改模块内存时，浏览器会自动刷新页面来更新视图内容，是整个页面刷新，速度较慢；刷新页面还会导致临时状态丢失（比如表单内容） 热更新 是在不刷新页面的情况下，使新代码生效，整个网面不会刷新，状态也不会丢失 target: &#39;web&#39;, plugins: [ new webpack.HotModuleReplacementPlugin({}) ] noParse noParse是用来过滤不需要解析的模块，比如jquery,lodash之类的，这些库一般不会再引入其它库，所以不需要webpack去解析其依赖，也不用打包，只是直接引用即可 module: { noParse: /jquery|lodash/, } 多线程打包thread-loader 将耗时的 loader 放在一个独立的 worker 池中运行，加快 loader 构建速度。 webpack 官网 提到 node-sass 中有个来自 Node.js 线程池的阻塞线程的 bug。 当使用 thread-loader 时，需要设置 workerParallelJobs: 2。 由于 thread-loader 引入后，需要 0.6s 左右的时间开启新的 node 进程，如果项目代码量小，引入 thread-loader就没什么必要了 我们应该仅在非常耗时的 loader 前引入 thread-loader。 优化图片使用打包大小分析工具how to use webpack-bundle-analyzer webpack-bundle-analyzer 升级webpack5遇到的问题node的一些模块webpack不自带了","tags":[{"name":"webpack","slug":"webpack","permalink":"https://github.com/NollieLeo/tags/webpack/"}]},{"title":"学习资料整理","date":"2021-08-04T14:29:08.000Z","path":"2021/08/04/学习资料整理/","text":"TypeScript来玩TypeScript啊，机都给你开好了！ 官方文档（英文） NPM这个讲了好多 React核心文章（一定要看完，卡颂大佬的） 源码讲解 git上的一个react讲解挺不错的 react源码 所有api解读 react hooks用法 Youtube上的视频讲解 一个国外大佬的react知识库 前端核心知识前端进阶积累 前端到服务工程详细 山月行 规范huskyhusky使用总结 conversion-log 整合commitlint + conversion-log 第二篇 angular配合 云原生https://fuckcloudnative.io/","tags":[{"name":"学习资料","slug":"学习资料","permalink":"https://github.com/NollieLeo/tags/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"}]},{"title":"useRef能做啥？","date":"2021-08-03T07:29:45.000Z","path":"2021/08/03/useRef能做啥？/","text":"useRefuseRef主要的功能就是。 帮助我们获取到DOM元素或者组件实例 保存在组件生命周期内不会变化的值 如下： function TextInputWithFocusButton() { const inputEl = useRef(null); const onButtonClick = () =&gt; { // `current` 指向已挂载到 DOM 上的文本输入元素 inputEl.current.focus(); }; return ( &lt;&gt; &lt;input ref={inputEl} type=&quot;text&quot; /&gt; &lt;button onClick={onButtonClick}&gt;Focus the input&lt;/button&gt; &lt;/&gt; ); } 这个创建ref的过程是这样的 组件初始化，执行到useRef，初始化了一个参数null 这时候触发render了，这个过程实现了一个ref的挂载，从null到相对应的组件实例或者DOM挂载，相当于对ref.current的赋值了，这个过程会有一个ref的数据变化 两个特点 每次组件重新渲染useRef的返回值都是同一个（引用不变） ref.current发生变化的时候，不会触发组件的重新渲染，区别于其他的hooks 因此引出两个场景 1.不要单独拿ref作为依赖项useEffect(()=&gt;{ .... },[ref]); useEffect(()=&gt;{ ... }, []); 上面两者相当于是一样的了，因为ref始终是同一个引用。 2.手动调用自己的ref挂载函数这里我们需要通过callback ref的形式去挂载 function MeasureExample() { const [height, setHeight] = useState(0); const measuredRef = useCallback(node =&gt; { if (node !== null) { setHeight(node.getBoundingClientRect().height); } }, []); return ( &lt;&gt; &lt;h1 ref={measuredRef}&gt;Hello, world&lt;/h1&gt; &lt;h2&gt;The above header is {Math.round(height)}px tall&lt;/h2&gt; &lt;/&gt; ); } 注意：这里的ref挂载针对的是DOM元素，如果是要拿组件的ref，则往下看 forwardRef我们用forwardRef包裹函数式组件，见下例 const Parent = () =&gt; { const childRef = useRef(null); useEffect(() =&gt; { ref.current.focus(); }, []); return ( &lt;&gt; &lt;Child ref={ref} /&gt; &lt;/&gt; ); }; const Child = forwardRef((props, ref) =&gt; { return &lt;input type=&quot;text&quot; name=&quot;child&quot; ref={ref} /&gt;; }); 使用forwardRef包裹之后，函数式组件会获得被分配给自己的ref（作为第二个参数）。如果你没有使用forwardRef而直接去ref的话，React会报错。 useImperativeHandle上面forwardRef的例子中，Parent中的ref拿到了Child组件的完整实例，它不但可以使用focus方法，还可以使用其它所有的DOM方法，比如blur,style。这种方式是不推荐的，我们需要严格的控制ref的权力，控制它所能调用到的方法。 所以我们要使用useImperativeHandle来限制暴露给父组件的方法。 const Parent = () =&gt; { const childRef = useRef(null); useEffect(() =&gt; { // 这里只能调用到focus方法 ref.current.focus(); }, []); return ( &lt;&gt; &lt;Child ref={ref} /&gt; &lt;/&gt; ); }; const Child = forwardRef((props, ref) =&gt; { const inputRef = useRef(null); useImperativeHandle(ref, () =&gt; ({ focus: () =&gt; { inputRef.current.focus(); } })); return &lt;input type=&quot;text&quot; name=&quot;child&quot; ref={inputRef} /&gt;; }); 这样子，我们就可以手动控制需要暴露给父组件的方法。 应用获取上一次的值function usePrevious(value) { const ref = useRef(); useEffect(() =&gt; { ref.current = value; }); return ref.current; } 这个hooks返回出来的值，在渲染的过程中，总是会显示上一次的值。我们来解析一下这个函数的运行步骤。 假设上例中ref的初始值传入的value是0,每次数据更新传入的都是递增的数据，比如1，2，3。 初始化，ref.current = 0，渲染出来 数据变化，value传入1, 因为useEffect会在渲染完毕之后才执行，所以这次的渲染过程中，这个为1的value值不会赋值给ref.current。渲染出来的还是上一个值0，渲染完毕了，ref.current变为1。但是ref.current变化不会触发组件的重新渲染，所以需要等到下次的渲染才能显示到页面上。 如此往复，渲染的就总是上一次的值。 使用useRef来保存不需要变化的值 因为useRef的返回值在组件的每次redner之后都是同一个，所以它可以用来保存一些在组件整个生命周期都不需要变化的值。最常见的就是定时器的清除场景。 刚开始在React里写定时器，你可能会这样写 const App = () =&gt; { let timer; useEffect(() =&gt; { timer = setInterval(() =&gt; { console.log(&#39;触发了&#39;); }, 1000); },[]); const clearTimer = () =&gt; { clearInterval(timer); } return ( &lt;&gt; &lt;Button onClick={clearTimer}&gt;停止&lt;/Button&gt; &lt;/&gt;) } 但是上面这个写法有个巨大的问题，如果这个App组件里有state变化或者他的父组件重新render等原因导致这个App组件重新render的时候，我们会发现，点击按钮停止，定时器依然会不断的在控制台打印，定时器清除事件无效了。 为什么呢？因为组件重新渲染之后，这里的timer以及clearTimer方法都会重新创建，timer已经不是定时器的变量了。 所以对于定时器，我们都会使用useRef来定义变量。 const App = () =&gt; { const timer = useRef(); useEffect(() =&gt; { timer.current = setInterval(() =&gt; { console.log(&#39;触发了&#39;); }, 1000); },[]); const clearTimer = () =&gt; { clearInterval(timer.current); } return ( &lt;&gt; &lt;Button onClick={clearTimer}&gt;停止&lt;/Button&gt; &lt;/&gt;) } 实现深度比较useEffect普通的useEffect只是一个浅比较的方法，如果我们依赖的state是一个对象，组件重新渲染，这个state对象的值没变，但是内存引用地址变化了，一样会触发useEffect的重新渲染。 const createObj = () =&gt; ({ name: &#39;zouwowo&#39; }); useEffect(() =&gt; { // 这个方法会无限循环 }, [createObj()]); 我们来使用useRef实现一个深度依赖对比的useDeepEffect import equal from &#39;fast-deep-equal&#39;; export useDeepEffect = (callback, deps) =&gt; { const emitEffect = useRef(0); const prevDeps = useRef(deps); if (!equal(prevDeps.current, deps)) { // 当深比较不相等的时候，修改emitEffect.current的值，触发下面的useEffect更新 emitEffect.current++; } prevDeps.current = deps; return useEffect(callback, [emitEffect.current]); }","tags":[{"name":"react","slug":"react","permalink":"https://github.com/NollieLeo/tags/react/"}]},{"title":"在线编辑网站","date":"2021-08-01T09:23:42.000Z","path":"2021/08/01/在线编辑网站/","text":"babel转换js，react ts转js","tags":[{"name":"网站收藏","slug":"网站收藏","permalink":"https://github.com/NollieLeo/tags/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/"}]},{"title":"21年7月17面试","date":"2021-07-17T11:55:52.000Z","path":"2021/07/17/21年7月17面试/","text":"微医集团面试（1面）（将近一小时）介绍下自己介绍一下你的项目这里我们目前的项目是猪齿鱼devops集成平台，所以他问的很深，包括流水线，部署等等的东西，这块集成的流程是什么 js基础1. var,let,const 什么区别老生常谈，就没啥好说的了 2. js中存在基本数据类型和引用数据类型，你能说说他们的区别吗？这里我提到了存储方式的不同，一个是在栈中存储，一个是在堆中存储 算法优化1. 你在项目中有用到平时刷的算法去优化代码吗？给他列了个例子，从深度优先和广度优先来说（空间复杂度和时间复杂度） 数据结构上面第二点被他套话了，“您刚刚提到了堆和栈，那你提堆和栈还能想起什么吗？” 计算机数据结构有哪些… 除了计算机数据结构提起堆和栈你还能想到什么吗？ 不晓得应该说什么了，我给他提了一下执行上下文栈 浏览器网络相关http的缓存策略强缓存 + 协商缓存 ，什么时候进行强缓存什么时候进行协商 强缓存是通过什么标识来进行的？什么情况下不开启缓存（什么字段标识）协商缓存通过什么标识来进行（304）浏览器存储（localstorage, session, cookie）区别js引擎说一说垃圾回收机制，IE和谷歌的垃圾回收机制有什么区别吗？说一说事件循环机制你能解释一下为什么js的单线程的吗涂鸦智能面试（1面）（面了30分钟）简单介绍一些你和你的项目这里你提到了react hooks，你平时自己有封装过吗你这里项目所说到了一个叫axios的节流缓存方案，你能详细描述一下吗你项目上常用的react hooks有哪些呢，简单介绍一下你能说说受控组件和非受控组件的区别吗ES6中有那些特性你经常用到呢你能讲一下Promise吗？Promise中的构造函数是同步还是异步的？什么是回调地狱你能说说吗？","tags":[{"name":"http","slug":"http","permalink":"https://github.com/NollieLeo/tags/http/"},{"name":"堆和栈","slug":"堆和栈","permalink":"https://github.com/NollieLeo/tags/%E5%A0%86%E5%92%8C%E6%A0%88/"},{"name":"es6","slug":"es6","permalink":"https://github.com/NollieLeo/tags/es6/"},{"name":"promise","slug":"promise","permalink":"https://github.com/NollieLeo/tags/promise/"},{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"var,let,const","slug":"var-let-const","permalink":"https://github.com/NollieLeo/tags/var-let-const/"}]},{"title":"js常见面试题","date":"2021-07-01T13:22:53.000Z","path":"2021/07/01/js常见面试题/","text":"手写篇1. 手写new 2. 手写call, apply 3. 手写instanceof 4. 手写bind 5. 手写promise 6. 深拷贝浅拷贝 7.防抖节流 数据类型 js有哪些数据类型 js有哪些内置对象 数据类型的检测方式（typeof, intanceof, Object.prototype.toString三者区分） null， undefined区别 0.1+0.2 !== 0.3 为什么，如果使其相等 == 操作符强制类型转换规则 什么是js的包装类型 biginit 类型转换类型转换 ES6 箭头函数和普通函数区别 Proxy使用场景 异步宏任务微任务 EvenLoop 原型，原型链，继承 对原型，原型链的理解 ES5实现继承的几种方法（原型链，盗用构造函数，组合继承，原型式继承，寄生式继承，组合寄生式继承） 继承 模块 作用域，作用域链，this指向，执行上下文，闭包执行上下文和执行上下文栈 作用域链 静态作用域 闭包","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"基于猪齿鱼平台的axios缓存封装","date":"2021-06-24T06:02:44.000Z","path":"2021/06/24/基于猪齿鱼平台的axios缓存封装/","text":"需求说明情况1：猪齿鱼平台是个相对复杂的多表格多表单数据处理平台，有些模块的数据量庞大，并且有些喜欢嵌入在tab页面当中，如果频繁的去访问这些页面就会频繁的请求，如果数据量庞大，每次访问都会去请求数据，等待时间就变长了，例如下面这个界面： 7 这个页面相当于是历史的执行记录，因为数据量庞大，我们可以看到这个页面请求过后响应速度较慢，假设我在短时间内切到别的记录又切回来要看，那还得重新再去请求这1000多条的数据，这个是没有必要的，用户等待时间就变长了 情况2：在一个页面渲染的过程中，或者在某些不正当的交互操作中，用户可能频繁的向后台去发送同一个请求（参数url等待都一样），或又是再渲染页面的一瞬间触发了多次同一请求，这样就很浪费带宽，多次请求前端还需要进行多次的响应处理，例如以下情况 image-20210624155243688 在渲染页面时，同时发送了多个相同请求，大多时候是页面逻辑处理的有问题，多次向后台获取数据了，或者是我频繁的去点击一个没有做防抖的按钮或者没有节流的一些频繁请求 情况3：假设我错误的点击了一个菜单的同时又去切到了另外一个菜单，这时候虽然说已经切换到了想要的菜单路由下对应的界面，但是由于你错误的操作，虽然上个页面在切路由瞬间被销毁，但是初始化页面的一些获取后台数据的请求已经发出去了，你访问的当前页面是不需要这些请求的。例如： test 这个例子就是，我先点击了代码管理的菜单，代码管理模块组件瞬间被加载出来，并且发送页面请求，这时候一瞬间切换到应用流水线的菜单，这时候我们会看见，代码管理模块的请求很多没必要的都发送出去了，这些请求并不是我们应用流水线模块需要用的到的。 如果上个页面的请求很慢或者很多情况下，都会占用不必要的资源以及前端处理时间，占用资源。 需求分析 针对情况1, 我们可以做缓存, 类似于DataSet的lookup，但又不完全类似。也可以做类似tab的数据缓存处理， 但是如果页面多起来，我们就需要多次分别对数据进行缓存处理。 针对第二种的情况，可以将重复的请求给取消掉，或者说在这一瞬间发送的多次相同请求都共用第一次发送的那个请求的响应状态。一些按钮或者频繁请求的操作做节流和防抖处理，这个就不再这次的讨论范围内了 第三种情况在切换路由的时候可以想办法把上个页面还在pending中的请求给取消掉 猪齿鱼平台用的是axios + DataSet来进行前后端数据交互以及请求处理的，所以基于他们要如何完美实现呢？ 综上所述：我们要实现一个，能够实现取消，又能实现缓存的，重点是实现相同请求的状态数据的公用以及不影响dataset的使用的东西 可以想到的是，我们肯定是要对axios的拦截器或者一些特殊属性例如axios的适配器，做处理。 缓存分析参考猪齿鱼lookup的缓存原理，以下放出lookup缓存的部分源码； image-20210625112724872 image-20210625113745262 lookup通过标识确定是否缓存，之后将适配器返回的期约直接给一个新得期约，之后存储这个新得期约，在下次发送相同请求时候直接将这个期约抛给它，从而实现请求的复用 首先我们要明白axios 的 adpater的原理： 源码是这样的 image-20210625160815760 可以知道的是，axios 的 transformRequest以及他的各个请求拦截器是在return这个期约之前发生的，之后请求完成，adapter将请求后的结果传递给期约，之后期约落定，后面才触发响应数据转换（transformReponse）以及响应拦截器（这个顺序非常的重要）。 既然要缓存，一定要把第一次落定的请求期约，想办法（包含了响应码数据等等等）存储起来，需要用到的时候才去使用，所以可以确定的是我们缓存需要对adapter进行操作，并且在响应和请求的拦截器中做标识等等操作 多次相同请求处理一开始我想用XMLHttpRequest的abort也就是axios的CancelToken（axios对abort进行了封装）去将页面正在渲染的时候一个个重复的请求cancel掉，但是这样有多种弊端，留到最后一点讲。 多次相同请求是一瞬间的事情，要在这一瞬间复用请求必须用到上面缓存所说的存储期约。 一瞬间咱们就可以定一个默认时间戳，例如1000ms，这个时间戳表示的是，在这1000ms中进来的请求都共用一个adapter的期约，这样定义一个默认时间戳，就可以做到类似取消重复请求的作用（实际上是用了缓存）。 当然既然加了缓存，又加了时间戳，灵活应用一下就可以实现一个，在对应时间内不单单是1000ms，我发的相同请求都共用，我们可以将时间戳直接定义在axios默认属性上或者axios创建出来的实例上面，定义默认值1000ms，之后如果想要缓存时间长一点的话直接在dataset的transport对应的方法配置项下面或者是axios实例上添加时间戳，用来覆盖默认的时间戳，因此可以实现长效缓存。 例如： image-20210625173040963 image-20210625173136449 切换路由取消pending请求这里必须用到axios的CancelToken。上面说到CancelToken的其实就是对XMLhttpRequest的abort方法进行封装， XMLHttpRequest 对象是我们发起一个网络请求的根本，在它底下有怎么一个方法 .abort()，就是中断一个已被发出的请求。 简单理解就是通过 new axios.CancelToken()给每个请求带上一个专属的CancelToken，之后会接收到一个cancel() 取消方法，用于后续的取消动作。 所以，每次请求进来的时候去获取本次请求的CancelToken，之后将其存起来（这里假设用CancelQueue的一个Map数据类型（Object.prototype.toString.call(CancelQueue) = &#39;[object Map]&#39;）），之后假如这个请求落定了，就将这个存储CancelToken的请求标识删除。 如果这时候切换路由了，我们就去CancelQueue中，遍历一遍所有的请求标识（因为这时候再队列里头的肯定是还在pending的请求），调用其存储的CancelToken调用cancel方法进行请求取消，并删除标识。 // 1. 获取 axios CancelToken const { CancelToken } = axios; // 2. 获取当前请求的source，并且将其cancel方法存储起来 const source = CancelToken.source(); // 3. 之后调用这个cancel方法 source.cancel(); 实现axios的实例化首先实例化axios(这是我们全局封装的axios)，在其中加入缓存标识，标识开启缓存（重复请求共用） const instance:AxiosStatic = axios.create({ timeout: 30000, baseURL: API_HOST, }); // 这里配置一个缓存请求得标识 instance.defaults.enabledCancelCache = true; 标识的实现对于每一个请求创建一个标识，标识唯一，标识是通过每一个请求的url, params, method, 以及 data建立标识，只要通过这4者建立的标识相同，那我们就能确定某些请求是相同的， 如下getMark是建立主标识，getDataMark是对响应体内的data的标识 params要进行参数拼接，现在主流基本在用application/json形式，Axios默认以这种形式工作，我们给后端接口传递参数也简单 ，但是有时候需要 Content-Type必须以application/x-www-form-urlencoded形式 ，以JSON格式后台是收不到的，而这时候就要进行序列化处理（先前是有前辈在这里做了处理的），但是这里不多说参数序列化 import { get } from &#39;lodash&#39;; import { AxiosRequestConfig } from &#39;axios&#39;; import JSONbig from &#39;json-bigint&#39;; import paramsSerializer from &#39;./paramsSerializer&#39;; // 单独处理data，response里面返回的config.data是个字符串对象 function getDataMark(data:any) { let stringifyData = data; if (typeof stringifyData === &#39;string&#39;) { stringifyData = JSONbig.parse(stringifyData); } return stringifyData; } // 区别请求的唯一标识，这里用方法名+请求路径 // 如果一个项目里有多个不同baseURL的请求 + 参数 export default function getMark(config:AxiosRequestConfig) { const getKey = (key:string) =&gt; get(config, key); // params标识处理，将其处理成?key=value&amp;key2=value的形式 const tempQueryString = (getKey(&#39;paramsSerializer&#39;) ?? paramsSerializer)(getKey(&#39;params&#39;)); // data标识处理 const dataMark = JSONbig.stringify(getDataMark(getKey(&#39;data&#39;))); // base标识 const requestMark = [ config?.method?.toLowerCase() || &#39;unknownMethod&#39;, config?.url, ]; getKey(&#39;params&#39;) &amp;&amp; requestMark.push(tempQueryString); getKey(&#39;data&#39;) &amp;&amp; requestMark.push(dataMark); return requestMark.join(&#39;&amp;&#39;); } 最终的拼接形式是 method &amp; url &amp; params &amp; data的形式， 例如下面这个请求 image-20210625210606969 image-20210625210632981 最终拼接出来的是 post&amp;http://172.23.16.92:30094/iam/choerodon/v1/permissions/menus/check-permissions&amp;tenantId=2&amp;[&quot;choerodon.code.organization.project.ps.create&quot;] 缓存实现这里我们采用拦截器的形式去添加缓存逻辑，以下是添加了请求拦截器 image-20210626094315248 下面标红的是添加响应拦截器 image-20210626094721131 至于这里拦截器的顺序为什么是这样的，后续再说 其次，我们要明白请求的几种情况 假设现在有一个A请求进来了 还在pending的时候，在默认时间戳内（1000ms）又进来了一个一模一样的A请求（重复了,共用状态） A请求已经落定了成功了，在定义的时间戳范围内又进来了多个一模一样的请求（缓存） A请求落定失败了，在定义的时间戳范围内又进来了多个一模一样的请求（不缓存） 最后明确需要存储在缓存实例中的数据格式 image-20210626101834505 存储数据我们需要以一种键值对的形式去存储，可选项就属Object或者Map。 但是这里我们需要频繁的对缓存的数据进行查找，插入，赋值，删除操作等等。 在小数量数据情况下Object的查找数据相对Map来的快，但是涉及更多插入的和删除的情况下都是Map性能来的优势，并且相同内存下Map能够存储更多的键值对，这里显然存在庞大数据的情况 于是这里封装一个AxiosCache缓存类，然后写一些私有方法在里头 class AxiosCache { constructor() { super(); this.cacheData = new Map(); } get size() { return this.cacheData.size; } get(key) { return this.cacheData.get(key); } delete(key) { this.cacheData.delete(key); } has(key) { return this.cacheData.has(key); } set(key, value) { this.cacheData.set(key, value); } isEmpty() { return !!this.cacheData.size; } clear() { this.cacheData = new Map(); } } const axiosCache = new AxiosCache(); 请求拦截器实现 当A请求进来时候发现先前并没有在缓存队列中做过标识，也就是说标识里头不存在以上的那些字段，这时候我们就将A请求做个标识，并且设置它的isPending（正在请求）为true axiosCache.set(cancelCacheKey, { isPending: true, }); 当A请求已经做过标识的时候，这时候又进来一个A1请求 倘若第一次做过标识的A请求已经不是在pending状态并且在这次请求的时间戳的范围内（在后面讲响应拦截器的时候会把A的isPending字段在某种条件下设置为false, 并且存储A请求响应后的数据），A1请求就直接去取A缓存的数据 这里就涉及到上面所说的适配器的用处，直接在A1请求config的适配器返回一个成功落定的期约，通过标识拿到cache实例中缓存的数据数据。 // isPending为false的情况下，并且在时间戳的范围内 if (expire &amp;&amp; expire &gt; Date.now()) { tempConfig.adapter = () =&gt; { const resolveData: AxiosResponse = { data, headers: tempConfig.headers, config: { ...tempConfig, useCache: true, }, // @ts-expect-error request: tempConfig, }; return Promise.resolve(resolveData); }; } 这里定义一个useCache的字段表明这个是再用缓存数据，后续的响应拦截器中会讲到 当A请求已经做过标识的时候，这时候又进来一个A1请求 倘若第一次做过标识的A请求还在pending的状态，我又想共用缓存数据，但是并不清楚什么时候A请求才会结束。 这时候我们就想，用一个发布订阅的模式，将A1请求的期约落定时机订阅起来，在A请求落定的时候告诉A1你是时候也该落定了就去发布信息，这时候缓存的数据就是在A请求落定时候，去发布顺便给A1传递的. 其实这个过程可以有多个A1进来 如果不好理解的这里有流程图 ​ image-20210626111840112 // 说明找到了请求但是找到的这个缓存的请求还在pending，这时候订阅一个期约待会要用 tempConfig.adapter = () =&gt; new Promise((resolve) =&gt; { axiosEvent.once(cancelCacheKey, (res:unknown) =&gt; { const resolveData: AxiosResponse = { data: res, headers: tempConfig.headers, config: { ...tempConfig, useCache: true, }, // @ts-expect-error request: tempConfig, }; resolve(resolveData); }); }); 这里A1请求订阅了以一个以cancelCacheKey为标识的信号。 至于A请求落定的时机，到响应拦截器中做处理 如果A请求请求失败怎么办？那这时候我们不做处理，也不做标识，请求失败走的是请求失败的拦截器。 以下是整个请求拦截器代码 import { AxiosRequestConfig, AxiosResponse } from &#39;axios&#39;; import { get } from &#39;lodash&#39;; import getMark, { transformDataToString } from &#39;../utils/getMark&#39;; import { axiosCache, axiosEvent } from &#39;../instances&#39;; export function handleCancelCacheRequest(config:AxiosRequestConfig) { const tempConfig = config; // 是否开启了缓存（复用重复请求状态） const enabledCancelCache = get(tempConfig, &#39;enabledCancelCache&#39;); if (enabledCancelCache) { // 获取标识 const cancelCacheKey = getMark(tempConfig); if (!axiosCache.has(cancelCacheKey)) { axiosCache.set(cancelCacheKey, {}); } const { data, // 缓存的数据 isPending, // 请求是否是pending状态 expire, // 时间戳 } = axiosCache.get(cancelCacheKey); if (isPending) { // 说明找到了请求但是找到的这个缓存的请求还在pending，这时候订阅一个期约待会要用 tempConfig.adapter = () =&gt; new Promise((resolve) =&gt; { axiosEvent.once(cancelCacheKey, (res:unknown) =&gt; { const resolveData: AxiosResponse = { data: res, headers: tempConfig.headers, config: { ...tempConfig, useCache: true, }, // @ts-expect-error request: tempConfig, }; resolve(resolveData); }); }); } else if (expire &amp;&amp; expire &gt; Date.now()) { tempConfig.adapter = () =&gt; { const resolveData: AxiosResponse = { data: transformDataToString(data), headers: tempConfig.headers, config: { ...tempConfig, useCache: true, }, // @ts-expect-error request: tempConfig, }; return Promise.resolve(resolveData); }; } else { axiosCache.set(cancelCacheKey, { isPending: true, }); } } return tempConfig; } 响应拦截器的实现实现了请求拦截器之后，我们来处理在先前拦截器中的一些字段，以及请求失败的数据处理 我们先对响应成功的的拦截器做处理 首先是响应成功的情况下而且也成功拿到想要的数据，假设这个响应成功的请求是上述的A请求，这时候我们就应该记录下A请求最终的所有数据以及它需要的缓存时间，并且设置它isPending字段为false，最重要的是给订阅了cancelCacheKey的信息的请求们发布一个信号，告诉你们可以来拿我的（A请求）数据了！ if (enabledCancelCache &amp;&amp; !useCache) { const finalData = resData; axiosCache.set(config?.cancelCacheKey || cancelCacheKey, { data: finalData, isPending: false, expire: Date.now() + Number(enabledCancelCache) * 500, }); // 发布这个信号让所有订阅了A的都能接受到信息 axiosEvent.emit(cancelCacheKey, finalData); } 这里为什么要多一次useCache的判断呢? 因为我先前在请求拦截器中处理了adapter用来处理缓存, 走完了adapter才会走响应拦截器，也就是说，我在响应拦截器里头还得判断，这次到底是走的缓存，还是第一次需要做缓存呢？所以才知道为什么我在上面的adapter里头加入了useCache的字段。 简单来说，就是A请求第一次进来，useCache就是false，就得去存值，接下来进来A1，那我就得走缓存，我不再去重新设置新值了。 没有成功拿到想要的数据，也就是后端返回错误信息的情况 这里我们的后台返回的错误标识是failed字段，就直接将isPending设置为false不做后续处理，并且将在订阅了的请求信号都删除(删除是因为A请求失败就已经报错，其他请求就不必再重复报错) axiosCache.set(cancelCacheKey, { isPending: false, }); axiosEvent.delete(cancelCacheKey); 当然响应失败拦截器中也需要做上述这样的处理 这是最终的响应成功的拦截器代码👇 import { AxiosResponse } from &#39;axios&#39;; import get from &#39;lodash/get&#39;; import { prompt, } from &#39;@/utils&#39;; import { axiosCache, axiosEvent } from &#39;../instances&#39;; import getMark from &#39;../utils/getMark&#39;; export default function handleResponseInterceptor(response:AxiosResponse) { const resData = get(response, &#39;data&#39;); const config = get(response, &#39;config&#39;) || {}; const { enabledCancelCache, useCache } = config; const cancelCacheKey = getMark(config); if (get(response, &#39;status&#39;) === 204) { return response; } if (resData?.failed === true) { axiosCache.set(cancelCacheKey, { ...(axiosCache.get(cancelCacheKey) || {}), isPending: false, }); if (!response?.config?.noPrompt) { prompt(resData.message, &#39;error&#39;); } throw resData; } if (enabledCancelCache &amp;&amp; !useCache) { const finalData = resData; axiosCache.set(config?.cancelCacheKey || cancelCacheKey, { data: finalData, isPending: false, expire: Date.now() + Number(enabledCancelCache) * 500, }); axiosEvent.emit(cancelCacheKey, finalData); } return resData; } 切换路由取消pending请求这里的思路就相对比较简单，按照上面需求分析所说的存储cancelToken给每一个请求，之后切换路由将pending的请求取消掉 因此我们不单单需要实现存储cancelToken的一个队列，还有处理他的拦截器，我们还需要监听路由的变化，找到这个时机将所有pending请求cancel掉 拦截器的实现这里我们封装一个拦截器routeCancelInterceptor // 添加切换路由取消pending请求拦截器 instance.interceptors.request.use(routeCancelInterceptor); // 4 需要一个取消请求的队，列于是封装一个实例用来存储对应的请求，包含相对应的get，set，等方法，最重要的是 cancelAllRequest方法，用于遍历所有存储的pending请求，之后在切路由的时候，遍历数据取消它。这里为什么还需要引入前面做了缓存的axiosCache，后头会细讲 import { axiosCache } from &#39;./index&#39;; class RouteAxios { constructor() { this.pendingRequest = new Map(); } get size() { return this.pendingRequest.size; } get(key) { return this.pendingRequest.get(key); } delete(key) { this.pendingRequest.delete(key); } has(key) { return this.pendingRequest.has(key); } set(key, value) { this.pendingRequest.set(key, value); } isEmpty() { return !!this.pendingRequest.size; } clear() { this.pendingRequest = new Map(); } cancelAllRequest() { for (const [key, value] of this.pendingRequest) { if (value?.cancel &amp;&amp; typeof value.cancel === &#39;function&#39;) { value.cancel(); axiosCache.delete(key); // 这里为什么这么做？后续在说 } } this.clear(); } } export const axiosRoutesCancel = new RouteAxios(); 之后要我们就在请求拦截器里头处理cancelToken 当然首先也是先检测是否有这个enabledCancelRoute字段表明是否要将这个请求加入切换路由取消请求的方案，之后调用source()，获取存储其source.cancel方法，重点是要在config上加入cancelToken，表明这个请求待会可能会被取消（简单来讲这个标识对应这个source.cancel的执行目标） import axios, { AxiosRequestConfig } from &#39;axios&#39;; import get from &#39;lodash/get&#39;; import { axiosRoutesCancel } from &#39;../instances&#39;; import getMark from &#39;../utils/getMark&#39;; export function routeCancelInterceptor(config:AxiosRequestConfig) { const tempConfig = config; const enabledCancelRoute = get(tempConfig, &#39;enabledCancelRoute&#39;); if (enabledCancelRoute) { const cancelRouteKey = tempConfig?.cancelCacheKey || getMark(config); const { CancelToken } = axios; const source = CancelToken.source(); tempConfig.cancelToken = source.token; axiosRoutesCancel.set(cancelRouteKey, { cancel: source.cancel, name: cancelRouteKey, }); } return tempConfig; } 如果请求在还没切换路由的时候就已经响应成功（这里不管是否拿到正确数据），就应该直接删除这个存储的key值 这里就在响应成功的拦截器中处理，在失败拦截器中也是一样的处理方案 if (enabledCancelRoute) { axiosRoutesCancel.delete(cancelCacheKey); } 路由守卫的实现实现了拦截器我们还需要简单的实现一个路由守卫，用来监听路由变化 在全局，我们封装了一个叫做PermissionRoute的守卫，这守卫是对react-router-dom的route做了变向封装 const PermissionRoute: React.FC&lt;PermissionRouteProps&gt; =()=&gt; React.ReactDOM 给这个组件配置参数，叫做enabledRouteChangedAjaxBlock，默认为true, 标识这个路由下的请求，在切换的时候都会被取消，当然每个请求自己也会标识自己是否在切换路由的时候要被取消，后者的优先级大于前者 之后我们写一个组件销毁的生命周期函数（路由切换的时候，这个路由对应的路由守卫组件就会被销毁，随之销毁（取消）的也就是当前页面正在pending的请求） useEffect(() =&gt; function () { if (enabledRouteChangedAjaxBlock &amp;&amp; axiosRoutesCancel.size) { axiosRoutesCancel.cancelAllRequest(); } }, [location]); useEffect返回一个销毁的函数，并且cancel掉所有pending请求。 这里具体可以看看PermissionRoute的封装代码，方便理解 import React, { useEffect, useMemo } from &#39;react&#39;; import { Route, RouteProps, useLocation } from &#39;react-router-dom&#39;; import { noaccess as NoAccess, Permission } from &#39;@/index&#39;; import useQueryString from &#39;@/hooks/useQueryString&#39;; import Skeleton from &#39;@/containers/components/c7n/master/skeleton&#39;; import { axiosRoutesCancel } from &#39;@/containers/components/c7n/tools/axios/instances&#39;; interface PermissionRouteProps extends RouteProps { service: string[] | ((type: &#39;project&#39; | &#39;organization&#39; | &#39;site&#39;) =&gt; string[]), enabledRouteChangedAjaxBlock: boolean, } const isFunction = (something: unknown): something is Function =&gt; typeof something === &#39;function&#39;; const PermissionRoute: React.FC&lt;PermissionRouteProps&gt; = ({ enabledRouteChangedAjaxBlock = true, service, ...rest }) =&gt; { const { type } = useQueryString(); const location = useLocation(); const codes = useMemo(() =&gt; (isFunction(service) ? service(type) : (service || [])), [service, type]); const route = ( &lt;Route {...rest} /&gt; ); useEffect(() =&gt; function () { if (enabledRouteChangedAjaxBlock &amp;&amp; axiosRoutesCancel.size) { axiosRoutesCancel.cancelAllRequest(); } }, [location]); return (codes.length &gt; 0) ? ( &lt;Permission service={codes} noAccessChildren={&lt;NoAccess /&gt;} defaultChildren={&lt;Skeleton /&gt;} &gt; {route} &lt;/Permission&gt; ) : ( &lt;Route {...rest} /&gt; ); }; export default PermissionRoute; // 用法 &lt;PermissionRoute service={[&#39;choerodon.code.project.project.overview.ps.default&#39;]} exact path={`${match.url}agile/project-overview`} component={ProjectOverview} /&gt; 遗留问题为什么不用CancelToken去取消重复请求而用缓存原理？我们知道取消重复请求原理是abort，定义是：请求如果发出，则立刻终止请求； 原因一：这个终止就很微妙，终止之后的请求我们可以知道它走了响应失败的拦截器，也就是说我们前端还是把数据发给了后端，后端还会做数据处理比如（post，put等），只是终止了，但是后端并不知道我们终止了请求，只是前端终止没有在像响应成功拦截器一样对数据做处理 但是实际上我们要的效果不是这样，我们要的是在那一瞬间的所有相同请求状态复用，重复的请求们是不可以在那一瞬间再发送给后端的，而是只有那个第一次的请求才发出去，如果使用CancelToken这样就没有意义了 原因二abort会导致浏览器中的network中一堆报红，看上去比较不美观。 image-20210627124622241 原因三如果用了cancelToken我又想做缓存，还不如直接用缓存来，也可以达到效果 为什么拦截器的添加顺序会影响到缓存？这也是在上面讲axios的adapter的时候提及过 请求拦截器是的执行顺序是后添加的先执行 响应拦截器是先添加的先执行 例如：我们项目的请求拦截器是这样添加的 // 添加切换路由取消pending请求拦截器 instance.interceptors.request.use(routeCancelInterceptor); // 4 // 添加缓存(复用重复请求)请求拦截器 instance.interceptors.request.use(handleCancelCacheRequest, handleRequestError); // 3 // 分页数据转换拦截器 instance.interceptors.request.use(transformRequestPage); // 2 // 添加头部拦截器， 以及请求失败拦截器 instance.interceptors.request.use(addCustomHeader); // 1 按顺序是从下到上执行，按照标注的1，2，3，4执行 响应拦截器是这样的 // 添加响应拦截器 instance.interceptors.response.use(transformResponsePage); // 1 instance.interceptors.response.use(handleResponseInterceptor, handelResponseError); // 2 路由取消cancelAllRequest方法中为什么要删除cache中的数据？难点解决","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"axios","slug":"axios","permalink":"https://github.com/NollieLeo/tags/axios/"}]},{"title":"算法之二叉树的所有路径","date":"2021-06-20T08:45:45.000Z","path":"2021/06/20/算法之二叉树的所有路径/","text":"257. 二叉树的所有路径给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 image-20210620164623685 思路： 前序遍历，每一次访问下一个节点都把本次的路径字符串传递下去，每次走到节点没有左右子树了就把最终的这个字符串给存到最终数组里头 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {string[]} */ var binaryTreePaths = function (root) { if (!root) { return root; } let res = []; const getPath = (root, str) =&gt; { if (root) { if (str) { str += `-&gt;${root.val}`; } else { str = String(root.val); } if (root.left) { getPath(root.left, str) } if (root.right) { getPath(root.right, str) } if (!root.right &amp;&amp; !root.left) { res.push(str); } } } getPath(root, &#39;&#39;); return res; };","tags":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"算法之无重复字符最长子串","date":"2021-06-20T08:30:50.000Z","path":"2021/06/20/算法之无重复字符最长子串/","text":"3. 无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 image-20210620163148398 解法： 1.滑动窗口 image-20210620163418701 image-20210620163439373 image-20210620163452684 var lengthOfLongestSubstring = function(s) { // 哈希集合，记录每个字符是否出现过 const occ = new Set(); const n = s.length; // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动 let rk = -1, ans = 0; for (let i = 0; i &lt; n; ++i) { if (i != 0) { // 左指针向右移动一格，移除一个字符 occ.delete(s.charAt(i - 1)); } while (rk + 1 &lt; n &amp;&amp; !occ.has(s.charAt(rk + 1))) { // 不断地移动右指针 occ.add(s.charAt(rk + 1)); ++rk; } // 第 i 到 rk 个字符是一个极长的无重复字符子串 ans = Math.max(ans, rk - i + 1); } return ans; };","tags":[{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"哈希表","slug":"哈希表","permalink":"https://github.com/NollieLeo/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://github.com/NollieLeo/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"算法之二叉搜索树的众数","date":"2021-06-20T07:59:30.000Z","path":"2021/06/20/算法之二叉搜索树的众数/","text":"501. 二叉搜索树中的众数给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。 假定 BST 有如下定义： 结点左子树中所含结点的值小于等于当前结点的值、 结点右子树中所含结点的值大于等于当前结点的值 左子树和右子树都是二叉搜索树 image-20210620160046650 解法： 1.递归中序遍历（开辟新空间） 思路： image-20210620160831230 image-20210620160856742 image-20210620160915942 var findMode = function(root) { let base = 0, count = 0, maxCount = 0; let answer = []; const update = (x) =&gt; { if (x === base) { ++count; } else { count = 1; base = x; } if (count === maxCount) { answer.push(base); } if (count &gt; maxCount) { maxCount = count; answer = [base]; } } const dfs = (o) =&gt; { if (!o) { return; } dfs(o.left); update(o.val); dfs(o.right); } dfs(root); return answer; };","tags":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"}]},{"title":"算法之有效括号","date":"2021-06-20T07:34:33.000Z","path":"2021/06/20/算法之有效括号/","text":"20. 有效的括号给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。、 左括号必须以正确的顺序闭合。 image-20210620153513595 解法： 1.利用栈 思路： 根据题意，我们可以推断出以下要点： 有效括号字符串 长度，一定是偶数！ 右括号前面，必须是相对应的左括号，才能抵消！ 右括号前面，不是对应的左括号，那么该字符串，一定不是有效的括号！ image-20210620153851332 image-20210620153901841 image-20210620153913790 image-20210620153926387 image-20210620153936050 /** * @param {string} s * @return {boolean} */ let isValid = function (s) { if (s.length % 2) { return false; } let stack = []; for (let item of s) { switch (item) { case &quot;{&quot;: stack.push(item); break; case &quot;[&quot;: stack.push(item); break; case &quot;(&quot;: stack.push(item); break; case &quot;}&quot;: if (stack.pop() !== &quot;{&quot;) return false; break; case &quot;]&quot;: if (stack.pop() !== &quot;[&quot;) return false; break; case &quot;)&quot;: if (stack.pop() !== &quot;(&quot;) return false; break; } } return !stack.length; };","tags":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"栈","slug":"栈","permalink":"https://github.com/NollieLeo/tags/%E6%A0%88/"}]},{"title":"算法之二叉树的剪枝","date":"2021-06-20T07:09:05.000Z","path":"2021/06/20/算法之二叉树的剪枝/","text":"814. 二叉树剪枝给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。 返回移除了所有不包含 1 的子树的原二叉树。 ( 节点 X 的子树为 X 本身，以及所有 X 的后代。) image-20210620151025318 解法： 1.递归 思路： 首先看以下什么情况会移除这个节点，两个条件都必须满足 这个节点为0 并且这个节点的左右子树节点，要么子树不存在，要么子树所有节点都为0、 按照上面的点就可以使用递归，这个节点等于0，并且没有左右子树的情况，删除这个节点， 就返回null让他等于父节点左或者右子树 所以我们要去走二叉树的后序遍历，左右中， 这题的重点就是一定要走后序遍历，先去判断左右节点 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {TreeNode} */ var pruneTree = function (root) { if (!root) { return root } return getNode(root) }; function getNode(node) { if (node.left) { node.left = getNode(node.left) } if (node.right) { node.right = getNode(node.right) } if (!node.left &amp;&amp; !node.right &amp;&amp; node.val === 0) { return null } return node }","tags":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"算法之重建二叉树","date":"2021-06-20T06:32:20.000Z","path":"2021/06/20/算法之重建二叉树/","text":"剑指 Offer 07. 重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 image-20210620143940113 解法： 1.递归 思路： 递归，六句代码包含着大智慧。首先我们要明白前序遍历和中序遍历的节点遍历顺序。前序遍历：根-&gt;左-&gt;右中序遍历：左-&gt;根-&gt;右结合题目的数组我们可以得到一个信息：preorder得到的根节点，在inorder中的它的位置，左侧是左子树，右侧是右子树而在inorder获取的索引可以帮助我们划分preorder数组于是我们可以通过划分数组的方式递归得到叶子节点，然后通过一步步的回溯把它们组装起来，就是一棵完整的树 image-20210620143830588 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {number[]} preorder * @param {number[]} inorder * @return {TreeNode} */ var buildTree = function (preorder, inorder) { if (preorder.length === 0) return null const cur = new TreeNode(preorder[0]) const index = inorder.indexOf(preorder[0]) cur.left = buildTree(preorder.slice(1, index + 1), inorder.slice(0, index)) cur.right = buildTree(preorder.slice(index + 1), inorder.slice(index + 1)) return cur };","tags":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"算法之验证二叉搜索树","date":"2021-06-20T06:13:30.000Z","path":"2021/06/20/算法之验证二叉搜索树/","text":"98. 验证二叉搜索树给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 image-20210620141619034 解法： 1.递归 思路： 根据二叉搜索树的特性： 中序遍历的时候遍历的顺序是由小到大逐渐遍历的，也就是升序排列， 所以我们保存上一个值prev，与当前值current作比较。 如果当前值小于等于上一个值，那么这个树不是二叉搜索树。 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {boolean} */ var isValidBST = function (node) { var prev = -Infinity function inorder(node) { if (!node) { return true } var preResult = inorder(node.left) var inResult = node.val &gt; prev prev = node.val var postResult = inorder(node.right) return preResult &amp;&amp; inResult &amp;&amp; postResult } return inorder(node) } 2.非递归（迭代） var isValidBST = function (node) { var stack = [] var prev = -Infinity while(stack.length || node) { while(node) { stack.push(node) node = node.left } node = stack.pop() if (node.val &lt;= prev) { return false } prev = node.val node = node.right } return true }","tags":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"}]},{"title":"算法之二叉树的直径","date":"2021-06-20T06:03:36.000Z","path":"2021/06/20/算法之二叉树的直径/","text":"543. 二叉树的直径给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 image-20210620140459295 解法： 1.DFS递归 思路： 既然是求二叉树中直径长度是任意两个节点中的最大路径值 那我们直接求每个节点的左子树和右子树深度，然后一个个节点进行左右深度和比较就能找出、 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number} */ var diameterOfBinaryTree = function (root) { if (!root) { return 0; } function maxDepth(node) { if (!node) { return 0 } let dep = 1; dep += Math.max(maxDepth(node.left), maxDepth(node.right)); return dep; } return Math.max( maxDepth(root.left) + maxDepth(root.right), diameterOfBinaryTree(root.left), diameterOfBinaryTree(root.right) ); };","tags":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"算法之删除二叉树中的节点","date":"2021-06-19T08:48:11.000Z","path":"2021/06/19/算法之删除二叉树中的节点/","text":"450. 删除二叉搜索树中的节点给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。 一般来说，删除节点可分为两个步骤： 首先找到需要删除的节点； 如果找到了，删除它. 说明： 要求算法时间复杂度为 O(h)，h 为树的高度 image-20210619165224426 思路 因为BST的左子树总是比根节点小，右子树总是比根节点大，所以我们将根节点的值与要删除的 key 值对比，就知道要删除的值大概在哪个位置：• 相等：要删除的节点就是当前根节点，即递归退出条件• key更大：则要递归朝右子树去删除• key更小：则要递归朝左子树去删除找到要删除后的节点会出现四种情况：• 待删除的节点左右子树均为空。证明是叶子节点，直接删除即可，即将该节点置为null• 待删除的节点左子树为空，让待删除节点的右子树替代自己。 image-20210619165359299 • 待删除的节点右子树为空，让待删除节点的左子树替代自己。 image-20210619165415885 • 如果待删除的节点的左右子树都不为空。我们需要找到比当前节点小的最大节点（前驱）[或比当前节点大的最小节点（后继）]，来替换自己. const deleteNode = function (root, key) { if (root == null) return root if (root.val &gt; key) { // 往左子树找 root.left = deleteNode(root.left, key) } else if (root.val &lt; key) { // 往右子树找 root.right = deleteNode(root.right, key) } else { // 找到了 if (!root.left &amp;&amp; !root.right) { // 待删除的节点左右子树均为空。证明是叶子节点，直接删除即可 root = null } else if (root.left &amp;&amp; !root.right) { // 待删除的节点右子树为空，让待删除节点的左子树替代自己。 root = root.left } else if (!root.left &amp;&amp; root.right) { // 待删除的节点左子树为空，让待删除节点的右子树替代自己。 root = root.right } else if (root.left &amp;&amp; root.right) { // 如果待删除的节点的左右子树都不为空。我们需要找到比当前节点小的最大节点（前驱）来替换自己 let last = root.left while (last.right) { last = last.left } // 最终的last就是比当前节点小的最大节点，将值进行替换 root.val = last.val // 删除该最大节点 root.left = deleteNode(root.left, last.val) } } return root }","tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"}]},{"title":"算法之修剪二叉搜索树","date":"2021-06-19T08:41:05.000Z","path":"2021/06/19/算法之修剪二叉搜索树/","text":"669. 修剪二叉搜索树给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。 image-20210619164548851 image-20210619164609679 解法 1.递归 思路 结合二叉搜索树的特点，节点值大于它的左节点并且小于它的右节点那么： 当节点值 &lt; L ，把它的左子树抛弃掉，继续修剪它的右子树 当节点值 &gt; R ，把它的右子树抛弃掉，继续修剪它的左子树 否则当前节点值满足 L &lt; node.val &lt; R ，那么它的左右子树都有可能仍然有符合条件 的节点值，所以要继续修剪左、右子树 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @param {number} L * @param {number} R * @return {TreeNode} */ var trimBST = function(root, L, R) { if (root === null) return root; if (root.val &lt; L) return trimBST(root.right, L, R); if (root.val &gt; R) return trimBST(root.left, L, R); root.left = trimBST(root.left, L, R); root.right = trimBST(root.right, L, R); return root; };","tags":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"}]},{"title":"算法之二叉搜索树的最近公共祖先","date":"2021-06-19T08:25:13.000Z","path":"2021/06/19/算法之二叉搜索树的最近公共祖先I/","text":"剑指 Offer 68 - I. 二叉搜索树的最近公共祖先给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] image-20210619163242688 实现 1.递归 核心思路： 1. 当 传入的祖先节点 同时大于/小于 p、q节点 更新祖先节点位置 a. root 同时小于 p、q 基于BST的特性可知 期望的祖先节点 应该在右子树 root = root.right b. root 同时大于 p、q 基于BST的特性可知 期望的祖先节点 应该在左子树 root = root.left 2. 当遇到/第一次 祖先节点root 不同时大于或小于 p、q的节点 即为我我们期望的最近公共祖先节点 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @param {TreeNode} p * @param {TreeNode} q * @return {TreeNode} */ var lowestCommonAncestor = function(root, p, q) { if (!root) return root if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) { return lowestCommonAncestor(root.right, p, q) } else if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) { return lowestCommonAncestor(root.left, p, q) } else { return root } }; 2.迭代 利用二叉搜索树的特点首先判断 p 和 q 是否相等，若相等，则直接返回 p 或 q 中的任意一个，程序结束 若不相等，则判断 p 和 q 在向左还是向右的问题上，是否达成了一致如果 p 和 q 都小于root, 哥俩一致认为向左👈，则 root = root.left如果 p 和 q 都大于root, 哥俩一致认为向右👉，则 root = root.right如果 p 和 q 哥俩对下一步的路线出现了分歧，说明 p 和 q 在当前的节点上就要分道扬镳了，当前的 root 是哥俩临别前一起走的最后一站返回当前 root程序结束 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @param {TreeNode} p * @param {TreeNode} q * @return {TreeNode} */ var lowestCommonAncestor = function (root, p, q) { if (!root) { return null } while (root) { if (root.val &lt; q.val &amp;&amp; root.val &lt; p.val) { root = root.right } else if (root.val &gt; q.val &amp;&amp; root.val &gt; p.val) { root = root.left } else { return root } } };","tags":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"二叉树公共祖先","slug":"二叉树公共祖先","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"}]},{"title":"算法之二叉搜素树范围和","date":"2021-06-19T07:38:52.000Z","path":"2021/06/19/算法之二叉搜素树范围和/","text":"938. 二叉搜索树的范围和给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。 解法 1.递归深度优先搜索 按深度优先搜索的顺序计算范围和。记当前子树根节点为 root， 分4种情况讨论 root节点为空，返回0 root.val值大于high的值，根据二叉搜索树的性质知道，应该此时去找root的左子树，无需考虑右子树 root.val值小于low的值，根据二叉搜索树的性质知道，应该此时去找root的右子树，无需考虑左子树 root.val值必须在[low, high]范围内 最终应该返回这个节点值和左右子树值的和 var rangeSumBST = function(root, low, high) { if (!root) { return 0; } if (root.val &gt; high) { return rangeSumBST(root.left, low, high); } if (root.val &lt; low) { return rangeSumBST(root.right, low, high); } return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high); }; 2.迭代（广度优先） 使用广度优先搜索的方法，用一个队列 q 存储需要计算的节点。每次取出队首节点时，若节点为空则跳过该节点，否则按方法一中给出的大小关系来决定加入队列的子节点。 var rangeSumBST = function(root, low, high) { let sum = 0; const q = [root]; while (q.length) { const node = q.shift(); if (!node) { continue; } if (node.val &gt; high) { q.push(node.left); } else if (node.val &lt; low) { q.push(node.right); } else { sum += node.val; q.push(node.left); q.push(node.right); } } return sum; };","tags":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉搜素哦树","slug":"二叉搜素哦树","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A0%E5%93%A6%E6%A0%91/"},{"name":"二叉搜索树范围和","slug":"二叉搜索树范围和","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8C%83%E5%9B%B4%E5%92%8C/"}]},{"title":"算法之最后一块石头重量","date":"2021-06-19T07:29:42.000Z","path":"2021/06/19/算法之最后一块石头重量/","text":"1046. 最后一块石头的重量有一堆石头，每块石头的重量都是正整数。 每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下： 如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。 image-20210619153349043 实现： 1.非递归 排序后比较最后面两个 不同差放数组，递归直至边界数组长度 &lt;= 1 /** * @param {number[]} stones * @return {number} */ var lastStoneWeight = function (stones) { if (stones.length &lt;= 1) { return stones; } stones.sort((a, b) =&gt; a - b); while (stones.length &gt; 1) { const pre = stones.pop(); const next = stones.pop(); if (pre !== next) { const temp = pre - next; let i = 0; while (stones[i] &lt; temp) { i++; } stones.splice(i, 0, temp); } } return stones.length ? stones[0] : 0; };","tags":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"栈","slug":"栈","permalink":"https://github.com/NollieLeo/tags/%E6%A0%88/"}]},{"title":"算法之合并二叉树","date":"2021-06-19T07:15:41.000Z","path":"2021/06/19/算法之合并二叉树/","text":"617. 合并二叉树给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 image-20210619151739614 思路 同步地遍历两棵树上的节点，直接在 t1 上修改。 如果把 mergeTrees 函数作为递归函数，参数 t1 和 t2 是指：当前遍历的节点（子树） 递归。总是关注当前节点t1 为 null 、t2 不是 null，t1t1 换成 t2 。（return t2）t2 为 null、t1t1 不是 null，t1t1 依然 t1 。（return t1） t1 和 t2 都为 null，t1t1 依然 t1。（return t1） t1、t2 都存在，将 t2 的值加给 t1 。（t1.val += t2.val） 『子树的合并』交给递归去做，它会对每一个节点做同样的事情。 t1.left = mergeTrees(t1.left, t2.left); t1.right = mergeTrees(t1.right, t2.right); image-20210619152328260 代码 const mergeTrees = (t1, t2) =&gt; { if (t1 == null &amp;&amp; t2) { return t2; } if ((t1 &amp;&amp; t2 == null) || (t1 == null &amp;&amp; t2 == null)) { return t1; } t1.val += t2.val; t1.left = mergeTrees(t1.left, t2.left); t1.right = mergeTrees(t1.right, t2.right); return t1; }; 如果不在原树修改，新建一个树呢？const mergeTrees = (t1, t2) =&gt; { if (t1 == null &amp;&amp; t2) { return t2; } if ((t1 &amp;&amp; t2 == null) || (t1 == null &amp;&amp; t2 == null)) { return t1; } const root=new TreeNode(t1.val + t2.val) root.left = mergeTrees(t1.left, t2.left); root.right = mergeTrees(t1.right, t2.right); return root; };","tags":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"合并二叉树","slug":"合并二叉树","permalink":"https://github.com/NollieLeo/tags/%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"算法之平衡二叉树","date":"2021-06-19T07:08:13.000Z","path":"2021/06/19/算法之平衡二叉树/","text":"110. 平衡二叉树给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。 image-20210619150948102 分解子问题：当前节点是否是平衡节点，判断依据为： 左子树高度与右子树高度之差不超过1 左节点是平衡节点 右节点是平衡节点有了思路，代码就很简单了，四行搞定 这里其中也运用了 判断二叉树的深度 的递归思想 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {boolean} */ var isBalanced = function (root) { if (!root) { return true; } return isBalanced(root.left) &amp;&amp; isBalanced(root.right) &amp;&amp; Math.abs(getSum(root.left) - getSum(root.right)) &lt;= 1 }; function getSum(node) { if (!node) { return 0; } let dep = 1; dep += Math.max(getSum(node.left), getSum(node.right)); return dep; }","tags":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"平衡二叉树","slug":"平衡二叉树","permalink":"https://github.com/NollieLeo/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"算法之二叉树的深度","date":"2021-06-19T06:48:30.000Z","path":"2021/06/19/算法之二叉树的深度/","text":"剑指 Offer 55 - I. 二叉树的深度（leecode 104）输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。 例如： 给定二叉树 [3,9,20,null,null,15,7]， image-20210619144925385 1.递归实现 思路：在存在节点的情况下，每次设置一个起始深度1，之后去遍历他的左子树和右子树找出最大层级，就像这样一个个节点去找 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number} */ var maxDepth = function (root) { if(!root){ return 0 }; let dep = 1; dep += Math.max(maxDepth(root.left), maxDepth(root.right)); return dep }; 2.栈迭代实现 思路： 通过前序遍历或者其他什么遍历，每次向栈中存储一个对象保存节点以及上面遍历过的节点深度，之后拿max值和节点深度值做Math.max比较，找出最大的深度就行，重点是每一次都需要存深度 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number} */ var maxDepth = function(root) { if (!root) return 0 let max = 0 const stack = [[root, 0]] while (stack.length) { const [node, p] = stack.pop() max = Math.max(max, p + 1) node.left &amp;&amp; stack.push([node.left, p + 1]) node.right &amp;&amp; stack.push([node.right, p + 1]) } return max };","tags":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"二叉树深度","slug":"二叉树深度","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6/"}]},{"title":"算法之对称二叉树","date":"2021-06-19T06:39:04.000Z","path":"2021/06/19/算法之对称二叉树/","text":"剑指 Offer 28. 对称的二叉树请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 image-20210619144112285 思路： 要想实现对称的二叉树需要满足： image-20210619144459361 实现： /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {boolean} */ var isSymmetric = function (root) { if (!root) { return true } return isEqual(root.left, root.right) }; const isEqual = (left, right) =&gt; { if (!left &amp;&amp; !right) { return true } if (!left || !right) { return false } if (left.val !== right.val) { return false; } return isEqual(left.left, right.right) &amp;&amp; isEqual(left.right, right.left); }","tags":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"对称二叉树","slug":"对称二叉树","permalink":"https://github.com/NollieLeo/tags/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"算法之二叉树层序遍历","date":"2021-06-19T06:16:29.000Z","path":"2021/06/19/算法之二叉树层序遍历/","text":"剑指 Offer 32 - II. 从上到下打印二叉树 II从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。 image-20210619141848957 思路： 稍微改变一下对队列的使用，就可以在遍历过程中体现出层次，大致过程如下： 初始化 queue，用于存储当前层的节点 检查 queue 是否为空 如果不为空：依次遍历当前 queue 内的所有节点，检查每个节点的左右子节点，将不为空的子节点放入 queue，继续循环 如果为空：跳出循环 /** * @param {TreeNode} root * @return {number[][]} */ var levelOrder = function(root) { if (!root) return []; const queue = [root]; const res = []; // 存放遍历结果 let level = 0; // 代表当前层数 while (queue.length) { res[level] = []; // 第level层的遍历结果 // 这里一开始我以为每层节点数量都是满的。。。然后就每层乘以2了。。。 let levelNum = queue.length; // 第level层的节点数量 while (levelNum--) { const front = queue.shift(); res[level].push(front.val); if (front.left) queue.push(front.left); if (front.right) queue.push(front.right); } level++; } return res; }; 思路2：递归 var levelOrder = function (root) { let res = []; const traversal = (root, level = 0) =&gt; { if (root) { if (!res[level]) res[level] = []; res[level].push(root.val); traversal(root.left, level + 1) traversal(root.right, level + 1) } } traversal(root); return res; };","tags":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"二叉树层序遍历","slug":"二叉树层序遍历","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"}]},{"title":"浅拷贝和深拷贝","date":"2021-06-17T09:29:37.000Z","path":"2021/06/17/浅拷贝和深拷贝/","text":"什么是拷贝？let arr = [1, 2, 3]; let newArr = arr; newArr[0] = 100; console.log(arr);//[100, 2, 3] 这是直接赋值的情况，不涉及任何拷贝。当改变newArr的时候，由于是同一个引用，arr指向的值也跟着改变。 浅拷贝上面的那个例子进行浅拷贝 let arr = [1, 2, 3]; let newArr = arr.slice(); newArr[0] = 100; console.log(arr);//[1, 2, 3] 当修改newArr的时候，arr的值并不改变。什么原因?因为这里newArr是arr浅拷贝后的结果，newArr和arr现在引用的已经不是同一块空间！！！ 这就是浅拷贝！ 但是这又会带来一个潜在的问题: let arr = [1, 2, {val: 4}]; let newArr = arr.slice(); newArr[2].val = 1000; console.log(arr);//[ 1, 2, { val: 1000 } ] 咦!不是已经不是同一块空间的引用了吗？为什么改变了newArr改变了第二个元素的val值，arr也跟着变了。 这就是浅拷贝的限制所在了。它只能拷贝一层对象。如果有对象的嵌套，那么浅拷贝将无能为力。但幸运的是，深拷贝就是为了解决这个问题而生的，它能 解决无限极的对象嵌套问题，实现彻底的拷贝。当然，这是我们下一篇的重点。 现在先让大家有一个基本的概念。 接下来，我们来研究一下JS中实现浅拷贝到底有多少种方式？ 浅拷贝API1. Object.assign但是需要注意的是，Object.assgin() 拷贝的是对象的属性的引用，而不是对象本身。 let obj = { name: &#39;sy&#39;, age: 18 }; const obj2 = Object.assign({}, obj, {name: &#39;sss&#39;}); console.log(obj2);//{ name: &#39;sss&#39;, age: 18 } 2. concat浅拷贝数组let arr = [1, 2, 3]; let newArr = arr.concat(); newArr[1] = 100; console.log(arr);//[ 1, 2, 3 ] 3. slicelet arr = [1, 2, 3]; let newArr = arr.slice(); newArr[1] = 100; console.log(arr);//[ 1, 2, 3 ] 4. …展开运算符let arr = [1, 2, 3]; let newArr = [...arr];//跟arr.slice()是一样的效果 手动实现浅拷贝const shallowClone = (target) =&gt; { if (typeof target === &#39;object&#39; &amp;&amp; target !== null) { const cloneTarget = Array.isArray(target) ? []: {}; for (let prop in target) { if (target.hasOwnProperty(prop)) { cloneTarget[prop] = target[prop]; } } return cloneTarget; } else { return target; } } 深拷贝1. JSON一套组合拳JSON.parse(JSON.stringify()); 估计这个api能覆盖大多数的应用场景，没错，谈到深拷贝，我第一个想到的也是它。但是实际上，对于某些严格的场景来说，这个方法是有巨大的坑的。问题如下： 无法解决循环引用的问题。举个例子： const a = {val:2}; a.target = a; 拷贝a会出现系统栈溢出，因为出现了无限递归的情况。 无法拷贝一写特殊的对象，诸如 RegExp, Date, Set, Map等 无法拷贝函数（划重点） 2. 简单实现只需将上面手写的浅拷贝骚做修改 function deepClone(target) { if (typeof target === &quot;object&quot; &amp;&amp; target !== null) { let temp = Array.isArray(target) ? [] : {}; for (const key in target) { if (Object.hasOwnProperty.call(target, key)) { const element = target[key]; temp[key] = deepClone(element); } } return temp; } return target; } 3. 细节以及问题处理最终实现如上所述，JSON.parse(JSON.stringfy(obj))有三个问题，我们根据这三个问题一个个解决 1.循环引用问题解决假如是这样的情况下，a对象中的一个属性有引用了自己 const a = { name: &quot;weng&quot;, age: 12, }; a.target = a; 这里我们可以使用一个Map，记录下已经拷贝过了的对象，如果已经拷贝过了，就直接返回这个对象 function deepClone(target, map = new Map()) { if (map.get(target)) { return target; } if ( (typeof target === &quot;object&quot; || typeof target === &quot;function&quot;) &amp;&amp; target !== null ) { map.set(target, true); let temp = Array.isArray(target) ? [] : {}; for (const key in target) { if (Object.hasOwnProperty.call(target, key)) { const element = target[key]; temp[key] = deepClone(element, map); } } return temp; } return target; } 好了咱们试一下 const a = { name: &quot;weng&quot;, age: 12, }; a.target = a; console.log(deepClone(a)); image-20210619073628733 好像是没有问题了, 拷贝也完成了。但还是有一个潜在的坑, 就是map 上的 key 和 map 构成了强引用关系，这是相当危险的。我给你解释一下与之相对的弱引用的概念你就明白了： 在计算机程序设计中，弱引用与强引用相对， 是指不能确保其引用的对象不会被垃圾回收器回收的引用。 一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收。 –百度百科 说的有一点绕，我用大白话解释一下，被弱引用的对象可以在任何时候被回收，而对于强引用来说，只要这个强引用还在，那么对象无法被回收。拿上面的例子说，map 和 a一直是强引用的关系， 在程序结束之前，a 所占的内存空间一直不会被释放。 怎么解决这个问题？ 很简单，让 map 的 key 和 map 构成弱引用即可。ES6给我们提供了这样的数据结构，它的名字叫WeakMap，它是一种特殊的Map, 其中的键是弱引用的。其键必须是对象，而值可以是任意的。 稍微改造一下即可: function deepClone(target, map = new Map()) { ..... } 2. 特殊对象的拷贝对于特殊的对象，我们使用以下方式来鉴别: Object.prototype.toString.call(obj);梳理一下对于可遍历对象会有什么结果： &quot;object Map&quot; &quot;object WeakMap&quot; &quot;object Set&quot; &quot;object WeakSet&quot; &quot;object Array&quot; &quot;object Object&quot; &quot;object Arguments&quot; 以及不可便利的对象 &quot;object Boolean&quot; &quot;object Symbol&quot; &quot;object Number&quot; &quot;object String&quot; &quot;object Date&quot; &quot;object Error&quot; &quot;object RegExp&quot; &quot;object Function&quot; 对于不同的对象有不同的处理方案，但是很多是相互类似的 之后改进之后的代码： function getType(target) { return Object.prototype.toString.call(target); } function isObject(target) { return typeof target === &quot;object&quot; &amp;&amp; target !== null; } function deepClone(target, map = new WeakMap()) { if (!isObject(target)) { return target; } if (map.get(target)) { return target; } // 获取target是Object的哪种衍生类型 const targetType = getType(target); let cloneTarget; map.set(target, true); const structFn = Object.getPrototypeOf(target).constructor; switch (targetType) { case &quot;[object RegExp]&quot;: const { source, flags } = target; cloneTarget = new structFn(source, flags); break; case &quot;[object Function]&quot;: // 函数这块独立出来处理 break; case &quot;[object Map]&quot;: case &quot;[object WeakMap]&quot;: cloneTarget = new structFn(); target.forEach((value, key) =&gt; { cloneTarget.set(deepClone(key), deepClone(value)); }); break; case &quot;[object Set]&quot;: case &quot;[object WeakSet]&quot;: cloneTarget = new structFn(); target.forEach((value) =&gt; { cloneTarget.add(deepClone(value)); }); break; case &quot;[object Array]&quot;: case &quot;[object Object]&quot;: cloneTarget = new structFn(); for (const key in target) { if (Object.hasOwnProperty.call(target, key)) { const element = target[key]; cloneTarget[key] = deepClone(element, map); } } break; default: // case &quot;[object String]&quot;: // case &quot;[object Number]&quot;: // case &quot;[object Boolean]&quot;: // case &quot;[object Error]&quot;: // case &quot;[object Date]&quot;: cloneTarget = new structFn(Object.prototype.valueOf.call(target)); break; } return cloneTarget; } 其中这行代码const structFn = Object.getPrototypeOf(target).constructor;是为了获取衍生对象或者对象的构造函数，是为了防止丢失原型的情况，之后利用构造函数去整活。 3. 处理函数类型虽然函数也是对象，但是它过于特殊，我们单独把它拿出来拆解。 提到函数，在JS种有两种函数，一种是普通函数，另一种是箭头函数。每个普通函数都是 Function的实例，而箭头函数不是任何类的实例，每次调用都是不一样的引用。那我们只需要 处理普通函数的情况，箭头函数直接返回它本身就好了。 那么如何来区分两者呢？ 答案是: 利用原型。箭头函数是不存在原型的。 处理代码如下： const handleFunc = (func) =&gt; { // 箭头函数直接返回自身 if(!func.prototype) return func; const bodyReg = /(?&lt;={)(.|\\n)+(?=})/m; const paramReg = /(?&lt;=\\().+(?=\\)\\s+{)/; const funcString = func.toString(); // 分别匹配 函数参数 和 函数体 const param = paramReg.exec(funcString); const body = bodyReg.exec(funcString); if(!body) return null; if (param) { const paramArr = param[0].split(&#39;,&#39;); return new Function(...paramArr, body[0]); } else { return new Function(body[0]); } } 4. 优化代码在上面的代码中，我们在处理一些”基本类型“对象的时候，我们去拿他们的构造函数，然后给他new出来，但是ES6中不推荐这样直接new String, 或者 new Number的写法，并且Symbol类型是无法被new操作符调用的，所以我们改成 new Object的形式并且传他们的value值 cloneTarget = new Object(Object.prototype.valueOf.call(target)); 最终代码 function getType(target) { return Object.prototype.toString.call(target); } function isObject(target) { return typeof target === &quot;object&quot; &amp;&amp; target !== null; } function deepClone(target, map = new WeakMap()) { if (!isObject(target)) { return target; } if (map.get(target)) { return target; } // 获取target是Object的哪种衍生类型 const targetType = getType(target); let cloneTarget; map.set(target, true); const structFn = Object.getPrototypeOf(target).constructor; switch (targetType) { case &quot;[object RegExp]&quot;: const { source, flags } = target; cloneTarget = new structFn(source, flags); break; case &quot;[object Function]&quot;: // 函数这块独立出来处理 cloneTarget = handleFunc(target); break; case &quot;[object Map]&quot;: case &quot;[object WeakMap]&quot;: cloneTarget = new structFn(); target.forEach((value, key) =&gt; { cloneTarget.set(deepClone(key), deepClone(value)); }); break; case &quot;[object Set]&quot;: case &quot;[object WeakSet]&quot;: cloneTarget = new structFn(); target.forEach((value) =&gt; { cloneTarget.add(deepClone(value)); }); break; case &quot;[object Array]&quot;: case &quot;[object Object]&quot;: cloneTarget = new structFn(); for (const key in target) { if (Object.hasOwnProperty.call(target, key)) { const element = target[key]; cloneTarget[key] = deepClone(element, map); } } break; default: cloneTarget = new Object(Object.prototype.valueOf.call(target)); break; } return cloneTarget; } const handleFunc = (func) =&gt; { // 箭头函数直接返回自身 if(!func.prototype) return func; const bodyReg = /(?&lt;={)(.|\\n)+(?=})/m; const paramReg = /(?&lt;=\\().+(?=\\)\\s+{)/; const funcString = func.toString(); // 分别匹配 函数参数 和 函数体 const param = paramReg.exec(funcString); const body = bodyReg.exec(funcString); if(!body) return null; if (param) { const paramArr = param[0].split(&#39;,&#39;); return new Function(...paramArr, body[0]); } else { return new Function(body[0]); } }","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"深拷贝与浅拷贝","slug":"深拷贝与浅拷贝","permalink":"https://github.com/NollieLeo/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"}]},{"title":"数组扁平化","date":"2021-06-16T09:04:21.000Z","path":"2021/06/16/数组扁平化/","text":"对于前端项目开发过程中，偶尔会出现层叠数据结构的数组，我们需要将多层级数组转化为一级数组（即提取嵌套数组元素最终合并为一个数组），使其内容合并且展开。那么该如何去实现呢？ 需求:多维数组=&gt;一维数组 let ary = [1, [2, [3, [4, 5]]], 6];// -&gt; [1, 2, 3, 4, 5, 6] let str = JSON.stringify(ary); 1. 调用ES6中的flat方法ary = ary.flat(Infinity); 2. replace + splitary = str.replace(/(\\[|\\])/g, &#39;&#39;).split(&#39;,&#39;) 3. replace + JSON.parsestr = str.replace(/(\\[|\\])/g, &#39;&#39;); str = &#39;[&#39; + str + &#39;]&#39;; ary = JSON.parse(str); 4. 普通递归let result = []; let fn = function(ary) { for(let i = 0; i &lt; ary.length; i++) { let item = ary[i]; if (Array.isArray(ary[i])){ fn(item); } else { result.push(item); } } } 5. 利用reduce函数迭代function flatten(ary) { return ary.reduce((pre, cur) =&gt; { return pre.concat(Array.isArray(cur) ? flatten(cur) : cur); }, []); } let ary = [1, 2, [3, 4], [5, [6, 7]]] console.log(flatten(ary)) 6：扩展运算符//只要有一个元素有数组，那么循环继续 while (ary.some(Array.isArray)) { ary = [].concat(...ary); }","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"数组扁平化","slug":"数组扁平化","permalink":"https://github.com/NollieLeo/tags/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/"}]},{"title":"forEach中怎么跳出循环","date":"2021-06-16T08:41:03.000Z","path":"2021/06/16/foreach中怎么跳出循环/","text":"总所周知：forEach是不可以跳出循环的，所以应该想办法给他跳出去 1. forEach中写try catch 使用try监视代码块，在需要中断的地方抛出异常。 let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; arr.forEach((value) =&gt; { try { if (!(value % 2)) { throw &#39;&#39;; } else { console.log(value); } } catch (error) { throw error } }); 2. 替换方法（使用every或者some替换）官方推荐方法（替换方法）：用every和some替代forEach函数。every在碰到return false的时候，中止循环。some在碰到return true的时候，中止循环 let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; arr.some((item) =&gt; { if (item % 2) { console.log(item); return false; } return true; }); let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; arr.every((item) =&gt; { if (item % 2) { console.log(item); return true; } return false; });","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"forEach","slug":"forEach","permalink":"https://github.com/NollieLeo/tags/forEach/"},{"name":"trycatch","slug":"trycatch","permalink":"https://github.com/NollieLeo/tags/trycatch/"}]},{"title":"垃圾回收与内存泄漏","date":"2021-06-15T08:59:12.000Z","path":"2021/06/15/垃圾回收与内存泄漏/","text":"1. 浏览器的垃圾回收机制（1）垃圾回收的概念垃圾回收：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。 回收机制： Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。 JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。 不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。 （2）垃圾回收的方式浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。 1）标记清除 标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。 2）引用计数 另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。 这种方法会引起循环引用的问题：例如：obj1和obj2通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，obj1和obj2还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。 function fun() { let obj1 = {}; let obj2 = {}; obj1.a = obj2; // obj1 引用 obj2 obj2.a = obj1; // obj2 引用 obj1 } 复制代码 这种情况下，就要手动释放变量占用的内存： obj1.a = null obj2.a = null 复制代码 （3）减少垃圾回收虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。 对数组进行优化： 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。 对object进行优化： 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。 对函数进行优化： 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。 2. 哪些情况会导致内存泄漏以下四种情况会造成内存的泄漏： 意外的全局变量： 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。 被遗忘的计时器或回调函数： 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。 脱离 DOM 的引用： 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。 闭包： 不合理的使用闭包，从而导致某些变量一直被留在内存当中作者：CUGGZ链接：https://juejin.cn/post/6941194115392634888来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"垃圾回收机制","slug":"垃圾回收机制","permalink":"https://github.com/NollieLeo/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"}]},{"title":"Proxy代理应用场景","date":"2021-06-15T08:55:27.000Z","path":"2021/06/15/Proxy代理应用场景/","text":"Proxy 使用场景1 增强型数组定义 enhancedArray 函数function enhancedArray(arr) { return new Proxy(arr, { get(target, property, receiver) { const range = getRange(property); const indices = range ? range : getIndices(property); const values = indices.map(function (index) { const key = index &lt; 0 ? String(target.length + index) : index; return Reflect.get(target, key, receiver); }); return values.length === 1 ? values[0] : values; }, }); function getRange(str) { var [start, end] = str.split(&quot;:&quot;).map(Number); if (typeof end === &quot;undefined&quot;) return false; let range = []; for (let i = start; i &lt; end; i++) { range = range.concat(i); } return range; } function getIndices(str) { return str.split(&quot;,&quot;).map(Number); } } 复制代码 使用 enhancedArray 函数const arr = enhancedArray([1, 2, 3, 4, 5]); console.log(arr[-1]); //=&gt; 5 console.log(arr[[2, 4]]); //=&gt; [ 3, 5 ] console.log(arr[[2, -2, 1]]); //=&gt; [ 3, 4, 2 ] console.log(arr[&quot;2:4&quot;]); //=&gt; [ 3, 4] console.log(arr[&quot;-2:3&quot;]); //=&gt; [ 4, 5, 1, 2, 3 ] 复制代码 由以上的输出结果可知，增强后的数组对象，就可以支持负数索引、分片索引等功能。除了可以增强数组之外，我们也可以使用 Proxy API 来增强普通对象。 2 增强型对象创建 enhancedObject 函数const enhancedObject = (target) =&gt; new Proxy(target, { get(target, property) { if (property in target) { return target[property]; } else { return searchFor(property, target); } }, }); let value = null; function searchFor(property, target) { for (const key of Object.keys(target)) { if (typeof target[key] === &quot;object&quot;) { searchFor(property, target[key]); } else if (typeof target[property] !== &quot;undefined&quot;) { value = target[property]; break; } } return value; } 复制代码 使用 enhancedObject 函数const data = enhancedObject({ user: { name: &quot;阿宝哥&quot;, settings: { theme: &quot;dark&quot;, }, }, }); console.log(data.user.settings.theme); // dark console.log(data.theme); // dark 复制代码 以上代码运行后，控制台会输出以下代码： dark dark 复制代码 通过观察以上的输出结果可知，使用 enhancedObject 函数处理过的对象，我们就可以方便地访问普通对象内部的深层属性。 3 创建只读的对象创建 Proxy 对象const man = { name: &quot;semlinker&quot;, }; const handler = { set: &quot;Read-Only&quot;, defineProperty: &quot;Read-Only&quot;, deleteProperty: &quot;Read-Only&quot;, preventExtensions: &quot;Read-Only&quot;, setPrototypeOf: &quot;Read-Only&quot;, }; const proxy = new Proxy(man, handler); 复制代码 使用 proxy 对象console.log(proxy.name); proxy.name = &quot;kakuqo&quot;; 复制代码 以上代码运行后，控制台会输出以下代码： semlinker proxy.name = &quot;kakuqo&quot;; ^ TypeError: &#39;Read-Only&#39; returned for property &#39;set&#39; of object &#39;#&lt;Object&gt;&#39; is not a function 复制代码 观察以上的异常信息可知，导致异常的原因是因为 handler 对象的 set 属性值不是一个函数。如果不希望抛出运行时异常，我们可以定义一个 freeze 函数： function freeze (obj) { return new Proxy(obj, { set () { return true; }, deleteProperty () { return false; }, defineProperty () { return true; }, setPrototypeOf () { return true; } }); } 复制代码 定义好 freeze 函数，我们使用数组对象来测试一下它的功能： let frozen = freeze([1, 2, 3]); frozen[0] = 6; delete frozen[0]; frozen = Object.defineProperty(frozen, 0, { value: 66 }); console.log(frozen); // [ 1, 2, 3 ] 复制代码 上述代码成功执行后，控制台会输出 [ 1, 2, 3 ]，很明显经过 freeze 函数处理过的数组对象，已经被 “冻结” 了。 4 拦截方法调用定义 traceMethodCalls 函数function traceMethodCalls(obj) { const handler = { get(target, propKey, receiver) { const origMethod = target[propKey]; // 获取原始方法 return function (...args) { const result = origMethod.apply(this, args); console.log( propKey + JSON.stringify(args) + &quot; -&gt; &quot; + JSON.stringify(result) ); return result; }; }, }; return new Proxy(obj, handler); } 复制代码 使用 traceMethodCalls 函数const obj = { multiply(x, y) { return x * y; }, }; const tracedObj = traceMethodCalls(obj); tracedObj.multiply(2, 5); // multiply[2,5] -&gt; 10 复制代码 上述代码成功执行后，控制台会输出 multiply[2,5] -&gt; 10，即我们能够成功跟踪 obj 对象中方法的调用过程。其实，除了能够跟踪方法的调用，我们也可以跟踪对象中属性的访问，具体示例如下： function tracePropAccess(obj, propKeys) { const propKeySet = new Set(propKeys); return new Proxy(obj, { get(target, propKey, receiver) { if (propKeySet.has(propKey)) { console.log(&quot;GET &quot; + propKey); } return Reflect.get(target, propKey, receiver); }, set(target, propKey, value, receiver) { if (propKeySet.has(propKey)) { console.log(&quot;SET &quot; + propKey + &quot;=&quot; + value); } return Reflect.set(target, propKey, value, receiver); }, }); } const man = { name: &quot;semlinker&quot;, }; const tracedMan = tracePropAccess(man, [&quot;name&quot;]); console.log(tracedMan.name); // GET name; semlinker console.log(tracedMan.age); // undefined tracedMan.name = &quot;kakuqo&quot;; // SET name=kakuqo 复制代码 在以上示例中，我们定义了一个 tracePropAccess 函数，该函数接收两个参数：obj 和 propKeys，它们分别表示需跟踪的目标和需跟踪的属性列表。调用 tracePropAccess 函数后，会返回一个代理对象，当我们访问被跟踪的属性时，控制台就会输出相应的访问日志。 5 隐藏属性创建 hideProperty 函数const hideProperty = (target, prefix = &quot;_&quot;) =&gt; new Proxy(target, { has: (obj, prop) =&gt; !prop.startsWith(prefix) &amp;&amp; prop in obj, ownKeys: (obj) =&gt; Reflect.ownKeys(obj).filter( (prop) =&gt; typeof prop !== &quot;string&quot; || !prop.startsWith(prefix) ), get: (obj, prop, rec) =&gt; (prop in rec ? obj[prop] : undefined), }); 复制代码 使用 hideProperty 函数const man = hideProperty({ name: &quot;阿宝哥&quot;, _pwd: &quot;www.semlinker.com&quot;, }); console.log(man._pwd); // undefined console.log(&#39;_pwd&#39; in man); // false console.log(Object.keys(man)); // [ &#39;name&#39; ] 复制代码 通过观察以上的输出结果，我们可以知道，利用 Proxy API，我们实现了指定前缀属性的隐藏。除了能实现隐藏属性之外，利用 Proxy API，我们还可以实现验证属性值的功能。 6 验证属性值创建 validatedUser 函数const validatedUser = (target) =&gt; new Proxy(target, { set(target, property, value) { switch (property) { case &quot;email&quot;: const regex = /^(([^&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+(\\.[^&lt;&gt;()\\[\\]\\\\.,;:\\s@&quot;]+)*)|(&quot;.+&quot;))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/; if (!regex.test(value)) { console.error(&quot;The user must have a valid email&quot;); return false; } break; case &quot;age&quot;: if (value &lt; 20 || value &gt; 80) { console.error(&quot;A user&#39;s age must be between 20 and 80&quot;); return false; } break; } return Reflect.set(...arguments); }, }); 复制代码 使用 validatedUser 函数let user = { email: &quot;&quot;, age: 0, }; user = validatedUser(user); user.email = &quot;semlinker.com&quot;; // The user must have a valid email user.age = 100; // A user&#39;s age must be between 20 and 80 复制代码 上述代码成功执行后，控制台会输出以下结果： The user must have a valid email A user&#39;s age must be between 20 and 80","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"proxy","slug":"proxy","permalink":"https://github.com/NollieLeo/tags/proxy/"}]},{"title":"setInterval和setTimeout优化策略","date":"2021-06-15T08:55:00.000Z","path":"2021/06/15/setInterval和setTimeout优化策略/","text":"异步编程当然少不了定时器了，常见的定时器函数有 setTimeout、setInterval、requestAnimationFrame。最常用的是setTimeout，很多人认为 setTimeout 是延时多久，那就应该是多久后执行。 其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 setTimeout 不会按期执行。当然了，可以通过代码去修正 setTimeout，从而使定时器相对准确： let period = 60 * 1000 * 60 * 2 let startTime = new Date().getTime() let count = 0 let end = new Date().getTime() + period let interval = 1000 let currentInterval = interval function loop() { count++ // 代码执行所消耗的时间 let offset = new Date().getTime() - (startTime + count * interval); let diff = end - new Date().getTime() let h = Math.floor(diff / (60 * 1000 * 60)) let hdiff = diff % (60 * 1000 * 60) let m = Math.floor(hdiff / (60 * 1000)) let mdiff = hdiff % (60 * 1000) let s = mdiff / (1000) let sCeil = Math.ceil(s) let sFloor = Math.floor(s) // 得到下一次循环所消耗的时间 currentInterval = interval - offset console.log(&#39;时：&#39;+h, &#39;分：&#39;+m, &#39;毫秒：&#39;+s, &#39;秒向上取整：&#39;+sCeil, &#39;代码执行时间：&#39;+offset, &#39;下次循环间隔&#39;+currentInterval) setTimeout(loop, currentInterval) } setTimeout(loop, currentInterval) 接下来看 setInterval，其实这个函数作用和 setTimeout 基本一致，只是该函数是每隔一段时间执行一次回调函数。 通常来说不建议使用 setInterval。第一，它和 setTimeout 一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题，请看以下伪代码 function demo() { setInterval(function(){ console.log(2) },1000) sleep(2000) } demo() 以上代码在浏览器环境中，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。 如果有循环定时器的需求，其实完全可以通过 requestAnimationFrame 来实现： function setInterval(callback, interval) { let timer const now = Date.now let startTime = now() let endTime = startTime const loop = () =&gt; { timer = window.requestAnimationFrame(loop) endTime = now() if (endTime - startTime &gt;= interval) { startTime = endTime = now() callback(timer) } } timer = window.requestAnimationFrame(loop) return timer } let a = 0 setInterval(timer =&gt; { console.log(1) a++ if (a === 3) cancelAnimationFrame(timer) }, 1000) 首先 requestAnimationFrame 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题，当然你也可以通过该函数来实现 setTimeout。","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"requestAnimationFrame","slug":"requestAnimationFrame","permalink":"https://github.com/NollieLeo/tags/requestAnimationFrame/"},{"name":"setInterval","slug":"setInterval","permalink":"https://github.com/NollieLeo/tags/setInterval/"},{"name":"setTimeout","slug":"setTimeout","permalink":"https://github.com/NollieLeo/tags/setTimeout/"},{"name":"异步","slug":"异步","permalink":"https://github.com/NollieLeo/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"算法之二叉树的3种遍历","date":"2021-06-14T08:15:16.000Z","path":"2021/06/14/算法之二叉树的3种遍历/","text":"一. 前序遍历（中左右）144.二叉树前序遍历 image-20210614161741801 1. 递归实现按照中间节点先遍历，在遍历左右节点 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ var preorderTraversal = function (root) { let number = []; getNode(root, number); return number; }; const getNode = (node, number) =&gt; { if (node) { number.push(node.val); if (node.left) { getNode(node.left, number) } if (node.right) { getNode(node.right, number); } } } 2. 迭代实现以显示栈的方式模仿递归。 初始化栈，并将根节点入栈； 当栈不为空时： 弹出栈顶元素 n，并将值添加到结果中 如果 n 的右节点存在，入栈 如果 n 的左节点存在，入栈 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ var preorderTraversal = function (root) { let number = []; let stack = [root]; while (stack.length) { const current = stack.shift(); if(current){ number.push(current.val); if(current.right){ stack.unshift(current.right) } if(current.left){ stack.unshift(current.left); } } } return number; }; 二. 中序遍历（左中右）1. 递归实现先左节点，然后中间节点，之后右节点 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ var inorderTraversal = function (root) { const number = []; getNode(root, number); return number }; const getNode = (node, number) =&gt; { if (node &amp;&amp; node.left) { getNode(node.left, number) } node &amp;&amp; number.push(node.val); if (node &amp;&amp; node.right) { getNode(node.right, number) } } 2. 迭代实现原理： image-20210614165726412 image-20210614165746953 image-20210614165812531 代码一： const inorderTraversal = (root) =&gt; { const res = []; const stack = []; while (root) { // 能压入栈的左子节点都压进来 stack.push(root); root = root.left; } while (stack.length) { let node = stack.pop(); // 栈顶的节点出栈 res.push(node.val); // 在压入右子树之前，处理它的数值部分（因为中序遍历） node = node.right; // 获取它的右子树 while (node) { // 右子树存在，执行while循环 stack.push(node); // 压入当前root node = node.left; // 不断压入左子节点 } } return res; }; 代码二： /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ var inorderTraversal = function (root) { const number = []; let stack = []; let tempNode = root; while(tempNode || stack.length){ if(tempNode){ stack.unshift(tempNode); tempNode = tempNode.left; }else{ tempNode = stack.shift(); number.push(tempNode.val); tempNode = tempNode.right } } return number; }; 三. 后序遍历1. 递归方式左右中 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ var postorderTraversal = function(root) { let number = []; getNode(root,number); return number; }; const getNode = (node, number)=&gt;{ if(node &amp;&amp; node.left){ getNode(node.left, number); } if(node &amp;&amp; node.right){ getNode(node.right, number) } node &amp;&amp; number.push(node.val); } 2. 迭代方式先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图： image-20210614173144699 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ const postorderTraversal = (root) =&gt; { const res = []; const stack = [root]; while(stack.length &gt; 0) { const node = stack.pop() node &amp;&amp; res.unshift(node.val) if(node?.left) { stack.push(node.left) } if(node?.right) { stack.push(node.right) } } return res }","tags":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"前序遍历","slug":"前序遍历","permalink":"https://github.com/NollieLeo/tags/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"中序遍历","slug":"中序遍历","permalink":"https://github.com/NollieLeo/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"后序遍历","slug":"后序遍历","permalink":"https://github.com/NollieLeo/tags/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"迭代","slug":"迭代","permalink":"https://github.com/NollieLeo/tags/%E8%BF%AD%E4%BB%A3/"}]},{"title":"算法之三数之和","date":"2021-06-14T07:28:27.000Z","path":"2021/06/14/算法之三数之和/","text":"15.三数之和 image-20210614161328925 思路： image-20210614161237056 /** * @param {number[]} nums * @return {number[][]} */ var threeSum = function(nums) { let ans = []; const len = nums.length; if(nums == null || len &lt; 3) return ans; nums.sort((a, b) =&gt; a - b); // 排序 for (let i = 0; i &lt; len ; i++) { if(nums[i] &gt; 0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环 if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; // 去重 let L = i+1; let R = len-1; while(L &lt; R){ const sum = nums[i] + nums[L] + nums[R]; if(sum == 0){ ans.push([nums[i],nums[L],nums[R]]); while (L&lt;R &amp;&amp; nums[L] == nums[L+1]) L++; // 去重 while (L&lt;R &amp;&amp; nums[R] == nums[R-1]) R--; // 去重 L++; R--; } else if (sum &lt; 0) L++; else if (sum &gt; 0) R--; } } return ans; };","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"双指针","slug":"双指针","permalink":"https://github.com/NollieLeo/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"算法之赎金信","date":"2021-06-14T06:57:24.000Z","path":"2021/06/14/算法之赎金信/","text":"383.赎金信 给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。 (题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。) image-20210614151820684 1.哈希表 思路： 首先我们遍历一遍magazine的值，将其中的字符当成key存入对象中，每出现一次就将其加1，之后遍历ransomNode，如果其中的值不存在就返回false，存在就将对象中key对应的值-1，如果减完之后为0，则删除这个key，直到遍历结束 /** * @param {string} ransomNote * @param {string} magazine * @return {boolean} */ var canConstruct = function(ransomNote, magazine) { const obj = {}; for(let i = 0; i&lt;magazine.length;i++){ if(magazine[i] in obj){ obj[magazine[i]]++; }else{ obj[magazine[i]]=1; } } for(let j= 0; j&lt;ransomNote.length; j++){ if(ransomNote[j] in obj){ obj[ransomNote[j]]--; if(obj[ransomNote[j]] === 0){ delete obj[ransomNote[j]]; } }else{ return false; } } return true; }; 2.一层for循环 遍历ransomNode，只要magazine中有这个值，就把magazine中的这个值给删掉，每次遍历都去更新magazine的值，如果找不到就说明不能构成，遍历结束。 /** * @param {string} ransomNote * @param {string} magazine * @return {boolean} */ var canConstruct = function (ransomNote, magazine) { for (let i = 0; i &lt; ransomNote.length; i++) { if (magazine.indexOf(ransomNote[i]) === -1) { return false; } magazine = magazine.replace(ransomNote[i], &quot;&quot;); } return true; };","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"哈希表","slug":"哈希表","permalink":"https://github.com/NollieLeo/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"算法之四数之和Ⅱ","date":"2021-06-14T06:48:40.000Z","path":"2021/06/14/算法之四数之和Ⅱ/","text":"454.四数字相加Ⅱ 给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。 为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。 image-20210614145011013 思路： 四个数之和咱们可以给他转换成2数之和，这里因为是4个数组，两两组合，之后用Map存储和值，因为既然要 使得 A[i] + B[j] + C[k] + D[l] = 0,换个思路就是使得 A[i] + B[j] = -C[k] - D[l]，AB一组遍历存键值，CD再去遍历找到键值相等的，那就是一组，或者多组，因为AB可能有多种情况，CD也是 /** * @param {number[]} A * @param {number[]} B * @param {number[]} C * @param {number[]} D * @return {number} */ var fourSumCount = function (A, B, C, D) { let h = new Map() let r = 0 //遍历前两个参数，在map中以键值对方式添加所有可能的值 //key值为-（a+b），当C D数组中的c+d=-（a+b）时候，说明组合起来会是0 //key值存在的时候就+1，不存在就set为1 for (var a of A) { for (var b of B) { if (h.get(0 - a - b)) { h.set(0 - a - b, h.get(0 - a - b) + 1) } else { h.set(0 - a - b, 1) } } } //C D中的值有匹配的话就在返回结果中加上key对应的value for (var c of C) { for (var d of D) { if (h.has(c + d)) { r += h.get(c + d) } } } return r };","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"哈希表","slug":"哈希表","permalink":"https://github.com/NollieLeo/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"算法之两数之和","date":"2021-06-13T09:18:10.000Z","path":"2021/06/13/算法之两数之和/","text":"1.两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 image-20210613172218604 思路： 根据题意，如果我们使用暴破，会导致时间复杂度为 n^2 ，这样的代价无疑是很大的。 所以我们很容易想到用哈希表来解决这个问题。 我们遍历到数字 a 时，用 target 减去 a，就会得到 b，若 b 存在于哈希表中，我们就可以直接返回结果了。若b 不存在，那么我们需要将 a 存入哈希表，好让后续遍历的数字使用。 image-20210613172111162 image-20210613172123173 image-20210613172134297 /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { let obj = {}; let i = 0; while(i &lt; nums.length){ let sum = target - nums[i]; if(sum in obj){ return [i, obj[sum]] } obj[nums[i]] = i; i++; } };","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"哈希表","slug":"哈希表","permalink":"https://github.com/NollieLeo/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"算法之快乐数","date":"2021-06-13T09:02:36.000Z","path":"2021/06/13/算法之快乐数/","text":"202.快乐数 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」定义为： 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。如果 n 是快乐数就返回 true ；不是，则返回 false 。 image-20210613171549533 思路: 1.哈希表 每次都去拆分数字计算平方和，如果和为1，就是快乐数，如果不唯一就存在Map里头。 后面计算发现，如果说不是快乐数得话，计算的值可能会回到之前计算的某个值，也就是Map里头，所以如果说计算的结果，map里头存在，那么说明不是快乐树 /** * @param {number} n * @return {boolean} */ function sum(n) { n = n + &#39;&#39; let sum = 0 for (let num of n) { sum += num * num } return sum } var isHappy = function (n) { let res = sum(n) let obj = {} while (res != 1) { if (res in obj) return false obj[res] = 1 res = sum(res) } return true } 2.快慢指针 根据题意，我们可以分析如下： 找到快乐数没有快乐数，形成环路，造成死循环。其实分析是很容易的，接下来我们看看，如何解题。 首先，我们肯定可以使用哈希表记录过程值，若找到 11，皆大欢喜。 如果在找的过程中，哈希表中已存在当前数，则证明进入了环路，也就是死循环了！ 此时，我们就可以判断当前数不是一个快乐数了~ 但是，为了降低空间复杂度，我们选择使用快慢指针来解决，流程如下： 创建一个慢指针，一次走一步，再创建一个快指针，一次走两步。当快慢指针相遇，代表形参环路，该数不是快乐数。若指针移动过程中，找到了 11，则当前数是一个快乐数。 image-20210613170644838 image-20210613170717617 image-20210613170728576 image-20210613170747791 image-20210613170758347 image-20210613170816336 image-20210613170827279 image-20210613170838148 image-20210613171129939 let getNext = function (n) { return n.toString().split(&#39;&#39;).map(i =&gt; i ** 2).reduce((a, b) =&gt; a + b); } let isHappy = function (n) { let slow = n; let fast = getNext(n); while(fast !== 1 &amp;&amp; fast !== slow){ slow = getNext(slow); fast = getNext(getNext(fast)); } return fast === 1; };","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"哈希表","slug":"哈希表","permalink":"https://github.com/NollieLeo/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"快慢指针","slug":"快慢指针","permalink":"https://github.com/NollieLeo/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"},{"name":"环形链表","slug":"环形链表","permalink":"https://github.com/NollieLeo/tags/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"}]},{"title":"算法之链表相交","date":"2021-06-13T08:48:30.000Z","path":"2021/06/13/算法之链表相交/","text":"面试题 02.07.链表相交 image-20210613164949653 解题思路： 1.假设两个链表相交于A，由于两个链表都是单向链表，所以A后面的所有节点都是两个链表的公共部分。现在要找它们第一个公共节点，如果可以从后往前找，则找到两个链表第一个不相同的节点，其后的节点即为所求。但链表的特点导致其更适合从前向后遍历，如果要从后往前一个个比较，则每次都要从头扫描找到合适位置的节点再进行比较（最多扫描N趟，平均扫描N/2趟，其中N为链表长度），这样时间复杂度会很高，是平方级的时间复杂度。要想从后往前一个个比较，又不需要每次从头扫描，可以考虑把两个链表的节点分别依次放入两个栈中，这样栈顶的元素便是其最后的节点，逐个出栈并进行比较，即可得到结果。不过这样做需要引入两个栈，而栈的空间复杂度为线性级。这相当于用空间换时间。最后，再仔细分析一下为什么不能从头开始扫描两个链表并用于比较，这是因为两个链表的长度不一样，如果两个链表的长度一样，则由于其公共节点个数一样，所以不相同节点数目也一样，这样完全可以从头扫描并进行比较。但实际给定的两个链表并不一定长度相同，这时可以先让较长的链表走上k(k为长链表与短链表的差值)步，在依次比较两个链表的节点，这样便可以不使用复杂的数据结构，从而保证常量级的空间复杂度。同时，由于用这种方法只需扫描两个链表最多两趟，因此时间复杂度为线性级。 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} headA * @param {ListNode} headB * @return {ListNode} */ var getIntersectionNode = function (headA, headB) { let headALen = 0; let p = headA; while (p) { headALen++; p = p.next; } let headBLen = 0; let q = headB; while (q) { headBLen++; q = q.next; } if (headALen &lt; headBLen) { p = headA; headA = headB; headB = p; [headALen, headBLen] = [headBLen, headALen]; } while (headALen - headBLen) { headA = headA.next; headALen--; } while (headA &amp;&amp; headB) { if (headA === headB) { return headA; } headA = headA.next; headB = headB.next; } return null; }; 2.两个指针最多走过headA链表长度 + headB链表长度的距离 如果相交，会提前相遇在相交节点。此时返回相交节点。如果不相交，则各自走过headA链表长度 + headB链表长度的距离，指向null。此时返回null. /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} headA * @param {ListNode} headB * @return {ListNode} */ var getIntersectionNode = function(headA, headB) { var p1 = headA, p2 = headB; while (p1 != p2) { p1 = p1 ? p1.next : headB; p2 = p2 ? p2.next : headA; } return p1; };","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://github.com/NollieLeo/tags/%E9%93%BE%E8%A1%A8/"},{"name":"快慢指针","slug":"快慢指针","permalink":"https://github.com/NollieLeo/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"}]},{"title":"算法之只出现一次的数字","date":"2021-06-13T08:29:03.000Z","path":"2021/06/13/算法之只出现一次的数字/","text":"136.给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ image-20210613163443078 解法： 1.哈希表 简单不接受，需要开辟新空间 2.逻辑运算符 /** * @param {number[]} nums * @return {number} */ var singleNumber = function (nums) { for (let i = 0, l = nums.length; i &lt; l; i++) { nums[i + 1] = nums[i] ^ nums[i + 1]; } return nums[nums.length - 1]; }; 思路： 逻辑 或非 运算符的特点就是，某个数或非本事就是 0，0或非任意数都是任意数 再不开辟新空间的情况下，根据数组特点我们知道，除了那个一次出现的数据，其他都是成双的 那我们把相邻两数 或非 运算的结果赋值给下一个，不断的或非下去，最终得到的最后一位数，就是出现一次的数","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"哈希表","slug":"哈希表","permalink":"https://github.com/NollieLeo/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"逻辑运算符","slug":"逻辑运算符","permalink":"https://github.com/NollieLeo/tags/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/"}]},{"title":"算法之环形链表2","date":"2021-06-13T08:08:49.000Z","path":"2021/06/13/算法之环形链表2/","text":"142.给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 说明：不允许修改给定的链表。 进阶： 你是否可以使用 O(1) 空间解决此题？ image-20210613161001882 解法： 1.哈希表 var detectCycle = function(head) { //建立一个Set，如果有重复的，就说明是环。 const memo = new Set() while(head){ if(memo.has(head)){ return head }else{ memo.add(head) } head = head.next } return null; }; 2.快慢指针 var detectCycle = function(head) { let fast = head, slow = head; do{ //检查是否有环 + 寻找相遇点 encounter point if(!fast || !fast.next) return null; fast = fast.next.next slow = slow.next }while(fast != slow) fast = head; //寻找入口 entrance //为什么这能寻找入口，请看下图 while(fast != slow){ fast = fast.next slow = slow.next } return fast; }; 复杂度分析时间复杂度：O(N)空间复杂度：O(1)有一个快指针fast，慢指针slow；快指针一次走两步，慢指针一次走一步；在有环的情况下，他们俩会在encounter相遇。相遇的时候有(Nfast - 2Nslow) * L = Path + E通过Lucifer的例子，我们得知(Nfast - 2Nslow) 只要是个整数，就不会影响encounter在环上的位置，所以我们能推导出:Path = L - E (就是那俩蓝色的地方)这时候fast再从head开始走，slow从encounter走，他们俩每个都走一步，遇见的时候就刚好在环的入口。","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://github.com/NollieLeo/tags/%E9%93%BE%E8%A1%A8/"},{"name":"哈希表","slug":"哈希表","permalink":"https://github.com/NollieLeo/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"环形链表","slug":"环形链表","permalink":"https://github.com/NollieLeo/tags/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"}]},{"title":"算法之环形链表1","date":"2021-06-13T07:58:09.000Z","path":"2021/06/13/算法之环形链表1/","text":"141.给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回 true 。 否则，返回 false 。 你能用 O(1)（即，常量）内存解决此问题吗？ image-20210613160243446 解题思路： 1.快慢指针 两个人在圆形操场上的起点同时起跑，速度快的人一定会超过速度慢的人一圈。 用一块一慢两个指针遍历链表，如果指针能够相逢，那么链表就有圈。 用一块一慢两个指针遍历链表，如果指针能够相逢，就返回true 遍历结束后，还没有相逢就返回false var hasCycle = function(head) { let p1 = head; let p2 = head; while(p1 &amp;&amp; p2 &amp;&amp; p2.next) { p1 = p1.next p2 = p2.next.next if(p1 === p2) { return true; } } return false; }; 2.标记法 标记法给遍历过的节点打记号，如果遍历过程中遇到有记号的说明已环🤓 const hasCycle = function(head) { while (head) { if (head.tag) { return true; } head.tag = true; head = head.next; } return false; };","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://github.com/NollieLeo/tags/%E9%93%BE%E8%A1%A8/"},{"name":"环形链表","slug":"环形链表","permalink":"https://github.com/NollieLeo/tags/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"}]},{"title":"算法之删除链表的倒数第N个节点","date":"2021-06-13T07:35:20.000Z","path":"2021/06/13/算法之删除链表的倒数第N个节点/","text":"19.给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 进阶：你能尝试使用一趟扫描实现吗？ image-20210613153633327 思路： 双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。 定义fast指针和slow指针，初始值为虚拟头结点，如图： fast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作），如图： fast和slow同时移动，之道fast指向末尾，如题： 删除slow指向的下一个节点，如图： 解题： /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @param {number} n * @return {ListNode} */ var removeNthFromEnd = function (head, n) { let preNode = new ListNode(); preNode.next = head; let fast = preNode; let slow = preNode; while (n--) { fast = fast.next; } while (fast.next) { fast = fast.next; slow = slow.next; } slow.next = slow.next.next; return preNode.next; };","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://github.com/NollieLeo/tags/%E9%93%BE%E8%A1%A8/"},{"name":"快慢指针","slug":"快慢指针","permalink":"https://github.com/NollieLeo/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"}]},{"title":"算法之最小栈","date":"2021-06-13T07:24:44.000Z","path":"2021/06/13/算法之最小栈/","text":"设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。pop() —— 删除栈顶的元素。top() —— 获取栈顶元素。getMin() —— 检索栈中的最小元素。 示例: 输入： [&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;] [[],[-2],[0],[-3],[],[],[],[]] 输出： [null,null,null,null,-3,null,0,-2] 解释： MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --&gt; 返回 -3. minStack.pop(); minStack.top(); --&gt; 返回 0. minStack.getMin(); --&gt; 返回 -2.。 图解： image-20210613153021619 image-20210613153039502 image-20210613153308874 image-20210613153321255 image-20210613153341392 image-20210613153354301 image-20210613153406440 image-20210613153418555 题解： /** * initialize your data structure here. */ var MinStack = function() { this.x_stack = []; this.min_stack = [Infinity]; }; MinStack.prototype.push = function(x) { this.x_stack.push(x); this.min_stack.push(Math.min(this.min_stack[this.min_stack.length - 1], x)); }; MinStack.prototype.pop = function() { this.x_stack.pop(); this.min_stack.pop(); }; MinStack.prototype.top = function() { return this.x_stack[this.x_stack.length - 1]; }; MinStack.prototype.getMin = function() { return this.min_stack[this.min_stack.length - 1]; }; /** * Your MinStack object will be instantiated and called as such: * var obj = new MinStack() * obj.push(val) * obj.pop() * var param_3 = obj.top() * var param_4 = obj.getMin() */","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"栈","slug":"栈","permalink":"https://github.com/NollieLeo/tags/%E6%A0%88/"}]},{"title":"算法之两两交换链表中节点","date":"2021-06-13T07:20:43.000Z","path":"2021/06/13/算法之两两交换链表中节点/","text":"给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 image-20210613152137809 题解： /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var swapPairs = function(head) { if(!head || !head.next){ return head }; let header = new ListNode(); header.next = head let vnode = header; while(head &amp;&amp; head.next){ const temp = head.next; head.next = head.next.next; temp.next = head; vnode.next = temp; vnode = head; head = head.next; } return header.next; };","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://github.com/NollieLeo/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"算法之反转链表","date":"2021-06-13T07:00:44.000Z","path":"2021/06/13/算法之反转链表/","text":"206.给你单链表的头节点 head,请你反转链表，并返回反转后的链表 image-20210613150413850 迭代解法： if(!head){ return head; } const virsualNode = new ListNode(); virsualNode.next = head; while(head.next){ let temp = head.next; head.next = head.next.next; temp.next = virsualNode.next; virsualNode.next = temp; } return virsualNode.next","tags":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://github.com/NollieLeo/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"手写Promise","date":"2021-06-13T05:20:58.000Z","path":"2021/06/13/手写Promise/","text":"暂未整理，先附上代码 class _Promise { constructor(excutor) { this.state = &quot;pending&quot;; this.resolveInfo = undefined; this.rejectInfo = undefined; this.resolveCb = []; this.rejectCb = []; const resolve = (value) =&gt; { if (this.state === &quot;pending&quot;) { this.state = &quot;fullfilled&quot;; this.resolveInfo = value; this.resolveCb.forEach((fn) =&gt; { fn(this.resolveInfo); }); } }; const reject = (value) =&gt; { if (this.state === &quot;pending&quot;) { this.state = &quot;rejected&quot;; this.rejectInfo = value; this.rejectCb.forEach((fn) =&gt; { fn(this.rejectInfo); }); } }; try { excutor(resolve, reject); } catch (error) { reject(error); } } then(onFullfilled, onRejected) { const innerPromise = new _Promise((resolve, reject) =&gt; { if (this.state === &quot;fullfilled&quot;) { setTimeout(() =&gt; { try { const returnValue = typeof onFullfilled === &quot;function&quot; ? onFullfilled(this.resolveInfo) : (value) =&gt; value; _Promise.resolvePromise.apply( innerPromise, returnValue, resolve, reject ); } catch (error) { reject(error); } }, 0); } if (this.state === &quot;rejected&quot;) { setTimeout(() =&gt; { try { const returnValue = typeof onRejected === &quot;function&quot; ? onRejected(this.rejectInfo) : (value) =&gt; value; _Promise.resolvePromise.apply( innerPromise, returnValue, resolve, reject ); } catch (error) { reject(error); } }, 0); } if (this.state === &quot;pending&quot;) { this.resolveCb.push(() =&gt; { setTimeout(() =&gt; { try { const returnValue = typeof onFullfilled === &quot;function&quot; ? onFullfilled(this.resolveInfo) : (value) =&gt; value; _Promise.resolvePromise.apply( innerPromise, returnValue, resolve, reject ); } catch (error) { reject(error); } }, 0); }); this.rejectCb.push(() =&gt; { setTimeout(() =&gt; { try { const returnValue = typeof onRejected === &quot;function&quot; ? onRejected(this.rejectInfo) : (value) =&gt; value; _Promise.resolvePromise.apply( innerPromise, returnValue, resolve, reject ); } catch (error) { reject(error); } }, 0); }); } }); return innerPromise; } static resolvePromise(newPromise, returnValue, resolve, reject) { if (newPromise === returnValue) { return reject(new Error(&quot;不能重复引用&quot;)); } // 防止多次调用 let called; if ( returnValue instanceof _Promise &amp;&amp; typeof returnValue.then === &quot;function&quot; ) { returnValue.then( (innerResolveMsg) =&gt; { if (called) return; called = true; resolvePromise(newPromise, innerResolveMsg, resolve, reject); }, (innerRejectedMsg) =&gt; { if (called) return; called = true; resolvePromise(newPromise, innerRejectedMsg, resolve, reject); } ); } else { resolve(returnValue); } } } 目前只实现了then方法，后续还有resolve,reject,catch, all, race, finally","tags":[{"name":"promise","slug":"promise","permalink":"https://github.com/NollieLeo/tags/promise/"},{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"宏任务和微任务","date":"2021-06-10T08:28:30.000Z","path":"2021/06/10/宏任务和微任务/","text":"宏任务(macrotask)在ECMAScript中，macrotask也被称为task 我们可以将每次执行栈执行的代码当做是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)， 每一个宏任务会从头到尾执行完毕，不会执行其他 由于JS引擎线程和GUI渲染线程是互斥的关系，浏览器为了能够使宏任务和DOM任务有序的进行，会在一个宏任务执行结果后，在下一个宏任务执行前，GUI渲染线程开始工作，对页面进行渲染 宏任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; ... 复制代码常见的宏任务 主代码块 setTimeout setInterval setImmediate ()-Node requestAnimationFrame ()-浏览器 微任务(microtask)ES6新引入了Promise标准，同时浏览器实现上多了一个microtask微任务概念，在ECMAScript中，microtask也被称为jobs 我们已经知道宏任务结束后，会执行渲染，然后执行下一个宏任务， 而微任务可以理解成在当前宏任务执行后立即执行的任务 当一个宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完 宏任务 -&gt; 微任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; ... 常见微任务 process.nextTick ()-Node Promise.then() catch finally Object.observe MutationObserver 简单区分宏任务与微任务看了上述宏任务微任务的解释你可能还不太清楚，没关系，往下看，先记住那些常见的宏微任务即可 我们通过几个例子来看，这几个例子思路来自掘金云中君的文章参考链接【14】，通过渲染背景颜色来区分宏任务和微任务，很直观，我觉得很有意思，所以这里也用这种例子 找一个空白的页面，在console中输入以下代码 document.body.style = &#39;background:black&#39;; document.body.style = &#39;background:red&#39;; document.body.style = &#39;background:blue&#39;; document.body.style = &#39;background:pink&#39;; 我们看到上面动图背景直接渲染了粉红色，根据上文里讲浏览器会先执行完一个宏任务，再执行当前执行栈的所有微任务，然后移交GUI渲染，上面四行代码均属于同一次宏任务，全部执行完才会执行渲染，渲染时GUI线程会将所有UI改动优化合并，所以视觉上，只会看到页面变成粉红色 再接着看 document.body.style = &#39;background:blue&#39;; setTimeout(()=&gt;{ document.body.style = &#39;background:black&#39; },200) 上述代码中，页面会先卡一下蓝色，再变成黑色背景，页面上写的是200毫秒，大家可以把它当成0毫秒，因为0毫秒的话由于浏览器渲染太快，录屏不好捕捉，我又没啥录屏慢放的工具，大家可以自行测试的，结果也是一样，最安全的方法是写一个index.html文件，在这个文件中插入上面的js脚本，然后浏览器打开，谷歌下使用控制台中performance功能查看一帧一帧的加载最为恰当，不过这样录屏不好录所以。。。 回归正题，之所以会卡一下蓝色，是因为以上代码属于两次宏任务，第一次宏任务执行的代码是将背景变成蓝色，然后触发渲染，将页面变成蓝色，再触发第二次宏任务将背景变成黑色 再来看 document.body.style = &#39;background:blue&#39; console.log(1); Promise.resolve().then(()=&gt;{ console.log(2); document.body.style = &#39;background:pink&#39; }); console.log(3); 控制台输出 1 3 2 , 是因为 promise 对象的 then 方法的回调函数是异步执行，所以 2 最后输出 页面的背景色直接变成粉色，没有经过蓝色的阶段，是因为，我们在宏任务中将背景设置为蓝色，但在进行渲染前执行了微任务， 在微任务中将背景变成了粉色，然后才执行的渲染 微任务宏任务注意点 浏览器会先执行一个宏任务，紧接着执行当前执行栈产生的微任务，再进行渲染，然后再执行下一个宏任务 微任务和宏任务不在一个任务队列，不在一个任务队列 例如setTimeout是一个宏任务，它的事件回调在宏任务队列，Promise.then()是一个微任务，它的事件回调在微任务队列，二者并不是一个任务队列 以Chrome 为例，有关渲染的都是在渲染进程中执行，渲染进程中的任务（DOM树构建，js解析…等等）需要主线程执行的任务都会在主线程中执行，而浏览器维护了一套事件循环机制，主线程上的任务都会放到消息队列中执行，主线程会循环消息队列，并从头部取出任务进行执行，如果执行过程中产生其他任务需要主线程执行的，渲染进程中的其他线程会把该任务塞入到消息队列的尾部，消息队列中的任务都是宏任务 微任务是如何产生的呢？当执行到script脚本的时候，js引擎会为全局创建一个执行上下文，在该执行上下文中维护了一个微任务队列，当遇到微任务，就会把微任务回调放在微队列中，当所有的js代码执行完毕，在退出全局上下文之前引擎会去检查该队列，有回调就执行，没有就退出执行上下文，这也就是为什么微任务要早于宏任务，也是大家常说的，每个宏任务都有一个微任务队列（由于定时器是浏览器的API，所以定时器是宏任务，在js中遇到定时器会也是放入到浏览器的队列中） 图解宏任务和微任务 img 首先执行一个宏任务，执行结束后判断是否存在微任务 有微任务先执行所有的微任务，再渲染，没有微任务则直接渲染 然后再接着执行下一个宏任务 完整的Event loop 首先，整体的script(作为第一个宏任务)开始执行的时候，会把所有代码分为同步任务、异步任务两部分 同步任务会直接进入主线程依次执行 异步任务会再分为宏任务和微任务 宏任务进入到Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中 微任务也会进入到另一个Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中 当主线程内的任务执行完毕，主线程为空时，会检查微任务的Event Queue，如果有任务，就全部执行，如果没有就执行下一个宏任务 上述过程会不断重复，这就是Event Loop，比较完整的事件循环","tags":[{"name":"Event Loop","slug":"Event-Loop","permalink":"https://github.com/NollieLeo/tags/Event-Loop/"},{"name":"浏览器","slug":"浏览器","permalink":"https://github.com/NollieLeo/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"js引擎","slug":"js引擎","permalink":"https://github.com/NollieLeo/tags/js%E5%BC%95%E6%93%8E/"},{"name":"宏任务和微任务","slug":"宏任务和微任务","permalink":"https://github.com/NollieLeo/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/"},{"name":"事件循环","slug":"事件循环","permalink":"https://github.com/NollieLeo/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"}]},{"title":"Event Loop轮询处理线程","date":"2021-06-10T08:12:17.000Z","path":"2021/06/10/Event-Loop轮询处理线程/","text":"首先要明白， js代码里头 有同步的任务，是由JS引擎线程处理，也就是主线程，同步任务都在主线程(这里的主线程就是JS引擎线程)上执行 ，形成一个执行栈 js代码里头 有异步的任务，各种各样的异步任务，各种各样的异步任务在各个对应的线程中进行处理，比如settimeout异步任务就在定时触发器线程中处理，ajax，fetch这些的js库的本质的请求代码是由异步http请求线程处理的。 主线程，之外还有一个 任务队列，这个任务队列归 事件触发线程 管， 只要异步任务有了运行结果 ，就在这个任务队列中加一个它的事件回调。 一旦执行栈中的所有同步任务执行完毕(也就是JS引擎线程空闲了)，系统就会读取任务队列，将可运行的异步任务(任务队列中的事件回调，只要任务队列中有事件回调，就说明可以执行)添加到执行栈中，开始执行 这个过程可以简单概括为，上面这3个东西之间的交流，他们交流的中介，就是 EventLoop轮询处理线程 ， 既然叫轮询了，那么肯定是不断的循环的去交流和沟通 看一段代码 let setTimeoutCallBack = function() { console.log(&#39;我是定时器回调&#39;); }; let httpCallback = function() { console.log(&#39;我是http请求回调&#39;); } // 同步任务 console.log(&#39;我是同步任务1&#39;); // 异步定时任务 setTimeout(setTimeoutCallBack,1000); // 异步http请求任务 ajax.get(&#39;/info&#39;,httpCallback); // 同步任务 console.log(&#39;我是同步任务2&#39;); JS是按照顺序从上往下依次执行的，可以先理解为这段代码时的执行环境就是主线程，也就是也就是当前执行栈 以下是顺序 执行console.log(&#39;我是同步任务1&#39;) ，主线程中运行 接着，执行到setTimeout时会 移交给定时触发器线程 ，通知定时触发器线程 1s 后将 setTimeoutCallBack 这个回调交给事件触发线程处理 在 1s 后事件触发线程会收到 setTimeoutCallBack 这个回调并把它加入到事件触发线程所管理的事件队列中等待执行 执行http请求 移交给异步http请求线程发送网络请求 请求成功后将 httpCallback 这个回调交由事件触发线程处理，事件触发线程收到 httpCallback 这个回调后把它加入到事件触发线程所管理的事件队列中等待执行 执行console.log(&#39;我是同步任务2&#39;) 主线程执行栈中执行完毕 ，JS引擎已经空闲了， 向事件触发线程发起询问，询问事件触发线程的事件队列中是否有需要执行的回调函数 如果有将事件队列中的回调事件加入执行栈中，开始执行回调 如果事件队列中没有回调，JS引擎线程会一直发起询问，直到有为止 图解Event Loop 首先，执行栈开始顺序执行 判断是否为同步，异步则进入异步线程，最终事件回调给事件触发线程的任务队列等待执行，同步继续执行 执行栈空，询问任务队列中是否有事件回调 任务队列中有事件回调则把回调加入执行栈末尾继续从第一步开始执行 任务队列中没有事件回调则不停发起询问 完整的图解Event loop可以再结合宏任务和微任务得出","tags":[{"name":"Event Loop","slug":"Event-Loop","permalink":"https://github.com/NollieLeo/tags/Event-Loop/"},{"name":"进程和线程","slug":"进程和线程","permalink":"https://github.com/NollieLeo/tags/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"},{"name":"浏览器","slug":"浏览器","permalink":"https://github.com/NollieLeo/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"js引擎","slug":"js引擎","permalink":"https://github.com/NollieLeo/tags/js%E5%BC%95%E6%93%8E/"}]},{"title":"浏览器的渲染进程（renderer）","date":"2021-06-10T06:50:55.000Z","path":"2021/06/10/浏览器的渲染进程（renderer）/","text":"简述渲染进程Renderer 页面的渲染，JS的执行，事件的循环，都在渲染进程内执行。 渲染进程Renderer的主要线程GUI渲染线程 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等 解析html代码(HTML代码本质是字符串)转化为浏览器认识的节点，生成DOM树，也就是DOM Tree 解析css，生成CSSOM(CSS规则树) 把DOM Tree 和CSSOM结合，生成Rendering Tree(渲染树) 当我们修改了一些元素的颜色或者背景色，页面就会重绘(Repaint) 当我们修改元素的尺寸，页面就会回流(Reflow) 当页面需要Repaing和Reflow时GUI线程执行，绘制页面 回流(Reflow)比重绘(Repaint)的成本要高，我们要尽量避免Reflow和Repaint GUI渲染线程与JS引擎线程是互斥的 当JS引擎执行时GUI线程会被挂起(相当于被冻结了) GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行 JS引擎线程（主线程） JS引擎线程就是JS内核，负责处理Javascript脚本程序(例如V8引擎) JS引擎线程负责解析Javascript脚本，运行代码 JS引擎一直等待着任务队列中任务的到来，然后加以处理 浏览器同时只能有一个JS引擎线程在运行JS程序，所以js是单线程运行的 一个Tab页(renderer进程)中无论什么时候都只有一个JS线程在运行JS程序 GUI渲染线程与JS引擎线程是互斥的，js引擎线程会阻塞GUI渲染线程 就是我们常遇到的JS执行时间过长，造成页面的渲染不连贯，导致页面渲染加载阻塞(就是加载慢) 例如浏览器渲染的时候遇到script标签，就会停止GUI的渲染，然后js引擎线程开始工作，执行里面的js代码，等js执行完毕，js引擎线程停止工作，GUI继续渲染下面的内容。所以如果js执行时间太长就会造成页面卡顿的情况 事件触发线程 属于浏览器而不是JS引擎，用来控制事件循环，并且管理着一个事件队列(task queue) 当js执行碰到事件绑定和一些异步操作(如setTimeOut，也可来自浏览器内核的其他线程，如鼠标点击、AJAX异步请求等)，会走事件触发线程将对应的事件添加到对应的线程中(比如定时器操作，便把定时器事件添加到定时器线程)，等异步事件有了结果，便把他们的回调操作添加到事件队列，等待js引擎线程空闲时来处理。 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理 因为JS是单线程，所以这些待处理队列中的事件都得排队等待JS引擎处理 定时触发器线程 setInterval与setTimeout所在线程 浏览器定时计数器并不是由JavaScript引擎计数的(因为JavaScript引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确) 通过单独线程来计时并触发定时(计时完毕后，添加到事件触发线程的事件队列中，等待JS引擎空闲后执行)，这个线程就是定时触发器线程，也叫定时器线程 W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms 异步http请求线程 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中再由JavaScript引擎执行 简单说就是当执行到一个http异步请求时，就把异步请求事件添加到异步请求线程，等收到响应(准确来说应该是http状态变化)，再把回调函数添加到事件队列，等待js引擎线程来执行 EventLoop轮询处理线程 （重中之重）这里单独拿出一篇文章将这个","tags":[{"name":"进程和线程","slug":"进程和线程","permalink":"https://github.com/NollieLeo/tags/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"},{"name":"浏览器","slug":"浏览器","permalink":"https://github.com/NollieLeo/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"js引擎","slug":"js引擎","permalink":"https://github.com/NollieLeo/tags/js%E5%BC%95%E6%93%8E/"},{"name":"渲染进程","slug":"渲染进程","permalink":"https://github.com/NollieLeo/tags/%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B/"}]},{"title":"进程和线程","date":"2021-06-10T06:39:25.000Z","path":"2021/06/10/进程和线程/","text":"线程与进程什么是进程？首先， CPU懂吧？是计算机的核心，承当所有的计算任务 官方：进程是CPU资源分配的最小单位 按我的理解： 进程就是进行中的程序，可以独立运行并且拥有自己的资源空间的任务程序 意思就是： 运行中的程序 程序所用到的内存和系统资源 浏览器中的每个tab页都是一个进程 什么是线程？ 官方：线程是CPU调度的最小单位 线程是建立 进程的基础上的一次程序运行单位 通俗点就是：线程是程序中的一个执行流，一个进程中可以拥有多个执行流，也就是多个线程 线程分为两种： 单线程：一个进程中只有一个执行流，就只有一个线程，叫做单线程 多线程：顾名思义一个进程多个执行流， 进程与线程的区别进程是操作系统分配资源的最小单位，线程是程序执行的最小单位 一个进程由一个或多个线程组成，线程可以理解为是一个进程中代码的不同执行路线 进程之间相互独立，但同一进程下的各个线程间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号) 多进程和多线程多进程：多进程指的是在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如大家可以在网易云听歌的同时打开编辑器敲代码，编辑器和网易云的进程之间不会相互干扰 多线程：多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务 JS为什么是单线程JS的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 还有人说js还有Worker线程，对的，为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程是完 全受主线程控制的，而且不得操作DOM 所以，这个标准并没有改变JavaScript是单线程的本质","tags":[{"name":"js引擎","slug":"js引擎","permalink":"https://github.com/NollieLeo/tags/js%E5%BC%95%E6%93%8E/"},{"name":"进程与线程","slug":"进程与线程","permalink":"https://github.com/NollieLeo/tags/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"}]},{"title":"浏览器的进程种类","date":"2021-06-10T06:18:46.000Z","path":"2021/06/10/浏览器的进程种类/","text":"浏览器是多进程的，一个网页就是一个进程，所以你看谷歌开了那么多tab页，然后放着，就是玩，然后我电脑就炸了，因为老子CPU不行啊，就分配不了那么多内存空间给他用，就不行了呗 浏览器的进程种类Browser进程 浏览器的主进程(负责协调、主控)，该进程只有一个 负责浏览器界面显示，与用户交互。如前进，后退等 负责各个页面的管理，创建和销毁其他进程 将渲染(Renderer)进程得到的内存中的Bitmap(位图)，绘制到用户界面上 网络资源的管理，下载等 第三方插件进程 每种类型的插件对应一个进程，当使用该插件时才创建 GPU进程 该进程也只有一个，用于3D绘制等等 *渲染进程(如此的重要) 即通常所说的浏览器内核(Renderer进程，内部是多线程) 每个Tab页面都有一个渲染进程，互不影响 主要作用为页面渲染，脚本执行，事件处理等 为什么浏览器需要多进程？我们假设浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差 同理如果插件崩溃了也会影响整个浏览器 当然多进程还有其它的诸多优势，不过多阐述 浏览器进程有很多，每个进程又有很多线程，都会占用内存 这也意味着内存等资源消耗会很大，有点拿空间换时间的意思","tags":[{"name":"Event Loop","slug":"Event-Loop","permalink":"https://github.com/NollieLeo/tags/Event-Loop/"},{"name":"进程和线程","slug":"进程和线程","permalink":"https://github.com/NollieLeo/tags/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"},{"name":"浏览器","slug":"浏览器","permalink":"https://github.com/NollieLeo/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"js引擎","slug":"js引擎","permalink":"https://github.com/NollieLeo/tags/js%E5%BC%95%E6%93%8E/"}]},{"title":"使用生成器写出斐波那契数列","date":"2021-06-07T03:04:35.000Z","path":"2021/06/07/使用生成器写出斐波那契数列/","text":"下面是一个利用 Generator 函数和for...of循环，实现斐波那契数列的例子。 function* fibonacci() { let [prev, curr] = [0, 1]; for (;;) { yield curr; [prev, curr] = [curr, prev + curr]; } } for (let n of fibonacci()) { if (n &gt; 10000) break; console.log(n); }","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"ES6","slug":"ES6","permalink":"https://github.com/NollieLeo/tags/ES6/"},{"name":"斐波那契数列","slug":"斐波那契数列","permalink":"https://github.com/NollieLeo/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"}]},{"title":"前端性能优化","date":"2021-06-06T08:13:08.000Z","path":"2021/06/06/前端性能优化/","text":"前端性能优化最佳实践本文主要考量客户端性能、服务器端和网络性能，内容框架来自 Yahoo Developer Network，包含 7 个类别共 35 条前端性能优化最佳实践，在此基础上补充了一些相关或者更符合主流技术的内容。 同时，建议关注及时更新的 Google 性能优化指南。 目录： 页面内容 减少 HTTP 请求数 减少 DNS 查询 避免重定向 缓存 Ajax 请求 延迟加载 预先加载 减少 DOM 元素数量 划分内容到不同域名 尽量减少 iframe 使用 避免 404 错误 服务器 使用 CDN 添加 Expires 或 Cache-Control 响应头 启用 Gzip 配置 Etag 尽早输出缓冲 Ajax 请求使用 GET 方法 避免图片 src 为空 Cookie 减少 Cookie 大小 静态资源使用无 Cookie 域名 CSS 把样式表放在 `` 中 不要使用 CSS 表达式 使用 `` 替代 @import 不要使用 filter JavaScript 把脚本放在页面底部 使用外部 JavaScript 和 CSS 压缩 JavaScript 和 CSS 移除重复脚本 减少 DOM 操作 使用高效的事件处理 图片 优化图片 优化 CSS Sprite 不要在 HTML 中缩放图片 使用体积小、可缓存的 favicon.ico 移动端 保持单个文件小于 25 KB 打包内容为分段（multipart）文档 前端性能的一个重要指标是页面加载时间，不仅事关用户体验，也是搜索引擎排名考虑的一个因素。 来自 Google 的数据表明，一个有 10 条数据 0.4 秒能加载完的页面，变成 30 条数据 0.9 秒加载完之后，流量和广告收入下降 90%。 Google Map 首页文件大小从 100KB 减小到 70-80KB 后，流量在第一周涨了 10%，接下来的三周涨了 25%。 亚马逊的数据表明：加载时间增加 100 毫秒，销量就下降 1%。 以上数据更说明「加载时间就是金钱」，前端优化主要围绕提高加载速度进行。 页面内容减少 HTTP 请求数Web 前端 80% 的响应时间花在图片、样式、脚本等资源下载上。浏览器对每个域名的连接数是有限制的，减少请求次数是缩短响应时间的关键。 通过简洁的设计减少页面所需资源，进而减少 HTTP 请求，这是最直接的方式，前提是你的 Boss、设计师同事不打死你。所以，还是另辟蹊径吧： 合并 JavaScript、CSS 等文件； 服务器端（CDN）自动合并 基于 Node.js 的文件合并工具一抓一大把 使用CSS Sprite：将背景图片合并成一个文件，通过background-image 和 background-position 控制显示； Sprite Cow Spritebox 逐步被 Icon Font 和 SVG Sprite 取代。 Image Map：合并图片，然后使用坐标映射不同的区域（演示）。 缺点：仅适用于相连的图片；设置坐标过程乏味且易出错；可访性问题。不推荐使用这种过时的技术。 Inline Assets：使用 Data URI scheme 将图片嵌入 HTML 或者 CSS 中；或者将 CSS、JS、图片直接嵌入 HTML 中。 会增加文件大小，也可能产生浏览器兼容及其他性能问题（有待整理补充）。 未来的趋势是使用内嵌 SVG。 内容分片，将请求划分到不同的域名上。 HTTP/2 通过多路复用大幅降低了多个请求的开销。通过数据分帧层，客户端和服务器之间只需要建立一个 TCP 连接，即可同时收发多个文件，而且，该连接在相当长的时间周期内保持打开（持久化），以便复用。 HTTP/2 的新特性意味着上述优化实践不再适用，但考虑到客户端对 HTTP/2 的支持覆盖程度，还需根据实际数据权衡。 减少 DNS 查询用户输入 URL 以后，浏览器首先要查询域名（hostname）对应服务器的 IP 地址，一般需要耗费 20-120 毫秒 时间。DNS 查询完成之前，浏览器无法从服务器下载任何数据。 基于性能考虑，ISP、局域网、操作系统、浏览器都会有相应的 DNS 缓存机制。 IE 缓存 30 分钟，可以通过注册表中 DnsCacheTimeout 项设置； Firefox 混存 1 分钟，通过 network.dnsCacheExpiration 配置； （TODO：补充其他浏览器缓存信息） 首次访问、没有相应的 DNS 缓存时，域名越多，查询时间越长。所以应尽量减少域名数量。但基于并行下载考虑，把资源分布到 2 个域名上（最多不超过 4 个）。这是减少 DNS 查询同时保证并行下载的折衷方案。 避免重定向HTTP 重定向通过 301/302 状态码实现。 HTTP/1.1 301 Moved Permanently Location: http://example.com/newuri Content-Type: text/html客户端收到服务器的重定向响应后，会根据响应头中 Location 的地址再次发送请求。重定向会影响用户体验，尤其是多次重定向时，用户在一段时间内看不到任何内容，只看到浏览器进度条一直在刷新。 有时重定向无法避免，在糟糕也比抛出 404 好。虽然通过 HTML meta refresh 和 JavaScript 也能实现，但首选 HTTP 3xx 跳转，以保证浏览器「后退」功能正常工作（也利于 SEO）。 最浪费的重定向经常发生、而且很容易被忽略：URL 末尾应该添加 / 但未添加。比如，访问 http://astrology.yahoo.com/astrology 将被 301 重定向到 http://astrology.yahoo.com/astrology/（注意末尾的 /）。如果使用 Apache，可以通过 Alias 或 mod_rewrite 或 DirectorySlash 解决这个问题。 网站域名变更：CNAME 结合 Alias 或 mod_rewrite 或者其他服务器类似功能实现跳转。 缓存 Ajax 请求Ajax 可以提高用户体验。但「异步」不意味着「及时」，优化 Ajax 响应速度提高性能仍是需要关注的主题。 最重要的的优化方式是缓存响应结果，详见 添加 Expires 或 Cache-Control 响应头。 以下规则也关乎 Ajax 响应速度： 启用 Gzip 减少 DNS 查询 压缩 JavaScript 和 CSS 避免重定向 配置 Etag 延迟加载页面初始加载时哪些内容是绝对必需的？不在答案之列的资源都可以延迟加载。比如： 非首屏使用的数据、样式、脚本、图片等； 用户交互时才会显示的内容。 遵循「渐进增强」理念开发的网站：JavaScript 用于增强用用户体验，但没有（不支持） JavaScript 也能正常工作，完全可以延迟加载 JavaScript。 延迟渲染 将首屏以外的 HTML 放在不渲染的元素中，如隐藏的 ，或者 `type` 属性为非执行脚本的 标签中，减少初始渲染的 DOM 元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。 预先加载预先加载利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面时更快地响应。 无条件预先加载：页面加载完成（load）后，马上获取其他资源。以 google.com 为例，首页加载完成后会立即下载一个 Sprite 图片，此图首页不需要，但是搜索结果页要用到。 有条件预先加载：根据用户行为预判用户去向，预载相关资源。比如 search.yahoo.com 开始输入时会有额外的资源加载。 Chrome 等浏览器的地址栏也有类似的机制。 有「阴谋」的预先加载：页面即将上线新版前预先加载新版内容。网站改版后由于缓存、使用习惯等原因，会有旧版的网站更快更流畅的反馈。为缓解这一问题，在新版上线之前，旧版可以利用空闲提前加载一些新版的资源缓存到客户端，以便新版正式上线后更快的载入（好一个「心机猿」:scream:）。 「双十一」、「黑五」这类促销日来临之前，也可以预先下载一些相关资源到客户端（浏览器、App 等），有效利用浏览器缓存和本地存储，降低活动当日请求压力，提高用户体验。 TODO: Prefetch 相关细节 Resource Hints Spec 减少 DOM 元素数量复杂的页面不仅下载的字节更多，JavaScript DOM 操作也更慢。例如，同是添加一个事件处理器，500 个元素和 5000 个元素的页面速度上会有很大区别。 从以下几个角度考虑移除不必要的标记： 是否还在使用表格布局？ 塞进去更多的 `` 仅为了处理布局问题？也许有更好、更语义化的标记。 能通过伪元素实现的功能，就没必要添加额外元素，如清除浮动。 浏览器控制台中输入以下代码可以计算出页面中有多少 DOM 元素： document.getElementsByTagName(&#39;*&#39;).length; 对比标记良好的的网站，看看差距是多少。 为什么不使用表格布局？ 更多的标签，增加文件大小； 不易维护，无法适应响应式设计； 性能考量，默认的表格布局算法会产生大量重绘（参见表格布局算法）。 划分内容到不同域名浏览器一般会限制每个域的并行线程（一般为 6 个，甚至更少），使用不同的域名可以最大化下载线程，但注意保持在 2-4 个域名内，以避免 DNS 查询损耗。 例如，动态内容放在 csspod.com 上，静态资源放在 static.csspod.com 上。这样还可以禁用静态资源域下的 Cookie，减少数据传输，详见 Cookie 优化。 更多信息参考 Maximizing Parallel Downloads in the Carpool Lane 尽量减少 iframe 使用使用 iframe 可以在页面中嵌入 HTML 文档，但有利有弊。 优点： 可以用来加载速度较慢的第三方资源，如广告、徽章； 可用作安全沙箱； 可以并行下载脚本。 缺点： 加载代价昂贵，即使是空的页面； 阻塞页面 load 事件触发； Iframe 完全加载以后，父页面才会触发 load 事件。 Safari、Chrome 中通过 JavaScript 动态设置 iframe src 可以避免这个问题。 缺乏语义。 避免 404 错误HTTP 请求很昂贵，返回无效的响应（如 404 未找到）完全没必要，降低用户体验而且毫无益处。 一些网站设计很酷炫、有提示信息的 404 页面，有助于提高用户体验，但还是浪费服务器资源。尤其糟糕的是外部脚本返回 404，不仅阻塞其他资源下载，浏览器还会尝试把 404 页面内容当作 JavaScript 解析，消耗更多资源。 补充规则： 定义字符集，并放在 `` 顶部。大多数浏览器会暂停页面渲染，直到找到字符集定义。 服务器服务器相关优化设置可参考 H5BP 相关项目： Nginx HTTP server boilerplate configs Apache HTTP server boilerplate configs IIS Web.Config Boilerplates 使用 CDN网站 80-90% 响应时间消耗在资源下载上，减少资源下载时间是性能优化的黄金发则。 相比分布式架构的复杂和巨大投入，静态内容分发网络（CDN）可以以较低的投入，获得加载速度有效提升。 添加 Expires 或 Cache-Control 响应头 静态内容：将 Expires 响应头设置为将来很远的时间，实现「永不过期」策略； 动态内容：设置合适的 Cache-Control 响应头，让浏览器有条件地发起请求。 Cache-Control 头在 HTTP/1.1 规范中定义，取代了之前用来定义响应缓存策略的头（例如 Expires、Pragma）。当前的所有浏览器都支持 Cache-Control，因此，使用它就够了。 鉴于静态内容和动态内容不同的缓存策略，实践中一般会把二者部署在不同的服务器（域名）以方便管理。 参考链接： HTTP 缓存 | Web Fundamentals - Google Developers H5BP - Server Configs 启用 GzipGzip 压缩通常可以减少 70% 的响应大小，对某些文件更可能高达 90%，比 Deflate 更高效。主流 Web 服务器都有相应模块，而且绝大多数浏览器支持 gzip 解码。所以，应该对 HTML、CSS、JS、XML、JSON 等文本类型的内容启用压缩。 注意，图片和 PDF 文件不要使用 gzip。它们本身已经压缩过，再使用 gzip 压缩不仅浪费 CPU 资源，而且还可能增加文件体积。 对于不支持的 Gzip 的用户代理，通过设置 Vary 响应头，返回为未压缩的数据： Vary: *配置 EtagEtag 通过文件版本标识，方便服务器判断请求的内容是否有更新，如果没有就响应 304，避免重新下载。 当然，启用 Etag 可能会导致其他问题，还需要根据具体情况做判断。（TODO：补充相关内容） 尽早输出（flush）缓冲用户请求页面时，服务器通常需要花费 200 ~ 500 毫秒来组合 HTML 页面。在此期间，浏览器处于空闲、等待数据状态。使用PHP 中的 flush() 函数，可以发送部分已经准备好的 HTML 到浏览器，以便服务器还在忙于处理剩余页面时，浏览器可以提前开始获取资源。 可以考虑在 之后输出一次缓冲，HTML head 一般比较容易生成，先发送以便浏览器开始获取 里引用的 CSS 等资源。 Example: &lt;!-- css, js --&gt; &lt;/head&gt; &lt;?php flush(); ?&gt; &lt;body&gt; &lt;!-- content --&gt; Ajax 请求使用 GET 方法浏览器执行 XMLHttpRequest POST 请求时分成两步，先发送 Header，再发送数据。而 GET 只使用一个 TCP 数据包发送数据，所以首选 GET 方法。 根据 HTTP 规范，GET 用于获取数据，POST 则用于向服务器发送数据，所以 Ajax 请求数据时使用 GET 更符合规范（GET 和 POST 对比）。 IE 中最大 URL 长度为 2K，如果超出 2K，则需要考虑使用 POST 方法。 避免图片 src 为空图片 src 属性值为空字符串可能以下面两种形式出现： HTML: &lt;img src=&quot;&quot; /&gt; JavaScript： var img = new Image(); img.src = &quot;&quot;; 虽然 src 属性为空字符串，但浏览器仍然会向服务器发起一个 HTTP 请求： IE 向页面所在的目录发送请求； Safari、Chrome、Firefox 向页面本身发送请求； Opera 不执行任何操作。 以上数据较老，当下主流版本可能会有改变。 空 src 产生请求的后果不容小觑： 给服务器造成意外的流量负担，尤其时日 PV 较大时； 浪费服务器计算资源； 可能产生报错。 当然，浏览器如此实现也是根据 RFC 3986 - Uniform Resource Identifiers，当空字符串作为 URI 出现时，被当成相对 URI，具体算法参见规范 5.2 节。 参考链接： Empty image src can destroy your site 空的 href 属性也存在类似问题。用户点击空链接时，浏览器也会向服务器发送 HTTP 请求，可以通过 JavaScript 阻止空链接的默认的行为。 Cookie减少 Cookie 大小Cookie 被用于身份认证、个性化设置等诸多用途。Cookie 通过 HTTP 头在服务器和浏览器间来回传送，减少 Cookie 大小可以降低其对响应速度的影响。 去除不必要的 Cookie； 尽量压缩 Cookie 大小； 注意设置 Cookie 的 domain 级别，如无必要，不要影响到 sub-domain； 设置合适的过期时间。 更多细节参考 When the Cookie Crumbles。 HTTP/2 首部压缩在客户端和服务器端使用「首部表」来跟踪和存储之前发送的键值对，对于相同的数据，不再随每次请求和响应发送。 静态资源使用无 Cookie 域名静态资源一般无需使用 Cookie，可以把它们放在使用二级域名或者专门域名的无 Cookie 服务器上，降低 Cookie 传送的造成的流量浪费，提高响应速度。 CSS把样式表放在 `` 中把样式表放在 `` 中可以让页面渐进渲染，尽早呈现视觉反馈，给用户加载速度很快的感觉。 这对内容比较多的页面尤为重要，用户可以先查看已经下载渲染的内容，而不是盯着白屏等待。 如果把样式表放在页面底部，一些浏览器为减少重绘，会在 CSS 加载完成以后才渲染页面，用户只能对着白屏干瞪眼，用户体验极差。 不要使用 CSS 表达式CSS 表达式可以在 CSS 里执行 JavaScript，仅 IE5-IE7 支持，IE8 标准模式已经废弃。 CSS 表达式超出预期的频繁执行，页面滚动、鼠标移动时都会不断执行，带来很大的性能损耗。 IE7 及更低版本的浏览器已经逐渐成为历史，忘记它吧。 使用 `` 替代 @import对于 IE 某些版本，@import 的行为和 `` 放在页面底部一样。所以，不要用它。 不要使用 filterAlphaImageLoader 为 IE5.5-IE8 专有的技术，和 CSS 表达式一样，放进博物馆吧。 注意： 这里所说的不是 CSS3 Filter，参考文章 Understanding CSS Filter Effects JavaScript使用requestIdleCallback 兼容性不好，目前只有chrome支持 希望快速响应用户，让用户觉得快 使开发者能够再主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件。 正常帧任务完成后没超过16ms，说明事件有富余，则执行它的回调函数 把脚本放在页面底部浏览器下载脚本时，会阻塞其他资源并行下载，即使是来自不同域名的资源。因此，最好将脚本放在底部，以提高页面加载速度。 一些特殊场景无法将脚本放到页面底部的，可以考虑 `` 的以下属性： defer 属性； HTML5 新增的 async 属性。 使用外部 JavaScript 和 CSS外部 JavaScript 和 CSS 文件可以被浏览器缓存，在不同页面间重用，也能降低页面大小。 当然，实际中也需要考虑代码的重用程度。如果仅仅是某个页面使用到的代码，可以考虑内嵌在页面中，减少 HTTP 请求数。另外，可以在首页加载完成以后，预先加载子页面的资源。 压缩 JavaScript 和 CSS压缩代码可以移除非功能性的字符（注释、空格、空行等），减少文件大小，提高载入速度。 得益于 Node.js 的流行，开源社区涌现出许多高效、易用的前端优化工具，JavaScript 和 CSS 压缩类的，不敢说多如牛毛，多入鸡毛倒是一点不夸张，如 [UglifyJS 2] (https://github.com/mishoo/UglifyJS2)、[csso](https://www.npmjs.com/package/csso)、[cssnano](https://www.npmjs.com/package/cssnano) 等。 对于内嵌的 CSS 和 JavaScript，也可以通过 htmlmin 等工具压缩。 这些项目都有 Gulp、Webpack 等流行构建工具的配套版本。 移除重复脚本重复的脚本不仅产生不必要的 HTTP 请求，而且重复解析执行浪费时间和计算资源。 减少 DOM 操作JavaScript 操作 DOM 很慢，尤其是 DOM 节点很多时。 使用时应该注意： 缓存已经访问过的元素； 使用 DocumentFragment 暂存 DOM，整理好以后再插入 DOM 树； 操作 className，而不是多次读写 style； 避免使用 JavaScript 修复布局。 使用高效的事件处理 减少绑定事件监听的节点，如通过事件委托； 尽早处理事件，在 DOMContentLoaded 即可进行，不用等到 load 以后。 对于 resize、scroll 等触发频率极高的事件，应该通过 debounce 等机制降低处理程序执行频率。 TODO: 补充相关内容 http://demo.nimius.net/debounce_throttle/ 图片优化图片 YDN 列出的相关工具 缺乏易用性，建议参考以下工具。 imagemin ImageOptim TODO: PNG 终极优化； Webp 相关内容； SVG 相关内容。 PNG 终极优化： Most Effective Method to Reduce and Optimize PNG Images Clever PNG Optimization Techniques 优化 CSS Sprite 水平排列 Sprite 中的图片，垂直排列会增加图片大小； Spirite 中把颜色较近的组合在一起可以降低颜色数，理想状况是低于 256 色以适用 PNG8 格式； 不要在 Spirite 的图像中间留有较大空隙。减少空隙虽然不太影响文件大小，但可以降低用户代理把图片解压为像素图的内存消耗，对移动设备更友好。 不要在 HTML 中缩放图片不要使用 `` 的 width、height 缩放图片，如果用到小图片，就使用相应大小的图片。 很多 CMS 和 CDN 都提供图片裁切功能。 使用体积小、可缓存的 favicon.icoFavicon.ico 一般存放在网站根目录下，无论是否在页面中设置，浏览器都会尝试请求这个文件。 所以确保这个图标： 存在（避免 404）； 尽量小，最好小于 1K； 设置较长的过期时间。 对于较新的浏览器，可以使用 PNG 格式的 favicon。 参考链接： Favicons, Touch Icons, Tile Icons, etc. Which Do You Need? 图片相关补充 设置图片的宽和高，以免浏览器按照「猜」的宽高给图片保留的区域和实际宽高差异，产生重绘。 移动端 移动端优化相关内容有待进一步整理补充。 保持单个文件小于 25 KB打包内容为分段（multipart）文档参考链接 The Psychology of Web Performance","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"性能优化","slug":"性能优化","permalink":"https://github.com/NollieLeo/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"react相关面试知识点","date":"2021-06-06T07:34:05.000Z","path":"2021/06/06/react相关面试知识点/","text":"react 的生命周期，分别在哪个时候被执行setState，哪些生命周期可以setState函数组件和普通组件区别什么是render props组件fiber是什么diff算法VDom虚拟dom这里，小编的理解是：虚拟DOM是真实DOM的内存表示，是一种编程概念，一种模式。它的作用是判断DOM是否改变、哪些部分需要被重新渲染。这样，不需要操纵真实的DOM,同时极大的提高了React的性能。 虚拟DOM使用diff算法，当我们多次修改某一部分的内容时，首先在虚拟DOM树从上至下进行同层比对（不影响真实DOM），上层发生变化，下层重新渲染，直到最后修改完成，再在真实DOM中渲染。 使用虚拟DOM的原因是，可以极大程度上减少DOM节点的回流和重绘问题，节约资源，提升运行效率。 区别 虚拟DOM不会进行重排和重绘； 虚拟DOM进行频繁的修改，然后一次性比较并修改真实DOM中需要修改的部分，最后进行回流和重绘，有效的减少了过多DOM节点回流和重绘资源消耗的问题； 虚拟DOM有效降低大面积（真实DOM节点）的回流和重绘，因为最终与真实DOM比较差异，可以局部渲染。 React中的controlled component 和 uncontrolled component区别 （受控组件和不受控组件）react-router内部实现机制","tags":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"react","slug":"react","permalink":"https://github.com/NollieLeo/tags/react/"}]},{"title":"js的精度运算","date":"2021-06-06T02:17:48.000Z","path":"2021/06/06/js的精度运算/","text":"前言0.1 + 0.2 是否等于 0.3 作为一道经典的面试题，已经广外熟知，说起原因，大家能回答出这是浮点数精度问题导致，也能辩证的看待这并非是 ECMAScript 这门语言的问题，今天就是具体看一下背后的原因。 数字类型ECMAScript 中的 Number 类型使用 IEEE754 标准来表示整数和浮点数值。所谓 IEEE754 标准，全称 IEEE 二进制浮点数算术标准，这个标准定义了表示浮点数的格式等内容。 在 IEEE754 中，规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度、与延伸双精确度。像 ECMAScript 采用的就是双精确度，也就是说，会用 64 位字节来储存一个浮点数。 浮点数转二进制我们来看下 1020 用十进制的表示： 1020 = 1 * 10^3 + 0 * 10^2 + 2 * 10^1 + 0 * 10^0 所以 1020 用十进制表示就是 1020……(哈哈) 如果 1020 用二进制来表示呢？ 1020 = 1 * 2^9 + 1 * 2^8 + 1 * 2^7 + 1 * 2^6 + 1 * 2^5 + 1 * 2^4 + 1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 0 * 2^0 所以 1020 的二进制为 1111111100 那如果是 0.75 用二进制表示呢？同理应该是： 0.75 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + … 因为使用的是二进制，这里的 abcd……的值的要么是 0 要么是 1。 那怎么算出 abcd…… 的值呢，我们可以两边不停的乘以 2 算出来，解法如下： 0.75 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4… 两边同时乘以 2 1 + 0.5 = a * 2^0 + b * 2^-1 + c * 2^-2 + d * 2^-3… (所以 a = 1) 剩下的： 0.5 = b * 2^-1 + c * 2^-2 + d * 2^-3… 再同时乘以 2 1 + 0 = b * 2^0 + c * 2^-2 + d * 2^-3… (所以 b = 1) 所以 0.75 用二进制表示就是 0.ab，也就是 0.11 然而不是所有的数都像 0.75 这么好算，我们来算下 0.1： 0.1 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + ... 0 + 0.2 = a * 2^0 + b * 2^-1 + c * 2^-2 + ... (a = 0) 0 + 0.4 = b * 2^0 + c * 2^-1 + d * 2^-2 + ... (b = 0) 0 + 0.8 = c * 2^0 + d * 2^-1 + e * 2^-2 + ... (c = 0) 1 + 0.6 = d * 2^0 + e * 2^-1 + f * 2^-2 + ... (d = 1) 1 + 0.2 = e * 2^0 + f * 2^-1 + g * 2^-2 + ... (e = 1) 0 + 0.4 = f * 2^0 + g * 2^-1 + h * 2^-2 + ... (f = 0) 0 + 0.8 = g * 2^0 + h * 2^-1 + i * 2^-2 + ... (g = 0) 1 + 0.6 = h * 2^0 + i * 2^-1 + j * 2^-2 + ... (h = 1) ....然后你就会发现，这个计算在不停的循环，所以 0.1 用二进制表示就是 0.00011001100110011…… 浮点数的存储虽然 0.1 转成二进制时是一个无限循环的数，但计算机总要储存吧，我们知道 ECMAScript 使用 64 位字节来储存一个浮点数，那具体是怎么储存的呢？这就要说回 IEEE754 这个标准了，毕竟是这个标准规定了存储的方式。 这个标准认为，一个浮点数 (Value) 可以这样表示： Value = sign * exponent * fraction 看起来很抽象的样子，简单理解就是科学计数法…… 比如 -1020，用科学计数法表示就是: -1 * 10^3 * 1.02 sign 就是 -1，exponent 就是 10^3，fraction 就是 1.02 对于二进制也是一样，以 0.1 的二进制 0.00011001100110011…… 这个数来说： 可以表示为： 1 * 2^-4 * 1.1001100110011…… 其中 sign 就是 1，exponent 就是 2^-4，fraction 就是 1.1001100110011…… 而当只做二进制科学计数法的表示时，这个 Value 的表示可以再具体一点变成： V = (-1)^S * (1 + Fraction) * 2^E (如果所有的浮点数都可以这样表示，那么我们存储的时候就把这其中会变化的一些值存储起来就好了) 我们来一点点看： (-1)^S 表示符号位，当 S = 0，V 为正数；当 S = 1，V 为负数。 再看 (1 + Fraction)，这是因为所有的浮点数都可以表示为 1.xxxx * 2^xxx 的形式，前面的一定是 1.xxx，那干脆我们就不存储这个 1 了，直接存后面的 xxxxx 好了，这也就是 Fraction 的部分。 最后再看 2^E 如果是 1020.75，对应二进制数就是 1111111100.11，对应二进制科学计数法就是 1 * 1.11111110011 * 2^9，E 的值就是 9，而如果是 0.1 ，对应二进制是 1 * 1.1001100110011…… * 2^-4， E 的值就是 -4，也就是说，E 既可能是负数，又可能是正数，那问题就来了，那我们该怎么储存这个 E 呢？ 我们这样解决，假如我们用 8 位字节来存储 E 这个数，如果只有正数的话，储存的值的范围是 0 ~ 254，而如果要储存正负数的话，值的范围就是 -127~127，我们在存储的时候，把要存储的数字加上 127，这样当我们存 -127 的时候，我们存 0，当存 127 的时候，存 254，这样就解决了存负数的问题。对应的，当取值的时候，我们再减去 127。 所以呢，真到实际存储的时候，我们并不会直接存储 E，而是会存储 E + bias，当用 8 个字节的时候，这个 bias 就是 127。 所以，如果要存储一个浮点数，我们存 S 和 Fraction 和 E + bias 这三个值就好了，那具体要分配多少个字节位来存储这些数呢？IEEE754 给出了标准： [ IEEE754 ] 在这个标准下： 我们会用 1 位存储 S，0 表示正数，1 表示负数。 用 11 位存储 E + bias，对于 11 位来说，bias 的值是 2^(11-1) - 1，也就是 1023。 用 52 位存储 Fraction。 举个例子，就拿 0.1 来看，对应二进制是 1 * 1.1001100110011…… * 2^-4， Sign 是 0，E + bias 是 -4 + 1023 = 1019，1019 用二进制表示是 1111111011，Fraction 是 1001100110011…… 对应 64 个字节位的完整表示就是： 0 01111111011 1001100110011001100110011001100110011001100110011010 同理, 0.2 表示的完整表示是： 0 01111111100 1001100110011001100110011001100110011001100110011010 所以当 0.1 存下来的时候，就已经发生了精度丢失，当我们用浮点数进行运算的时候，使用的其实是精度丢失后的数。 浮点数的运算关于浮点数的运算，一般由以下五个步骤完成：对阶、尾数运算、规格化、舍入处理、溢出判断。我们来简单看一下 0.1 和 0.2 的计算。 首先是对阶，所谓对阶，就是把阶码调整为相同，比如 0.1 是 1.1001100110011…… * 2^-4，阶码是 -4，而 0.2 就是 1.10011001100110...* 2^-3，阶码是 -3，两个阶码不同，所以先调整为相同的阶码再进行计算，调整原则是小阶对大阶，也就是 0.1 的 -4 调整为 -3，对应变成 0.11001100110011…… * 2^-3 接下来是尾数计算: 0.1100110011001100110011001100110011001100110011001101 + 1.1001100110011001100110011001100110011001100110011010 ———————————————————————————————————————————————————————— 10.0110011001100110011001100110011001100110011001100111我们得到结果为 10.0110011001100110011001100110011001100110011001100111 * 2^-3 将这个结果处理一下，即结果规格化，变成 1.0011001100110011001100110011001100110011001100110011(1) * 2^-2 括号里的 1 意思是说计算后这个 1 超出了范围，所以要被舍弃了。 再然后是舍入，四舍五入对应到二进制中，就是 0 舍 1 入，因为我们要把括号里的 1 丢了，所以这里会进一，结果变成 1.0011001100110011001100110011001100110011001100110100 * 2^-2本来还有一个溢出判断，因为这里不涉及，就不讲了。 所以最终的结果存成 64 位就是 0 01111111101 0011001100110011001100110011001100110011001100110100 将它转换为10进制数就得到 0.30000000000000004440892098500626 因为两次存储时的精度丢失加上一次运算时的精度丢失，最终导致了 0.1 + 0.2 !== 0.3 其他// 十进制转二进制 parseFloat(0.1).toString(2); =&gt; &quot;0.0001100110011001100110011001100110011001100110011001101&quot; // 二进制转十进制 parseInt(1100100,2) =&gt; 100 // 以指定的精度返回该数值对象的字符串表示 (0.1 + 0.2).toPrecision(21) =&gt; &quot;0.300000000000000044409&quot; (0.3).toPrecision(21) =&gt; &quot;0.299999999999999988898&quot;","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"浮点数","slug":"浮点数","permalink":"https://github.com/NollieLeo/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"},{"name":"精度运算","slug":"精度运算","permalink":"https://github.com/NollieLeo/tags/%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/"}]},{"title":"js的闭包","date":"2021-06-06T01:56:18.000Z","path":"2021/06/06/js的闭包/","text":"定义MDN 对闭包的定义为： 闭包是指那些能够访问自由变量的函数。 那什么是自由变量呢？ 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 由此，我们可以看出闭包共有两部分组成： 闭包 = 函数 + 函数能够访问的自由变量 举个例子： var a = 1; function foo() { console.log(a); } foo();foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。 那么，函数 foo + foo 函数访问的自由变量 a 不就是构成了一个闭包嘛…… 还真是这样的！ 所以在《JavaScript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包。 咦，这怎么跟我们平时看到的讲到的闭包不一样呢！？ 别着急，这是理论上的闭包，其实还有一个实践角度上的闭包，让我们看看汤姆大叔翻译的关于闭包的文章中的定义： ECMAScript中，闭包指的是： 从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。 从实践角度：以下函数才算是闭包： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 接下来就来讲讲实践上的闭包。 分析让我们先写个例子，例子依然是来自《JavaScript权威指南》，稍微做点改动： var scope = &quot;global scope&quot;; function checkscope(){ var scope = &quot;local scope&quot;; function f(){ return scope; } return f; } var foo = checkscope(); foo();首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。 这里直接给出简要的执行过程： 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈 全局执行上下文初始化 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈 checkscope 执行上下文初始化，创建变量对象、作用域链、this等 checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈 f 执行上下文初始化，创建变量对象、作用域链、this等 f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 了解到这个过程，我们应该思考一个问题，那就是： 当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？ 以上的代码，要是转换成 PHP，就会报错，因为在 PHP 中，f 函数只能读取到自己作用域和全局作用域里的值，所以读不到 checkscope 下的 scope 值。(这段我问的PHP同事……) 然而 JavaScript 却是可以的！ 当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链： fContext = { Scope: [AO, checkscopeContext.AO, globalContext.VO], }对的，就是因为这个作用域链，f 函数依然可以读取到 checkscopeContext.AO 的值，说明当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。 所以，让我们再看一遍实践角度上闭包的定义： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 在这里再补充一个《JavaScript权威指南》英文原版对闭包的定义: This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature. 闭包在计算机科学中也只是一个普通的概念，大家不要去想得太复杂。 必刷题接下来，看这道刷题必刷，面试必考的闭包题： var data = []; for (var i = 0; i &lt; 3; i++) { data[i] = function () { console.log(i); }; } data[0](); data[1](); data[2]();答案是都是 3，让我们分析一下原因： 当执行到 data[0] 函数之前，此时全局上下文的 VO 为： globalContext = { VO: { data: [...], i: 3 } }当执行 data[0] 函数的时候，data[0] 函数的作用域链为： data[0]Context = { Scope: [AO, globalContext.VO] }data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。 data[1] 和 data[2] 是一样的道理。 所以让我们改成闭包看看： var data = []; for (var i = 0; i &lt; 3; i++) { data[i] = (function (i) { return function(){ console.log(i); } })(i); } data[0](); data[1](); data[2]();当执行到 data[0] 函数之前，此时全局上下文的 VO 为： globalContext = { VO: { data: [...], i: 3 } }跟没改之前一模一样。 当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变： data[0]Context = { Scope: [AO, 匿名函数Context.AO globalContext.VO] }匿名函数执行上下文的AO为： 匿名函数Context = { AO: { arguments: { 0: 0, length: 1 }, i: 0 } }data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是0。 data[1] 和 data[2] 是一样的道理。","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"作用域链","slug":"作用域链","permalink":"https://github.com/NollieLeo/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"},{"name":"作用域","slug":"作用域","permalink":"https://github.com/NollieLeo/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"闭包","slug":"闭包","permalink":"https://github.com/NollieLeo/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"js的执行上下文以及执行上下文栈","date":"2021-06-05T07:37:38.000Z","path":"2021/06/05/js的执行上下文以及执行上下文栈/","text":"js的执行上下文以及执行上下文栈可执行代码js的可执行代码（executable code）有哪些？只有可执行代码会创建执行上下文 全局代码 函数代码 eval代码 执行上下文只有可执行代码会创建执行上下文 当执行到一个函数的时候这里会进行准备工作， 这个准备工作用专业点的话讲就是 执行上下文（execution context） 这里一定是！函数执行的时候才会去创建执行上下文！ 对于每一个执行上下文，都有三个重要属性 变量对象（Variable object） 俗称VO 作用域链（Scope chain） this 这些属性可以去对应的文章中看 执行上下文栈js以执行上下文栈的方式去创建一个执行上下文栈，来进行各个上下文之间的管理 在所有的情况下，执行js的代码，首先遇到的是全局代码这是毋庸置疑的 这个时候相当于这个全局的执行上下文就是在栈底了 首先我们先模拟一下，创建一个栈表示执行上下文栈 ECStack = []; 按照上面所说的，执行上下文栈底永远都有一个全局的执行上下文，这里用globalContext表示 ECStack=[ globalContext ] 按题分析解释执行上下文栈function fn3(){ console.log(&#39;fn3&#39;) } function fn2(){ console.log(&#39;fn2&#39;); fn3(); } function fn1(){ console.log(&#39;fn1&#39;); fn2(); } fun1(); 当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。 因此以上的代码执行原理是这样的 //fn1() ECStack.push(&lt;fn1&gt; function1Context); // 这时候发现fun1中调用了fn2 ECStack.push(&lt;fn2&gt; function2Context); // fn2中又调用了fn3 ECStack.puhs(&lt;fn3&gt; function3Context); // 此时的ECStack为 // ECStack = [ // globalContext // function1Context // function2Context // function3Context // ] //fn3执行完了 ECStack.pop(); // function3Context // fn2执行完了 ECStack.pop(); // function3Context // fn1执行完了 ECStack.pop(); // function1Context // javascript接着执行下面的代码，但是ECStack底层永远有个globalContext 根据上下文栈以及作用域链以及VO或者AO分析例如 var scope = &quot;global scope&quot;; function checkscope(){ var scope = &quot;local scope&quot;; function f(){ return scope; } return f(); } checkscope(); var scope = &quot;global scope&quot;; function checkscope(){ var scope = &quot;local scope&quot;; function f(){ return scope; } return f; } checkscope()(); 分别输出什么？ 对，都是local scope 具体分析一下 先分析第一道 分析第一道执行过程如下 1.无论如何先执行全局代码，创建全局执行上下文，全局上下文压入栈底 ECStack = [ globalContext ] 2.初始化全局上下文 globalContext = { VO: [global], Scope: [globalContext.VO], this: globalContext.VO } 3.在第2步初始化的过程发现全局的作用域中定义了一个 checkscrope函数，这个函数的作用域链上就会先推入一个全局上下文对象中的Scope checkscope.[[scope]]=[ globalContext.VO ] 4.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 ECStack = [ globalContext, checkscopeContext, ] 5.checkscope函数执行上下文的初始化 复制函数的[[scope]]属性创建作用域链，放到checkscopeContext的[[scope]]中 用arguments创建活动对象 初始化活动对象，加入形参，内部函数声明，变量声明 将活动对象压入 checkscope 作用域链顶端，也就是checkscope.VO 函数f被声明，保存checkscope的作用域链到fn函数的[[scope]]当中 checkscopeContext = { AO:{ arguments: { length: 0, }, scope: undefined, f: refrence to function f(){} }, Scope: [checkscopeContext.AO, globalContext.VO], this: undefined } ​ 6. 执行函数f，创建f的执行上下文，f函数的执行上下文被压入栈中 ECStack= [ globalContext, checkscopeContext, fnContext ] f函数执行上下文初始化，和第5步一样 fnContext = { AO = { arguments:{ length: 0 } }, Scope: [fnContext.AO, checkscopeContext.AO, globalContext.VO], this: undefined } f函数执行之后，沿着作用域链查找到scope的值，返回scope值 f函数执行完，栈中pop出上下文 ECStack.pop() ECStack = [ globalContext, checkscopeContext, ] checkscope函数执行完毕，checkscope执行上下文pop出栈 ECStack.pop() ECStack = [ globalContext, ]","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"作用域","slug":"作用域","permalink":"https://github.com/NollieLeo/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"执行上下文","slug":"执行上下文","permalink":"https://github.com/NollieLeo/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"},{"name":"执行上下文栈","slug":"执行上下文栈","permalink":"https://github.com/NollieLeo/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/"}]},{"title":"js的作用域链","date":"2021-06-05T07:34:14.000Z","path":"2021/06/05/js的作用域链/","text":"作用域链当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。 下面，以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。 函数创建函数的作用域在函数定义的时候就决定了。 这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！ 举个例子： function foo() { function bar() { ... } }函数创建时，各自的[[scope]]为： foo.[[scope]] = [ globalContext.VO ]; bar.[[scope]] = [ fooContext.AO, globalContext.VO ];函数激活当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。 这时候执行上下文的作用域链，我们命名为 Scope： Scope = [AO].concat([[Scope]]);至此，作用域链创建完毕。 捋一捋以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程： var scope = &quot;global scope&quot;; function checkscope(){ var scope2 = &#39;local scope&#39;; return scope2; } checkscope();执行过程如下： 1.checkscope 函数被创建，保存作用域链到 内部属性[[scope]] checkscope.[[scope]] = [ globalContext.VO ];2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 ECStack = [ checkscopeContext, globalContext ];3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链 checkscopeContext = { Scope: checkscope.[[scope]], }4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明 checkscopeContext = { AO: { arguments: { length: 0 }, scope2: undefined }， Scope: checkscope.[[scope]], }5.第三步：将活动对象压入 checkscope 作用域链顶端 checkscopeContext = { AO: { arguments: { length: 0 }, scope2: undefined }, Scope: [AO, [[Scope]]] }6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值 checkscopeContext = { AO: { arguments: { length: 0 }, scope2: &#39;local scope&#39; }, Scope: [AO, [[Scope]]] }7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出 ECStack = [ globalContext ];","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"作用域链","slug":"作用域链","permalink":"https://github.com/NollieLeo/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"},{"name":"作用域","slug":"作用域","permalink":"https://github.com/NollieLeo/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"执行上下文","slug":"执行上下文","permalink":"https://github.com/NollieLeo/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"}]},{"title":"js的静态作用域理解","date":"2021-06-05T07:10:11.000Z","path":"2021/06/05/js的静态作用域/","text":"js的静态作用域理解总所周知，js是词法作用域（静态作用域），函数的作用域在函数定义的时候就已经决定了。（这句话是重点，要考） 作用域 作用域是指程序源代码中定义变量的区域 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。 按题分析如下 var value = 0; function sayHi(){ console.log(value); } function hi(){ const value = 2; sayHi(); } hi(); 最终打印啥？ 对 就是 2 错！ 是1哈哈哈哈哈 为啥卧槽 执行过程 首先可以看到全局定义了value， 声明了函数hi和sayHi 这时候是最外层声明的函数，那么sayHi和hi的函数作用域在此时已经决定了！（作用域是一层层的嵌套的，具体这里内部处理方式看 js的作用域链那片文章 这时候执行hi函数 定义了一个value，然后什么都不做去执行sayHi 这时候执行sayHi函数，要输出value，这时候会去查找他的局部是否有这个变量，发现没有 这个时候往上找，这个上，很重要，就是sayHi函数在定义的时候的那个区域，这里指的就是全局 全局找到了value，输出value 如果说是动态作用域的话，那这里执行sayHi就得看调用它是在哪个域中调用了","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"作用域链","slug":"作用域链","permalink":"https://github.com/NollieLeo/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"},{"name":"作用域","slug":"作用域","permalink":"https://github.com/NollieLeo/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"执行上下文","slug":"执行上下文","permalink":"https://github.com/NollieLeo/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"}]},{"title":"手写bind","date":"2021-06-03T08:58:33.000Z","path":"2021/06/03/手写bind/","text":"手写bind原理 bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN ) 由此我们可以首先得出 bind 函数的两个特点： 返回一个函数 可以传入参数 实现首先先在Function的原型上挂载一个自定义bind函数 Function.prototype._bind = function(){} 1. 模拟实现返回一个函数正常的使用bind的时候是返回一个函数，这里返回的函数的引用(this)依旧指向的是调用bind的函数，而不是新得返回函数, 而且 考虑到绑定函数可能是有返回值 ，所以这块还是要处理下 const obj ={ name: &#39;weng&#39;, }; function sayName(){ return this.name; } const a = sayName._bind(obj); console.log(a()); //weng 所以这块的this指向需要做处理。 Function.prototype._bind = function(context){ const that = this; return function(){ return that.call(context); } } 这里用that存储this，之后返回一个闭包函数 2. 传参数在执行bind的时候，bind可以传参数，而且bind返回之后的函数也可以传参数 const obj ={ name: &#39;weng&#39;, }; function sayName(age, address){ return `${this.name}: ${age} : ${address}`; } const a = sayName.bind(obj, 23); console.log(a(&#39;fujian&#39;)); // weng : 23 : fujian 这里就相当于内部实现一个函数柯里化用来存储每次传进来的数据，但是没有柯里化那么牛逼，具体可以看实现函数柯里化那那篇文章 具体实现如下 Function.prototype._bind = function(context){ const that = this; const outerArgs = Array.prototype.slice.call(arguments, 1); // 存下第一次传的参数， 截掉第一个 return function(){ const innerArgs = Array.prototype.slice.call(arguments); return that.call(context, ...outerArgs.concat(innerArgs)); // 把外层参数拼接到内层的参数类数组里头 } } 3. 构造函数的模拟实现 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子： const obj = { preName: &quot;weng&quot;, }; function Bar(name, age) { this.name = name; this.age = age; } Bar.prototype.sayName = function(){ console.log(this.name) } const MyBar = Bar.bind(obj, &quot;kaimin&quot;); const o = new MyBar(12); console.log(o); 结果如下 image-20210604110748385 可以得知此时Bar函数的this指向的是o对象，就是相当于以new的形式调用了构造函数，这块的原理可以去 手写new那篇文章看看 Function.prototype._bind = function (context) { const that = this; const outerArgs = Array.prototype.slice.call(arguments, 1); const returnFn = function () { const innerArgs = Array.prototype.slice.call(arguments); return that.call( this instanceof returnFn ? this : context, ...outerArgs.concat(innerArgs) ); }; returnFn.prototype = this.prototype; return returnFn; }; 以這行代碼来说 return that.call( this instanceof returnFn ? this : context, ...outerArgs.concat(innerArgs) ); 当作为构造函数时，this 指向实例，此时this instanceof returnFn结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值以上面的是 demo 为例，如果改成 this instanceof returnFn? null : context，实例只是一个空对象，将 null 改成 this当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context 4. 构造函数效果的优化实现 但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转： Function.prototype._bind = function (context) { const that = this; const outerArgs = Array.prototype.slice.call(arguments, 1); const _Transit = function(){}; const returnFn = function () { const innerArgs = Array.prototype.slice.call(arguments); return that.call( this instanceof returnFn ? this : context, ...outerArgs.concat(innerArgs) ); }; _Transit.prototype = this.prototype; returnFn.prototype = new _Transit(); return returnFn; }; 这里相当做了个私有变量（匿名构造函数类似的），外部是不能访问到的，所以如果后续做returnFn的原型修改，也只是改在了这个私有构造函数new出来的实例上的，这个实例的[[Prototype]]指向的是真正的this原型。 5. 最后做一个日常判定this是否为函数if (typeof this !== &quot;function&quot;) { throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;); } 6.最终代码Function.prototype._bind = function (context) { if(typeof this !== &#39;function&#39;){ // MDN上的 throw new Error(&#39;Function.prototype.bind - what is trying to be bound is not callable&quot;&#39;) } const that = this; const outerArgs = Array.prototype.slice.call(arguments, 1); const _Transit = function(){}; const returnFn = function () { const innerArgs = Array.prototype.slice.call(arguments); return that.call( this instanceof returnFn ? this : context, ...outerArgs.concat(innerArgs) ); }; _Transit.prototype = this.prototype; returnFn.prototype = new _Transit(); return returnFn; }; 测试let o = { address: &#39;fujian&#39; } function Person(name, age){ this.name = name; this.age = age; } const NewPerson = Person._bind(o, &#39;weng&#39;); const per1 = new NewPerson(23); console.log(per1); 最终打印的是这样的 image-20210604150133583 正常打印出来是这样的，差了一个标识的问题， 这个无所谓了 image-20210604150802371 let o = { address: &#39;fujian&#39; } function sayHi(name, age){ console.log(this.name = name, this.age = age, this.address); } const hi = sayHi.bind(o, &#39;weng&#39;); hi(23); // weng 23 fujian","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"原型链","slug":"原型链","permalink":"https://github.com/NollieLeo/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"name":"bind","slug":"bind","permalink":"https://github.com/NollieLeo/tags/bind/"},{"name":"原型","slug":"原型","permalink":"https://github.com/NollieLeo/tags/%E5%8E%9F%E5%9E%8B/"}]},{"title":"手写instanceof","date":"2021-06-02T09:45:33.000Z","path":"2021/06/02/手写instanceof/","text":"手写instanceof instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 原理instanceof 运算符用来检测 constructor.prototype是否存在于参数 object 的原型链上。 就是找对象原型链上是否有某个构造函数的原型 实现function _instanceof(obj, fn){ let proto = obj.__proto__; let prototype = fn.prototype; while(true){ if(prototype === null){ return false; } if(proto === prototype){ return true; } proto = prototype.__proto__; } } 首先将实例的[[Prototype]]指针赋值给proto对象，这里指向的是此对象构造函数的原型 之后将构造函数的原型赋值给prototype，这里要排除原型指向null的情况； 之后不断的循环，将原型的原型付给prototype，一层层向上查找，直到等于proto或者为null的情况下退出循环 因为Object.prototype.__proto__是指向null的，所以到这里还找不到，那就说明目标构造函数不在原型链上面 测试function BasePerson(){} function Person(){} Person.prototype = new BasePerson(); // 这里使用继承 const a = new Person(); console.log(_instanceof(a, Person)) // true console.log(_instanceof(a, BasePerson)) // true","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"原型链","slug":"原型链","permalink":"https://github.com/NollieLeo/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"name":"原型","slug":"原型","permalink":"https://github.com/NollieLeo/tags/%E5%8E%9F%E5%9E%8B/"},{"name":"instanceof","slug":"instanceof","permalink":"https://github.com/NollieLeo/tags/instanceof/"}]},{"title":"手写call, apply","date":"2021-06-02T03:04:59.000Z","path":"2021/06/02/手写call-apply/","text":"手写call，apply这应该是面试最傻逼的题目了， 这类 native code ，用js怎么能实现的完美呢？？？ 首先先理解一下call, apply具体做了些啥事情 原理1. 调用形式首先调用call或者apply的都是函数 function Person(address){ this.name = &#39;weng&#39;; this.address = address; } const obj = { age: 23, } Person.call(obj, &#39;fujian&#39;); // 这里new console.log(obj); image-20210602111202474 2. 传入的参数 call和apply 的区别在于传参的写法不同： call 是一个一个参数传，而apply是以数组的形式传入 const args = [1,2,3,4]; Fn.call(obj, ...args); Fn.apply(obj, args); 实现首先先写一个_call的方法 那这个_call要挂在哪里呢？对，就是Fn函数的原型上，那要怎么挂呢？直接原型挂 Function.prototype._call = function(target, ...args){ } target指向对象，args就是其他参数 1. 判断是否是函数(this)来调用_callFunction.prototype._call = function(target, ...args){ if(typeof this !== &#39;function&#39;){ throw new Error(&#39;must be a function&#39;) } } 2. 判断传进来的target是否为基本数据类型如果target是基本数据类型，是无法将函数附加到target上面的，通过instanceof可以顺着原型链找到Object的构造函数的数据类型才可以被附加函数。否者就直接把这个数据返回，因为我看call就是这样做的 Function.prototype._call = function(target, ...args){ if(typeof this !== &#39;function&#39;){ throw new Error(&#39;must be a function&#39;) } if(!target instanceof Object){ return target } } 3. 对象是否是被冻结或者封闭的状态这里的对象如果被冻结或者处于封闭的状态那么，后续调用函数给对象做赋值操作也会失效，所以这里还需要判断一层，具体的对象冻结和对象封闭可以看看这Object.freeze() 和 Object.seal() Function.prototype._call = function(target, ...args){ if(typeof this !== &#39;function&#39;){ throw new Error(&#39;must be a function&#39;) } if(!target instanceof Object){ return target } if(Object.isFrozen(target) || Object.isSeal(target)){ return target } } 3. target必须是目标对象，如果不传值，默认为windowFunction.prototype._call = function(target, ...args){ if(typeof this !== &#39;function&#39;){ throw new Error(&#39;must be a function&#39;) } if(!(target instanceof Object){ return target } if(Object.isFrozen(target) || Object.isSeal(target)){ return target } target = target || window; } 4. 隐式绑定，改变构造函数的调用者间接改变 this 指向Function.prototype._call = function(target, ...args){ if(typeof this !== &#39;function&#39;){ throw new Error(&#39;must be a function&#39;) } if(!(target instanceof Object){ return target } if(Object.isFrozen(target) || Object.isSeal(target)){ return target } target = target || window; target.fn = this; // 隐式绑定，改变构造函数的调用者间接改变 this 指向 let result = target.fn(...args) return result; } 这里我看很多人用了 target.fn去将this指向这个参数，但是万一这个fn本身就在target当中声明了呢？ 这里我的想法是以一个符号作为键，保存这个键名，之后调用和赋值就不怕出问题了，因为声明新得符号的引用只是暂时的，也不可能存在重复的情况，之后删除也方便 改善之后的代码为： Function.prototype._call = function(target, ...args){ if(typeof this !== &#39;function&#39;){ throw new Error(&#39;must be a function&#39;) } if(!(target instanceof Object){ return target } if(Object.isFrozen(target) || Object.isSealed(target)){ return target } target = target || window; const fn = Symbol(&#39;fn&#39;); target[fn] = this; // 隐式绑定，改变构造函数的调用者间接改变 this 指向 let result = target[fn](...args); delete target[fn]; // 这里要把这玩意删了 return result; } 测试正常传function Person(address) { this.name = &quot;weng&quot;; this.address = address; } let obj = { name: &quot;weng&quot;, }; let arr = [1, 2, 3, 4]; let set = new Set([1, 2, 3, 4]); let map = new Map([ [&quot;key1&quot;, 1], [&quot;key2&quot;, 2], ]); let stringObj = new String(&quot;2121&quot;); let numberObj = new Number(1212); let booleanObj = new Boolean(false); Person._call(obj, &quot;fujian&quot;); Person._call(arr, &quot;fujian&quot;); Person._call(set, &quot;fujian&quot;); Person._call(map, &quot;fujian&quot;); Person._call(stringObj, &quot;fujian&quot;); Person._call(numberObj, &quot;fujian&quot;); Person._call(booleanObj, &quot;fujian&quot;); console.log(obj); console.log(arr); console.log(set); console.log(map); console.log(stringObj); console.log(numberObj); console.log(booleanObj); 打印出来的是酱紫的 image-20210602160711663 image-20210602161119496 传基本数据类型数据const symb = Symbol(&quot;dsadas&quot;); const num = 1212; const str = &quot;1212&quot;; const isNull = null; const isUndefined = undefined; const isBoolean = false; Person._call(symb, &quot;fujian&quot;); Person._call(num, &quot;fujian&quot;); Person._call(str, &quot;fujian&quot;); Person._call(isNull, &quot;fujian&quot;); Person._call(isUndefined, &quot;fujian&quot;); Person._call(isBoolean, &quot;fujian&quot;); console.log(symb, num, str, isNull, isUndefined, isBoolean); 最终打印出来的是酱紫的 image-20210602162033860 传一个冻结或者封闭的对象const obj = Object.freeze({ key: 1, }); const obj2 = Object.seal({ key: 2, }); Person._call(obj, &quot;fujian&quot;); Person._call(obj2, &quot;fujian&quot;); console.log(obj); console.log(obj2); 打印结果是这样： image-20210602162721877 直接调用Person.call(); 那这时候作用对象在浏览器里头就是window了，构造函数里头的赋值操作可以在window对象里头体现。 最终代码优化了一哈子 Function.prototype._call = function (target, ...args) { if (typeof this !== &quot;function&quot;) { throw new Error(&quot;must be a function&quot;); } if ( !(target instanceof Object) || Object.isFrozen(target) || Object.isSealed(target) ) { return target; } target = target || window; const fn = Symbol(&quot;fn&quot;); target[fn] = this; // 隐式绑定，改变构造函数的调用者间接改变 this 指向 let result = target[fn](...args); delete target[fn]; return result; }; 不晓得对不对反正自己感觉 一般","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"call","slug":"call","permalink":"https://github.com/NollieLeo/tags/call/"},{"name":"apply","slug":"apply","permalink":"https://github.com/NollieLeo/tags/apply/"}]},{"title":"手写new","date":"2021-06-01T07:27:54.000Z","path":"2021/06/01/手写new/","text":"手写new操作符要手写new的操作实现 必须先了解new的过程发生了什么 创建一个新得对象（obj） 将新对象的__proto__指向构造函数的prototype 将构造函数的this执行这个新对象（obj） 执行构造函数中的代码(为这个新对象添加属性和方法); 返回这个新对象;（这里构造函数可能会显式返回值，得做处理，可以看看 构造函数返回值 那篇文章） 总结就是需要实现以下的功能： 让实例可以访问到私有的属性 实例可以访问到构造函数原型所在链上的属性（也就是原型链） 针对构造函数显式返回的值做处理 步骤首先先写出一个叫做 _new的函数，类似构造函数的传参形式 structFn: 函数 args: 给构造函数传的参数 function _new(structFn, ...args){ } 1. 第一个参数类型判断structFn 指的就是构造函数，首先明白一点，new操作符后头只能够跟随函数，要先做类型判断(ES6中的class也是一样的) function _new(structFn, ...args) { if (typeof structFn !== &quot;function&quot;) { throw &#39;structFn must be a function&#39; } } 2. 创建新对象，并且克隆构造函数的原型，将原型赋值给新对象的[[Prototype]]指针function _new(structFn, ...args) { if (typeof structFn !== &quot;function&quot;) { throw &#39;structFn must be a function&#39; } let obj = new Object; obj.__proto__ = Object.create(structFn.prototype); } 3. 执行构造函数中的初始化逻辑，并且将this指向新对象这里声明res变量，将构造函数的this指向了新对象，并且将args剩余参数传入构造函数，保存执行构造函数之后返回值存在res function _new(structFn, ...args) { if (typeof structFn !== &quot;function&quot;) { throw &quot;structFn must be a function&quot;; } let obj = new Object(); obj.__proto__ = Object.create(structFn.prototype); let res = fn.call(obj, ...args); } 4. 对构造函数执行之后的返回值做处理因为根据构造函数的返回值情况来看，比较值得注重的就是返回一个引用类型的时候，和返回null 以及基本数据类型的时候区别，引用类型（比如new String() new Object() {} new Number() 这些的）就直接返回了，null以及基本数据类型就默认返回this function _new(structFn, ...args) { if (typeof structFn !== &quot;function&quot;) { throw &quot;structFn must be a function&quot;; } let obj = new Object(); obj.__proto__ = Object.create(structFn.prototype); let res = fn.call(obj, ...args); const isObject = typeof res === &quot;object&quot; &amp;&amp; res !== null; const isFunction = typeof res === &quot;function&quot;; return isFunction || isObject ? res : obj; } 这里通过isObject和isFunction来确定返回值的类型 测试首先检测一下 function _new(structFn, ...args) { if (typeof structFn !== &quot;function&quot;) { throw &quot;structFn must be a function&quot;; } let obj = new Object(); obj.__proto__ = Object.create(structFn.prototype); let res = structFn.call(obj, ...args); const isObject = typeof res === &quot;object&quot; &amp;&amp; res !== null; const isFunction = typeof res === &quot;function&quot;; return isFunction || isObject ? res : obj; } function Person(name) { this.name = name; } const per1 = _new(Person, &#39;weng&#39;); const per2 = new Person(&#39;weng&#39;); console.log(per1); console.log(per2); 这里分别打印出使用 new操作符和_new函数的实例 image-20210601175133106 这里会发现，我们自己写的_new操作函数得出的实例[[Prototype]]指针的指向指向的是Person实例，通过Person实例链接到Person构造函数的原型的，这是因为这里包了一层 Object.create(structFn.prototype) 相当于这里通过原型式继承，克隆了一份构造函数的原型对象，出发点是为了不在使用多余构造函数的情况下，实现数据共享, 原理其实如下 function object(o){ function Fn(){}; Fn.prototype = o; return new Fn(); }; 我觉得没必要，直接让，structFn.prototype也就是构造函数的原型直接等于新对象的[[Prototype]]特性就行 于是就改为 obj.__proto__ = structFn.prototype; 之后打印出其他相关的 console.log(per1.__proto__); console.log(per2.__proto__); console.log(Object.getPrototypeOf(per1) === Object.getPrototypeOf(per2)); console.log(Person.prototype.isPrototypeOf(per1)); console.log(Person.prototype.isPrototypeOf(per2)); console.log(per1 instanceof Person); console.log(per2 instanceof Person); 结果如下: image-20210602104007880 OK成功手写了一个new，接下来就再试试能不能写call, aplly, bind这些用c/c ++写的底层代码","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"构造函数","slug":"构造函数","permalink":"https://github.com/NollieLeo/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"name":"new","slug":"new","permalink":"https://github.com/NollieLeo/tags/new/"}]},{"title":"构造函数的返回值","date":"2021-06-01T07:15:30.000Z","path":"2021/06/01/构造函数的返回值/","text":"构造函数的返回值在使用new 操作符去执行构造函数的时候，构造函数的返回值会决定了最终构建出来的实例是长什么样子的 例如以下例子 function Person(){ this.name = &#39;weng&#39;; } const per1 = new Person(); console.log(per1); 一般情况下构造函数是不需要返回值的，默认是返回this，内部的这些行为都会指定到this 但是有些面试题就要你整活，所以还是了解以下返回值对初始化后的实例的影响吧 // return; // 返回 this // return null; // 返回 this // return this; // 返回 this // return false; // 返回 this // return &#39;hello world&#39;; // 返回 this // return 2; // 返回 this // return {}; // 返回 新建的 {}, person.name = undefined // return []; // 返回 新建的 [], person.name = undefined // return function(){}; // 返回 新建的 function，抛弃 this, person.name = undefined // return new Boolean(false); // 返回 新建的 boolean，抛弃 this, person.name = undefined // return new String(&#39;hello world&#39;); // 返回 新建的 string，抛弃 this, person.name = undefined // return new Number(32); // 返回 新的 number，抛弃 this, person.name = undefined 总结一下，构造函数中直接 return 一个非引用类型值或者null，会直接返回this对象；如果返回一个复杂对象或是 new 关键字初始化的对象，会直接返回此对象，也就是引用类型值。","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"构造函数","slug":"构造函数","permalink":"https://github.com/NollieLeo/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"}]},{"title":"继承之寄生式组合继承","date":"2021-05-31T08:53:22.000Z","path":"2021/05/31/继承之寄生式组合继承/","text":"寄生式组合继承在组合式继承的那篇文章说过，组合式继承，会将父类的构造函数调用两次。 本质上，子类原型最终式要包含超类的所有实例属性，子类的构造函数只要在执行适合重写原型就行了 再看看组合式继承的例子 function SuperType(name){ this.name = name; this.numbers = [1,2,3,4]; } SuperType.prototype.sayName = function(){ console.log(this.name); } function SubType(name, age){ SuperType.call(this, name); this.age = age; } SubType.prototype = new SuperType(); SubType.constructor = SubType; SubType.prototype.sayAge = function(){ console.log(this.age); } 这个详细过程如下： image-20210531170936146 image-20210531171003754 可以看出这里重复调用了SuperType函数。 为了解决这个，引出了了寄生组合式继承 原理通过盗用构造函数继承属性，但使用混合式原型链继承的方法。基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。 说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型 function inheritPrototype(subType, superType){ let prototype = object(superType.prototype); // 创建对象 prototype.constructor = subType; // 增强对象 subType.prototype = prototype; // 赋值对象 } inheritPrototype函数接受两个参数，子构造函数和父类构造函数 创建父类原型的一个副本 给返回的原型对象设置constructor属性设置为自身，解决原型覆盖丢失constructor的问题 最后将新创建的对象赋值给子类型的原型 这里只调用了一次父类构造函数，避免了SubType原型上不必要的属性。 而且原型键也保持不变，因此instanceof操作符和isPrototypeOf()方法正常有效。 寄生式组合继承可以算是引用类型继承的最佳模式","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"构造函数","slug":"构造函数","permalink":"https://github.com/NollieLeo/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"name":"原型链","slug":"原型链","permalink":"https://github.com/NollieLeo/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"name":"原型","slug":"原型","permalink":"https://github.com/NollieLeo/tags/%E5%8E%9F%E5%9E%8B/"},{"name":"继承","slug":"继承","permalink":"https://github.com/NollieLeo/tags/%E7%BB%A7%E6%89%BF/"},{"name":"组合式继承","slug":"组合式继承","permalink":"https://github.com/NollieLeo/tags/%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF/"},{"name":"寄生式组合继承","slug":"寄生式组合继承","permalink":"https://github.com/NollieLeo/tags/%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF/"}]},{"title":"继承之寄生式继承","date":"2021-05-31T08:45:34.000Z","path":"2021/05/31/继承之寄生式继承/","text":"寄生式继承寄生式继承背后的思路类似于寄生 构造函数和工厂模式 思路如下： 创建一个实现继承的函数，这里只要是能返回对象的函数就行，例如 原型式继承的object函数（Object.create()） 然后以某种方式增强对象，返回对象 例子： function create(o){ let clone = object(o); clone.sayHi = function(){ console.log(&#39;hello world&#39;); } return clone; } 寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的情况下。 寄生式继承存在问题通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"原型","slug":"原型","permalink":"https://github.com/NollieLeo/tags/%E5%8E%9F%E5%9E%8B/"},{"name":"继承","slug":"继承","permalink":"https://github.com/NollieLeo/tags/%E7%BB%A7%E6%89%BF/"},{"name":"原型式继承","slug":"原型式继承","permalink":"https://github.com/NollieLeo/tags/%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF/"},{"name":"工厂模式","slug":"工厂模式","permalink":"https://github.com/NollieLeo/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"name":"寄生式继承","slug":"寄生式继承","permalink":"https://github.com/NollieLeo/tags/%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF/"}]},{"title":"继承之原型式继承","date":"2021-05-31T08:18:56.000Z","path":"2021/05/31/继承之原型式继承/","text":"原型式继承这是一种不涉及严格意义上构造函数的继承方式 这个思路就是，不需要自定义一个类型，就可以通过原型实现对象之间的信息共享 就仍然是为了实现对象之间的信息共享 目标函数如下 function object(o){ function F(){} F.prototype = o; return new F(); } 思路如下： object函数会创建一个 临时 的构造函数在函数作用域内，退出函数就直接销毁的那种 将传入的对象赋值给这个临时构造函数的原型，然后返回这个临时构造函数的实例 其实本质上是对这个传入的object进行一次浅复制 function object(o) { function F() {} F.prototype = o; return new F(); } let person = { name: &quot;weng&quot;, numbers: [1, 2, 3, 4], }; let person2 = object(person); person2.name = &quot;kaimin&quot;; person2.numbers.push(5); let person3 = object(person); person3.name = &quot;helloworld&quot;; person2.numbers.push(6); console.log(Object.getPrototypeOf(person)); console.log(Object.getPrototypeOf(person2)); console.log(Object.getPrototypeOf(person3)); console.log(person2.name); console.log(person3.name); console.log(person3.numbers); console.log(person.name); console.log(person.numbers); 这是最终的打印结果 image-20210531163110860 这里的person, person2, person3之间的数据都是共享的 Object.create()ES5将这种原型式继承的概念规范化了。 Object.create()接受两个参数 作为新对象原型的对象 给新对象定义的额外属性对象 只有在传第一个参数的时候，Object.create与这里的object()方法一样 Object.create()的第二个参数与Object.defineProperties第二个参数一样：每一个新增的属性都通过各自的描述符来描述。这种方式添加的的属性会遮蔽原型对象上的同名属性 实际上和原型模式一样的，只是不需要显式的去创建构造函数了。适用于需要在对象之间共享信息的场合","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"原型链","slug":"原型链","permalink":"https://github.com/NollieLeo/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"name":"原型","slug":"原型","permalink":"https://github.com/NollieLeo/tags/%E5%8E%9F%E5%9E%8B/"},{"name":"继承","slug":"继承","permalink":"https://github.com/NollieLeo/tags/%E7%BB%A7%E6%89%BF/"},{"name":"原型式继承","slug":"原型式继承","permalink":"https://github.com/NollieLeo/tags/%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF/"}]},{"title":"继承之组合继承","date":"2021-05-31T03:14:09.000Z","path":"2021/05/31/继承之组合继承/","text":"组合继承（伪经典继承）组合继承综合了原型链和盗用构造函数，将两者的优点集中起来了。 基本思路是： 使用原型链继承原型上的属性和方法 再通过盗用构造函数继承实例属性 如下例子： function SuperType(name){ this.name = name; this.numbers = [1,2,3,4]; } SuperType.prototype.sayName = function(){ console.log(this.name); } function SubType(name, age){ SuperType.call(this, name); this.age = age; } SubType.prototype = new SuperType(); SubType.prototype.sayAge = function(){ console.log(this.age); } let instance1 = new SubType(&#39;weng&#39;, 23); instance1.numbers.push(5); console.log(instance1.numbers); // 1,2,3,4,5 instance1.sayName(); // weng instance1.sayAge(); // 23 let instance2 = new SubType(&#39;helloworld&#39;, 24); console.log(instance2.numbers); // 1,2,3,4 用以上的方式创建的实例，可以实现自身的属性是独立的，方法可以是共享的 组合继承是js中用的最多的继承模式 而组合继承也保留了instanceof操作符和isPrototypeOf()方法识别合成对象的能力 可以执行一下语句检验一下，其实这篇文章和原型那块的例子一样，那边更解释了实例和这两个构造函数之间的关系 console.log(SubType.prototype); console.log(SubType.prototype.isPrototypeOf(instance1)); console.log(SuperType.prototype.isPrototypeOf(instance1)); console.log(SuperType.prototype.isPrototypeOf(SubType.prototype)) console.log(Object.getPrototypeOf(instance1)); console.log(instance1.__proto__); console.log(instance1.__proto__.constructor); console.log(SubType.prototype.constructor); 组合继承的问题看以上的组合继承代码，你会发现这里的超类也就是SuperType被实例化了两次 在SubType将其原型覆盖为SuperType构造函数new出来的实例的时候 在SubType构造函数创建实例的时候，构造函数内部直接调用了SuperType，这里又初始化了一次 造成的问题就是，SuperType创建出来的实例，也就是此时SubType的原型，会带有SuperType构造函数初始化的参数，并且，SubType构造函数创建出来的实例，也会带着SuperType的属性，这里就重复了。","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"构造函数","slug":"构造函数","permalink":"https://github.com/NollieLeo/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"name":"原型链","slug":"原型链","permalink":"https://github.com/NollieLeo/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"name":"原型","slug":"原型","permalink":"https://github.com/NollieLeo/tags/%E5%8E%9F%E5%9E%8B/"},{"name":"继承","slug":"继承","permalink":"https://github.com/NollieLeo/tags/%E7%BB%A7%E6%89%BF/"},{"name":"组合式继承","slug":"组合式继承","permalink":"https://github.com/NollieLeo/tags/%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF/"}]},{"title":"继承之盗用构造函数","date":"2021-05-31T02:41:46.000Z","path":"2021/05/31/继承之盗用构造函数/","text":"盗用构造函数（对象伪装）为了解决原型中包含引用值的问题，引出盗用构造函数的一种方法 基本思路：在子类的构造函数中调用父类的构造函数，使用aplly()和call()方法以新创建的对象为上下文执行构造函数。 例如： function SuperType(){ this.numbers = [1,2,3,4]; } function SubType(){ SuperType.call(this); } let instance1 = new SubType(); instance1.numbers.push(5); console.log(instance1.numbers); // [1,2,3,4,5] let instance2 = new SubType(); console.log(instance2.numbers); // [1,2,3,4]; 以上的盗用，即让SuperType构造函数在为SubType的实例创建的新对象的上下文中执行了。这就是相当于在新的SubType对象上运行了SuperType构造函数中的所有初始化代码。结果就是每一个实例都有自己的numbers属性 1. 传递参数相比于原型链的使用，盗用构造函数优点就是，可以在子类构造函数中向父类构造函数传参数。 function SuperType(name){ this.name = name; } function SubType(){ SuperType.call(this, &#39;weng&#39;); this.age = 23; } let instance = new SubType(); console.log(instance.name); // weng 为了确保调用SuperType的时候覆盖了SubType自身定义的属性，最好先调用父函数之后再给子类添加额外属性 2. 盗用构造函数的问题这个问题显而易见 也是必须再构造函数中定义方法，因此函数不能重用 子类也不能访问父类原型上定义得方法，因此所有类型只能使用构造函数模式 由于存在这些问题，盗用函数也不能单独使用， 可以看看 继承之组合继承 这篇文章","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"构造函数","slug":"构造函数","permalink":"https://github.com/NollieLeo/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"name":"原型链","slug":"原型链","permalink":"https://github.com/NollieLeo/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"name":"原型","slug":"原型","permalink":"https://github.com/NollieLeo/tags/%E5%8E%9F%E5%9E%8B/"},{"name":"继承","slug":"继承","permalink":"https://github.com/NollieLeo/tags/%E7%BB%A7%E6%89%BF/"}]},{"title":"继承之原型链","date":"2021-05-31T01:53:23.000Z","path":"2021/05/31/继承之原型链/","text":"继承之原型链首先再明确一下构造函数，原型，实例之间关系 每一个构造函数都有一个原型对象 原型对象有个属性叫做constructor指回构造函数 实例是用构造函数创建出来的，它有一个指针[[Prototype]]指向其构造函数的原型，也可以说是实例的原型 按照上面的说法，假设，如果一个原型是另一个类型的实例，那就意味着这个原型本身有一个内部指针指向他的构造函数的原型，也就是它的原型，相应的另外一个原型也有一个指针指向另外一个构造函数。所以 在实例和原型之间构造了一条原型链 实现一条原型链的代码如下： function SuperType(){ this.property = true; } SuperType.prototype.getSuperValue = function(){ return this.property; } function SubType(){ this.subproperty = false; } // 这里直接继承SuperType，将原型指向SuperType的实例 SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function(){ return this.subproperty; } let instance = new SubType(); console.log(instance.getSuperValue()); // true; 以下是他们的原型链图： image-20210531100430978 这个例子继承的关键就是在于，将SubType的默认原型设置为了SubType的实例，这样SubType的实例不仅能从superType的实例中继承属性方法，而且还和SuperType挂钩了 这个时候 instance内部的[[Prototype]]指向SubType.prototype SubType.prototype通过内部的[[Prototype]]指向了SuperType.prototype 调用或者访问实例的一个属性，这个搜索过程是逐级向上的，如果实例上没有找到属性或者方法就回去原型上找，如果还没有，就去原型的原型上找，直到一直找到Object.prototype.__proto__为null的时候，就是一直找到原生对象的原型指向的原型（原型链末端） 上面的例子实际的原型链是如下图所示的 image-20210531101503489 原型链存在的问题原型链毕竟也是由原型搭起来的，这个时候就包含了原型存在的问题 在原型那篇文章说过 问题一原型中包含引用值的时候，会在实例间共享 所以为什么通常一些属性是定义在构造函数中，而不是直接存在原型上 问题二子类型在实例化的时候不能够给父类型的构造函数传参数。 实际上我们还无法在不影响所有对象实例的情况下把参数传给父类的构造函数。 所以原型链基本不会被单独使用 这个时候就衍生出了解决原型链存在问题的几种继承方案 例如 盗用构造函数 组合继承 原型式继承 寄生式继承 寄生组合式继承","tags":[{"name":"原型链","slug":"原型链","permalink":"https://github.com/NollieLeo/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"name":"原型","slug":"原型","permalink":"https://github.com/NollieLeo/tags/%E5%8E%9F%E5%9E%8B/"},{"name":"继承","slug":"继承","permalink":"https://github.com/NollieLeo/tags/%E7%BB%A7%E6%89%BF/"}]},{"title":"算法之滑动窗口","date":"2021-05-30T12:58:43.000Z","path":"2021/05/30/算法之滑动窗口/","text":"leetcode第209道题目 链接 题目是 image-20210530205955854 题解 image-20210530210433266 /** * @param {number} target * @param {number[]} nums * @return {number} */ var minSubArrayLen = function (target, nums) { let left = 0; let right = 0; let minL = Infinity; let sum = 0; while (right &lt; nums.length) { sum += nums[right]; while (sum &gt;= target) { minL = Math.min(minL, right - left + 1); sum -= nums[left]; left++; if (sum &lt; target) { break; } } right++; } return minL === Infinity ? 0 : minL };","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"https://github.com/NollieLeo/tags/%E7%AE%97%E6%B3%95/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://github.com/NollieLeo/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"创建对象之原型模式","date":"2021-05-30T05:42:33.000Z","path":"2021/05/30/创建对象之原型模式/","text":"原型模式每一个函数都会创建一个prototype的属性 原型方式 function Person(){} Person.prototype.name = &#39;weng&#39;; Person.prototype.age = 23; Person.sayName = function(){ console.log(this.name); } let per1 = new Person(); ler per2 = new Person(); per1.sayName(); // weng 1.与构造函数的不同原型模式是直接再构造函数的prototype属性上加对象和相应的属性（也就是再构造函数的原型对象上面加属性） 与构造函数不同的是，使用这种原型模式定义的属性和方法，之后创建出来的实例，都是一起共享这些属性的，因此 上述的per1和per2的sayName()函数指向的是同一个指针, 他们的原型也同样都是Person构造函数指向的原型对象 console.log(per1.sayName = per2.sayName); 2. 理解原型自定义构造函数的时候，原型对象，也就是构造函数的原型对象（prototype指向的对象），会自动获得一个constructor的属性，这个属性是重新指向自定义的构造函数，如果没有父类的话，其他的所有方法都是继承于js内部的Object对象的所有方法。 console.log(Person.prototype.constructor === Person; // true; 例如，根据上述的Person自定义构造函数创建一个实例 let per1 = new Person() 这个过程是这样的 per1实例（对象）内部的[[Prototype]]指针就会被赋值为Person构造函数的原型对象（也就是Person.prototype） per1可以访问Person的原型上所有属性 js脚本中是没有访问[[Prototype]]特性的标准方式，但是谷歌浏览器火狐还有safari会在每一个对象上暴露__proto__属性，这个属性可以直接访问构造函数的原型也就是这个实例的原型 但是，实例是和构造函数没有直接的联系的，只和构造函数的原型又关联 console.log(Person.prototype === per1.__proto__); // true; Object的原型的原型是null console.log(Person.prototype.__proto__ === Object.prototype) // true console.log(Person.prototype.__proto__.constructor === Object); //true console.log(Person.prototype.__proto__.__proto__ === null); 1 如图可以看出实例，构造函数，构造函数的原型之间的关系 这里比较重要的点在于 构造函数的原型（Person.prototype）的constructor属性是指回Person构造函数的 实例和构造函数之间没有直接联系 所有通过同一个构造函数构建出来的实例，其中[[Prototype]]指针是指向构造函数的原型。 3. 检查实例原型1. instanceof由实例直接调用，去判断实例的原型链中是否有某个构造函数的原型 这里一定要注意，是判断某个构造函数的原型 console.log(per1 instanceof Person); // true console.log(per1 instanceof Object); // true; console.log(Person.prototype instanceof Object); // true; 如第二大点的图1可以看清这样的继承关系，继承关系另一篇文章再说 2. isPrototypeOf这个方法是为了确定两个对象之间原型的关系 因为如第2大点所说，不是所有的实现都对外暴露的[[Prototype]]的指针 所以可以直接在原型上去调用这个方法检测某个对象是否的[[Prototype]]的指针是否指向它，因此也能够检测出两个对象之间的关系 console.log(Person.prototype.isPrototypeOf(per1)); // true; 3. Object.getPrototypeOf()这个方法会返回参数的内部[[Prototype]]的指针（这个[[Prototype]]也其实就是参数的特性，可以去一篇叫做对象的属性特性详解的文章查看） 这个函数传入一个 实例， 返回这个实例的原型对象，也就是它的构造函数的原型对象 console.log(Object.getPrototypeOf(per1)===Person.prototype); Object.getPrototypeOf(per1).name; // weng 4. *Object.setPrototypeOf()这个方法可以给实例的[[Prototype]]指针写入一个新的值，这样可以重写一个实例的原型继承关系 let a = { name: &#39;weng&#39;; age:23 }; let b = { name: &#39;kaimin&#39; } Object.setPrototypeof(b, a); console.log(b.name) // kaimin console.log(b.age) // 23 console.log(Object.getPrototypeOf(b) === a); // true; 这里不推荐使用这种覆盖实例原型指向的方式改变原型继承的关系，会严重的影响代码的性能。 Mozilla文档中说的“在所有浏览器和js的引擎中，修改继承关系的影响都是微妙而且深远的。这种影响并不是执行以上这个代码那么简单，而是会涉及到所有访问了那些修改过 [[Prototype]]指向的实例的代码” 因为有上述的弊端，可以看另外一篇文章，继承之原型式继承 中讲到的创建新对象的形式，也就是类似于Object.create()来创建一个新对象，同时给他指定一个原型，这块继承会在继承文章中详细解释 let a = { name: &#39;weng&#39;; age:23 }; let b = Object.create(a); b.name = &#39;kaimin&#39;; console.log(b.name) // kaimin console.log(b.age) // 23 console.log(Object.getPrototypeOf(b)) // a Object.create这种形式其实是以匿名构造函数的形式，指定这个匿名函数的原型为你想要的那个实例，因为这里咱们只是在乎这个新创建的实例（这里指的是b）他的[[Prototype]]的指向是否是指向所需对象（这里指的是a）的，完全可以跳过显示创建构造函数的形式，使用这个方法不仅仅不会改变原来实例（这里指的是a）的[[Prototype]]指向，而且又让新实例的原型指向了a，就很棒，这里具体还是去继承那边文章看 4.原型的层级例如以下代码 function BasePerson(){ this.country = &#39;China&#39;; this.age = 23; } function Person(){ this.name = &#39;weng&#39;; } Person.prototype = new BasePersn(); const per1 = new Person(); per1.address = &#39;fujian&#39;; console.log(per1.age) // 23 以上代码的各个关系如下图所示； image-20210530163634192 这里比较重要的是Person.prototype，这里手动给他赋值给了new BasePerson()构造出来的实例，后面又手动的给把他的constructor属性赋值给了Person，这里为什么呢？本文最后会说明 之后呢，Person的原型对象中有了BasePerson构造函数内部初始化的时候的一些参数 按照这上面的层级关系 per1.name; // weng per1.address; // fujian per1.age; // 23 这里其实都是可以访问到的 在通过实例访问属性的时候，会按这个属性的名称开始搜索，一层层往上走，一开始搜索实例本身是否有这些属性 ，如果有就返回，如果没有继续通过 [[Prototype]]的指针向上搜索原型。 constructor只存在于原型对象上面，其实也可以通过访问实例的原型指针来访问这个constructor 如果有存在同名属性的话，实力上创建的会覆盖原型上的，但不至于改变原型上的同名属性，只是给他盖住看不见了 1.删除实例中的属性delete操作符号可以删除实例上面定义的属性值，调用时候，这个实例的原型上的值不会被删除 要删除的话得直接在原型上做操作 例如上面的代码构建的实例per1 delete per1.address; console.log(per1.address) // undefined 通过删除实例上的属性，可能会暴露出原型上的同名属性，这里的话具体而论，那怎么判断这个属性是在原型上还是在实例上的呢？ 2. 判断属性在原型上还是在实例上1. hasOwnProperty()这个方法可以用来判断某个属性是否在实例上面（这个函数不进入实例的原型中去搜索指定属性） 这个方法直接在实例上调用，继承至Object构造函数的原型对象，如果害怕实例的中有同名方法的话可以使用Object.prototype.hasOwnProperty.call(this)来调用 比如上面的per1实例在没有删除addrss的情况下 per1.hasOwnProperty(&#39;address&#39;); // true; per1.hasOwnProperty(&#39;name&#39;); // true; per1.hasOwnProperty(&#39;age&#39;); // false; per1.age实际上返回的是这个实例原型上的age，hasOwnProperty是访问不到的 那如果要确定是否原型上有这个值呢？不用per1[‘….’]来判断 2. inin操作符有两种使用方式 在for-in中使用 单独使用 这里先说说单独使用in，下面得第5点说for-in in操作符号可以通过对象访问指定属性时候返回true，无论是在原型上还是在实例上面，都可以访问的到 例如上面的per1对象 console.log(&#39;name&#39; in per1); // true console.log(&#39;address&#39; in per1); // true console.log(&#39;age&#39; in per1); // true 3. 确定实例的某个属性不在实例上，只在原型上结合第4大点的第二小点的两个操作符，可以确定一个函数 function hasPrototypeProperty(object,name){ return !object.hasOwnProperty(name) &amp;&amp; (name in object); } 4. 获取实例的属性1. Object.keys()获取实例上的属性（仅仅是实例上可枚举属性）2. for-in遍历实例以及其原型上的所有属性（仅仅是可枚举属性）3.Object.getOwnPropertyNames()获取仅仅是实例上的属性（是否可枚举都能获取）例如： 正常来说，一个实例的原型对象上的constructor属性都是不可以枚举的，是不能够通过1，2两个方法获取的 let keys = Object.getOwnPropertyNames(Person.prototype); console.log(keys); // [...., &#39;constructor&#39;] 4. Object.getOwnPropertySymbols() 仅仅针对符号针对实例属性（是否枚举都可以）let k1 = Symbol(&#39;k1&#39;); let o = { [k1]: &#39;helloworld&#39; } console.log(o); // [Symbol(k1)] 5. 属性的枚举顺序以上可以总结几种获取实例或者实例原型上的一些属性的方法 for-in Object.keys() Object.getOwnPropertyNames() Object.getOwnPropertySymbols(); 这里涉及到获取属性的顺序，还有一个Object.assign这类浅层复制对象的方式 for-in以及Object.keys()获取到的属性值的顺序是确定的，取决于js的引擎 Object.getOwnPropertyNames()，Object.getOwnPropertySymbols(); 以及Object.assign得出来的属性的枚举顺序都是确定的。 按照以下规则： 先升序枚举数值键 以插入顺序枚举字符串和符号键 对象字面量中定义的键，以逗号分隔的顺序插入 例如： let k1 = Symbol(&#39;k1&#39;), k2 = Symbol(&#39;k2&#39;); let o = { 1: 1, first:&#39;first&#39;, [k1]:&#39;hello&#39;, second:&#39;second&#39;, 0:0 } o[k2] = &#39;world&#39;; o[3] = 3; o.third = &#39;third&#39;; o[2] = 2; console.log(Object.getOwnPropertyNames(0)); // [&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;first&quot;,&quot;second&quot;,&quot;third&quot;]; console.log(Object.getOwnPropertySymbols(o)); // [Symbol(k1),Symbol(k2)]; 6. 原型中存在的问题 弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值 原型上引用值属性的问题 第一点是显而易见的 第二点中举个例子 function Person(){} Person.prototype.arr = [1,2,3,4]; let per1 = new Person(); let per2 = new Person(); per1.arr.push(5); console.log(per2.arr) // [1,2,3,4, 5]; 引用类型的arr定义在原型上，这时候对per1上的arr属性进行修改，因为per1实例上不存在arr的属性，那么会找到原型中的arr，这时候通过arr.push是直接作用在原型中的arr的，所以，引用类型属性之间的共享特性导致per2.arr访问的也是原型上的arr，意思就是引用类型访问的都是一个指针，就特么和对象一样。 本篇文章中留下来的疑问1. constructor手动赋值的情况以上第4大点中的层级关系代码中，手动将原型中的constructor赋值给了Person function BasePerson(){ this.country = &#39;China&#39;; this.age = 23; } function Person(){ this.name = &#39;weng&#39;; } Person.prototype = new BasePersn(); Person.prototype.constructor = Person; const per1 = new Person(); per1.address = &#39;fujian&#39;; console.log(per1.age) // 23 因为在这个例子中，Person.prototype被手动设置为一个BasePerson构建函数构建出来的新实例，这个过程相当于重写了Person构造函数的原型，这样重写之后，Person.prototype就不再指向自身的Person，由本文开头说的一样，函数构建的时候会默认创建原型，也就是prototype对象，也会自动给原型的contructor赋值，这个写法完全覆盖了默认的prototype，造成了constructor不再指向自身的构造函数，而是指向了Object构造函数Object(){} 这个时候就不在能够通过constructor属性来识别是什么类型了，还是得用instanceof 再比如下面的代码 function Person(){ } let f = new Person(); Person.prototype = { name:&#39;weng&#39;, sayName(){ console.log(this.name); } } f.sayName(); // 报错，sayName is not a function 这是为什么呢？ 由于f实例是在重写Person原型之前就已经构建出来了的，它的[[Prototype]]指针指向的原型对象是一开始Person构造函数所指向的，那本身就不存在sayName这个方法，这时候Person的原型被覆盖了，和f一点关系都没有； 这就解释了为什么不能用实例访问constructor来判断类型标识了得用intanceof 那这时候来解决上面手动赋值constructor的问题 如果constructor的值很重要，可以在上述代码中加入 function Person(){ } let f = new Person(); Person.prototype = { constructor: Person, name:&#39;weng&#39;, sayName(){ console.log(this.name); } } 这样就可 但是又存在个问题 咱们知道原型上的constructor的属性是不可枚举的，也就是constructor本身这个属性的特性[[Enumberable]]特性是false，但是这样定义的constructor属性是可以枚举的，那这个时候可以看看 那篇 对象属性特性的文章，然后定义这个属性","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"原型模式","slug":"原型模式","permalink":"https://github.com/NollieLeo/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"创建对象之构造函数模式","date":"2021-05-28T13:10:48.000Z","path":"2021/05/28/创建对象之构造函数模式/","text":"ES中的构造函数是用来创建特点类型的对象的，像Object和Array这样的原生构造函数，直接再环境中能用。 当然也可以自定义构造函数 就得自定义属性和方法了 定义构造函数例如下面是一个工厂模式的函数，将他改造成构造函数形式 function createPerson(name, age){ let o = new Object(); o.name = name; o.age = age; o.sayName = function(){ console.log(this.name); } return o; } // 改成构造函数 function Person(name,age){ this.name = name; this.age = age; this.sayName = function(){ console.log(this.name) } } let per1 = new Person(&#39;weng&#39;, 20); per1.sayName(); // weng 当然也可以这样定义和new构造函数 let Person = function(){ ..... } let person1 = new Person; // 不传参可以不加括号 当然构造函数也是函数，调用方式也很多 Person(&#39;weng&#39;, &#39;23&#39;); // 这种也可以，但是这样构建出来的实例会被添加到window上去 window.sayName() // weng 也可以在另一个对象作用域中调用 let o = new Object(); Person.call(o, &#39;weng&#39;, 23); o.sayName() // weng 这里要记住，调用一个函数没有明确的指定this的情况下（即没有作为对象的方法调用，或没有使用call或者apply转换this指向的话，this始终指向Global对象（浏览器中式window） 构造函数与工厂模式区别在上面例子中只是用Person()构造函数替代了createPerson()工厂函数。实际上内部是和createPerson一样的。 区别在于 没有显示的去new一个object 属性和方法都直接赋值了this 没有return 1. 以new操作符去调用构造函数会执行以下操作 在内存中创建一个新对象 这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype 构造函数内部的this被赋值为这个新对象（就this指向了第一步的新对象） 执行构造函数内部代码 如果构造函数返回非空对象，则返回该对象；否者返回刚创建的新对象 这里如果返回值是一个非空对象，那这个对象的行为会默认覆盖构造函数在第四步对创建的内存对象进行操作得出的行为，如果返回其他类型值是不会的； 这块设计到原型和继承方面的东西，在原型继承那边文章可以看 2. 自定义构造函数确保实例被标识为特定类型相比于工厂模式，这是一个很大的好处 例如： const person1 = new Person(); console.log(person1.contructor == Person); // true console.log(person1 instanceof Person) // true; 创建出来的person1的protype会指向它的原型对象，这个原型对象里头有个属性叫做contructor是回指向Person构造函数的，可以用person.contructor和person1 instanceof Person来判断 相当于有个标识，告诉这个实例是哪个构造函数创建出来的 但是一般来说用instanceof来判断对象类型是更可靠的方式 构造函数的问题问题很明显 就是在实例上定义的方法会在创建每个实例的时候都会再去创建一次 let per1 = new Person(); let per2 = new Person(); console.log(per1.sayName === per2.sayName) // false 因为都是调用同一种行为的函数，可能有些时候参数不同，但是行为一样的就没必要再去创建一个 这个时候会考虑把公共函数提出去到外部 function sayName(){ console.log(this.name) } function Person(name,age){ this.name = name; this.age = age; this.sayName = sayName; } 这样解决了不重复创建new Function的问题，因为每个实例sayName指针都是指向外部同一个函数； 但是这样缺陷也很明显啊 全局作用域乱了，如果内部有很多方法，那不得再全局再创建多个函数 所以这时候需要原型模式，另一篇文章看","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"构造函数","slug":"构造函数","permalink":"https://github.com/NollieLeo/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"name":"new","slug":"new","permalink":"https://github.com/NollieLeo/tags/new/"}]},{"title":"js的类型转换","date":"2021-05-28T02:55:50.000Z","path":"2021/05/28/js的类型转换/","text":"自我检测[] == ![] // -&gt; true D部分有答案 显式类型转换和隐式类型转换强制转换经常发生在动态类型语言运行时。我们经常会写类型转换，如： var a=1 var b=a+&#39;&#39; // 隐式 &#39;1&#39; var c=String(a) // 显式 &#39;1&#39; 这里的隐式和显式是相对于开发者而言的。可以从代码中看出来类型转换的是显式，反则为隐式。 A.抽象值操作1.ToString非字符串-&gt;字符串。 基本类型null -&gt; &#39;null&#39; undefined -&gt; &#39;undefined&#39; true -&gt; &#39;true&#39; 1 -&gt; &#39;1&#39; 1 * 1 000 000 000 000 000 000 000 -&gt; &#39;1e+21&#39; 复杂类型当对象有自己的toString()方法，字符串化时就会调用该方法，使用其返回值。 const obj={ a:&#39;test&#39;, toString(){ return &#39;yeah~~&#39; } } //没有自定义的toString()方法应该返回[object Object]111， console.log(obj+&#39;111&#39;) // yeah~~111 JSON字符串化对于大多数简单值来说，JSON.stringify()和toString()的效果基本相同，序列化的结果总是字符串。有一个比较特殊的情况： JSON.stringify(&#39;hello&#39;) // &quot;&quot;hello&quot;&quot; 含有双引号的字符串 对于undefined、function、symbol来说会返回undefined，在数组中返回null、在对象中自动忽略。 JSON.stringify(undefined) // undefined JSON.stringify(function(){}) // undefined JSON.stringify([function(){},2]) // &quot;[null,2]&quot; JSON.stringify({a:function(){},b:2}) // &quot;{&quot;b&quot;:2}&quot; const obj={ a:&#39;test&#39;, toJSON(){ return &#39;yeah~~&#39; } } console.log(JSON.stringify(obj)) 答案： &quot;yeah~~&quot; 2.ToNumber基本类型true -&gt; 1 false -&gt; 0 undefined -&gt; NaN null -&gt; 0 处理字符串失败时返回NaN。 复杂类型对象（包括数组），先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则按照上面的规则强制转换为数字。 将值转换为相应的基本类型值，先检查该值是否有valueOf()方法，有并且返回基本类型值，则使用该值进行强制类型转换；没有就使用toString()的返回值进行强制转换。如果以上都不返回基类型值，产生TypeError错误。 const obj={ toString(){ return &#39;1&#39; } } console.log({}) // NaN console.log(Number(obj)) // 1 注意使用Object.create(null)创建的对象，无法进行强制转换！是因为其[[Prototype]]为空，没有valueOf()和toString()方法。 3.ToBoolean假值（falsy value）js中的值可被分为两类：可被强制转换为false的值，和其他（可以被强制转换为true的值）。 以下这些为假值： undefined null fasle +0 -0 NaN &quot;&quot; 虽然没有明确规定，我们可以默认除了这些值以外的所有值为真值。 B.显式强制类型转换字符串和数字之间的显式转换一般通过String()和Number()这两个内建函数实现的。如： String(1) // &quot;1&quot; Number(&#39;1.25&#39;) // 1.25 通过一元运算符以及toString()也被认为是显示强制类型转换。 +&#39;25&#39; // 25 日期显示转换为数字一元运算符有一个常用的用途是，将Date对象强制转换为Unix时间戳，如： +new Date() // 1516625381333 我们也可以使用更显式的方法： new Date().getTime() // 1516625518125 最好还是使用Date.now()来获得当前的时间戳。 位操作符~~运算符，按位非，反转操作符的比特位。位操作符会强制操作数使用32位格式，通过ToInt32实现（ToInt32先执行ToNUmber强制转换，之后再执行ToInt32）。如果你不太明白他的运算机制，请记住一个公式： ~4 -&gt; -5 ~x =&gt; -(x+1) ~在日常开发中很少会用到，但在我们处理indexOf()时，可以将结果强制转换为真/假值。 const str=&#39;hello&#39; str.indexOf(&#39;a&#39;) // -1 ~str.indexOf(&#39;a&#39;) //0 -&gt; 假值 ~~x还可以用来截除小数部分，如： ~~-22.8 -&gt; -22 显式解析数字字符串解析和转换的区别使用parseInt()将字符串解析为数字，它与Number的作用并不一样： parseInt只能解析字符串，传入其他类型参数，如true、function(){}等，返回NaN。 parseInt可以解析含有非数字字符的字符串，如parseInt(&#39;2px&#39;)将会解析为2，Number则会返回NaN。 对于parseInt有一个经典的例子， parseInt(1/0,19) -&gt; 18 这是因为1/0为Infinity，先被转化为字符串&#39;Infinity&#39;，第一个字符为i，在js中有效数字为09和0i，所以之后的n不会被解析，只解析到i为止，i为第18位，所以输出为18. 显式转换为布尔值和上面的Number(),String()一样，Boolean()为显式的ToBoolean强制类型转换。但这个在开发中并不常用，通常使用!!来进行强制类型转换。 在if()...上下文中，如没有使用Boolean()或!!转成布尔值，则会进行隐式转换。但还是建议使用显式转换，让代码可读性更高。 C.隐式强制类型转换1.字符串和数字之间的隐式转换+/-操作符+如何判断是进行字符串拼接，还是数值加法呢？ +的其中一个操作符为字符串（或是通过ToPrimitive抽象操作后转换为字符串的值）则进行字符串拼接，否则执行数字加法。 所以，通常上我们将空字符串与数值进行拼接，将其转换为字符串。 const a=&#39;2&#39; const b=a-0 b // -&gt; 2 通过-也可将a强制转换为数字，或者使用a*1或a/1，因为这两个运算符只适用于数字，所以比较少见。 const a=[1] const b=[3] a-b // -&gt; -2 2.隐式类型转换为布尔值在以下情况中，非布尔值会被隐式转换为布尔值。 if()中的判断表达式 for(;;)中的条件判断表达式 while(…)和do..while(..)循环中的条件表达式 ? : 中的条件判断表达式 逻辑运算符 || 和 &amp;&amp; 左边的操作数。 但&amp;&amp;和||返回的值并不一定是布尔值，而是两个操作书中其中的一个。如： 123||&#39;hello&#39; // 123 42&amp;&amp;&#39;abc&#39; // &#39;abc&#39; null || &#39;hello&#39; // -&gt;&#39;hello&#39; null &amp;&amp; &#39;hello&#39; // -&gt;null 3.Symbol的强制类型转换ES6允许从符号到字符串得显示类型转换，但使用隐式转换会报错。 const s1=Symbol(&#39;test&#39;) String(s1) -&gt; &quot;Symbol(test)&quot; &#39;&#39;+s1 -&gt; Uncaught TypeError: Cannot convert a Symbol value to a string 同时，Symbol类型也不能被转换为数字（无论是显式还是隐式），但可以被转换为布尔值。 D.宽松相等（ == ）和严格相等（ === ）==允许在相等比较中进行强制类型转换，但===则不允许。 宽松相等的转换规则（==） 对于基本类型：两个值的类型相同，则比较是否相等。 除了NaN（NaN是js中唯一不等于自身的值）和+0/-0（+0 === -0）。类型不同的两个值参考第三条。 对于对象（包括函数和数组）：他们指向同一引用时，即视为相等，不发生强制转换。 在比较两个不同类型的值时，会发生隐式类型转换，将其转为相同的类型后再比较。 字符串和数字之间的相等比较const a=&#39;12&#39; const b=12 a==b //true a===b //false 规则为：==两边，哪边为数值类型，则另一边转为数值类型。 其它类型和布尔类型之间的相等比较const a=&#39;12&#39; const b=true a==b // false a为真值，为什么返回false 因为在==两边，哪边为布尔类型，哪边转为数值类型！！ 同样，a==false也会返回false，因为这里的布尔值会被强制转换为数字0. null和undefined之间的相等比较只要记住： null == undefined //true null === undefined //false 对象和非对象之间的相等比较对于布尔值和对象之间的比较，先把布尔值转换为数值类型。 数值或字符串与对象之间的比较，对象先会调用ToPromitive抽象操作，之后再转为数值进行比较。 const a=12 const b=[12] a==b //true b-&gt;&#39;12&#39;-&gt;12 const c=Object(null) c==null //fasle 这里c被转换为空对象{} const d=Object(undefined) d==undefined // fasle 这里d被转换为空对象{} const e=Object(NaN) e==NaN // fasle 这里e被转换为Number(NaN) -&gt; NaN 但NaN不等于自身，所以为false 几个典型的坑// 小坑 &quot;0&quot; == false // -&gt; true 这里false先被转为0，&quot;0&quot;也会转为0，所以为true &quot;0&quot; == &quot;&quot; // -&gt; false 两个都是字符串类型，直接比较 0 == &#39;&#39; // -&gt; true 空字符串直接转为0 false == [] // -&gt; true false先转为0；[]空数组转为&#39;&#39;，之后ToNumber操作转为0 // 大坑 [] == ![] // -&gt; true [] 这里![]先被强制转换为false，变成[]与fasle的比较，之后fasle-&gt;0；[]-&gt;&#39;&#39;-&gt;0，所以为true。 2=[2] // -&gt; true [2]-&gt;&#39;2&#39;-&gt;2 所以为true &#39;&#39;==[null] // true [null]-&gt;&#39;&#39; 0==&#39;\\n&#39; // -&gt; true &#39;\\n&#39;-&gt;&#39;&#39;-&gt;0 &#39;true&#39;==true // -&gt; false true-&gt;0;&#39;true&#39;-&gt;NaN，所以为false 如果你还是一头雾水的话，请仔细阅读D部分这几种相互比较的规则和C部分的隐式类型转换。只要记住，遇到两个不同类型的值，转换优先顺序为布尔值&gt;对象&gt;字符串&gt;数字；每一步的转换到相同类型的值即停止转换，进行比较判断。 E.抽象关系比较出现非字符串就先转为数字类型；如果两者都为字符串，按照字母顺序来比较，如： [&#39;22&#39;]&lt;[&#39;023&#39;] // -&gt; false 这里并不转为数字，0在字母顺序上小于2，所以为false 22&lt;[&#39;023&#39;] // -&gt; true 对于对象来说，也同样是转换成字符串，再进行比较，如: const a={a:1} const b={a:2} a&gt;b // -&gt; false a&lt;b // -&gt; false a==b // -&gt; false a&lt;=b // -&gt; true a&gt;=b // -&gt; true 这个例子比较奇怪，虽然他们转成字符串都为[Object Object]，但两个对象的比较并不是转为字符串，而是看他们的引用是否指向同一值。这里&lt;=被处理为!&gt;，所以为true； &gt;=同理。","tags":[{"name":"类型转换","slug":"类型转换","permalink":"https://github.com/NollieLeo/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"name":"==","slug":"","permalink":"https://github.com/NollieLeo/tags/"},{"name":"===","slug":"","permalink":"https://github.com/NollieLeo/tags/"}]},{"title":"面试需要知道点","date":"2021-05-28T02:28:41.000Z","path":"2021/05/28/面试需要知道点/","text":"1.JS 类型有哪些？2.TCP,HTTP,CDN3.大数相加、相乘算法题，可以直接使用 bigint，当然再加上字符串的处理会更好。4.NaN如何判断5.instanceof` 原理 ✔6.手写 instanceof ✔7.类型转换隐式转换和强制转换 ✔8.this, 箭头函数9.闭包 ✔10.new, 手写new，new做了哪些事？new 返回不同类型的时候是什么表现 ✔11.作用域，作用域链，全局作用域，函数作用域，块级作用域 ✔12.原型，原型链，原型继承， js中是如何实现继承的，通过原型实现的继承和class有什么区别，手写任意一种原型继承 ✔13.深拷贝，浅拷贝✔14.Promise** all、race ， 使用all实现并行需求， 手写all的实现 页面上有三个按钮，分别为 A、B、C，点击各个按钮都会发送异步请求且互不影响，每次请求回来的数据都为按钮的名字。 请实现当用户依次点击 A、B、C、A、C、B 的时候，最终获取的数据为 ABCACB。 15.async, await16.浏览器渲染也页面过程含义浏览器缓存（Browser Caching）是为了加速浏览，浏览器在用户磁盘上岁最近请求过的文档进行存储，当用户再次访问这个文档时，浏览器会从本地磁盘显示此文档，从而提升页面加载速率。 cache的作用 减少延迟，让网站的运行速度更快，带来更好的用户体验； 避免网络拥塞，减少请求量，减少输出带宽； 实现手段cache-control中的max-age是实现内容cache的重要手段，常用的策略有以下三种： max-age和ETag的组合； 仅max-age； max-age和Last-Modified（If-Modified-Since）的组合； 拓展在此，拓展一下有关强制缓存（200）和协商缓存（304）部分的内容。 强制缓存（也称强缓存），指当浏览器去请求某个文件的时候，服务端就在respone header里面对该文件做了缓存配置。强制缓存不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码; 协商缓存：强制缓存给资源设置了过期时间，在未过期时，可以说是给用户自给自足用的。但是当资源过期时，就需要去请求服务器，这时候请求服务器的过程就可以设置成协商缓存。协商缓存就是需要客户端和服务端进行交互的。协商缓存将缓存信息中的Etag和Last-Modified通过请求发给服务器，由服务器校验，返回状态码304时，浏览器就可以直接使用缓存。 共同点： 都是从客户端中读取数据； 区别： 强缓存不会发出请求，协商缓存会发出请求。 缓存中header（头部）的参数： （1）、强制缓存： Expires（常用）：response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。 Cache-Control（常用）：当值设为max-age=120时，则代表在这个请求正确返回时间（浏览器也会记录下来）的2分钟内再次加载资源，就会命中强缓存。 no-cache：不使用本地缓存。需要使用缓存协商，来验证是否过期； no-store：不可缓存； public：客户端和代理服务器都可缓存； private：只能有客户端缓存； （2）、协商缓存 Etag：即文件hash，每个文件唯一。web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）； If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etag声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定是否命中协商缓存； Last-Modify/If-Modify-Since：文件的修改时间，精确到秒。浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间；当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存； 🌈🌈注意： Etag要优于Last-Modified； 在优先级上，服务器校验优先考虑Etag； 在性能上，Etag要逊于Last-Modified。 17.如何性能优化18.CDN 优化有哪些， CDN是什么19.webpack 插件原理，如何写一个插件20.手写 bind ✔、reduce21.防抖截流 ✔22.遍历树，求树的最大层数。求某层最多的节点数23.前端模块化的理解24.隐式转换25.数字在计算机怎么储存的26.知道什么是事件委托吗？概念： 事件冒泡是指嵌套最深的元素触发一个事件，然后这个事件顺着嵌套顺序在父元素上触发。而事件委托，是利用事件冒泡原理，让自己所触发的事件，让其父元素代替执行。 冒泡阻止方式：使用event.cancelBubble = true或者event.stopPropgation()（低于IE9）。 默认事件阻止方式： e.preventDefault();或return false;。 27.window的onload事件和domcontentloaded谁先谁后？28.macrotask 和 microtask29.浏览器缓存,HTTP缓存 对比缓存？强缓存？对应请求头30.commonjs和esmodule31.xss攻击和csrf攻击32.时针和分针的夹角33.Javascript的事件流模型都有什么“事件冒泡”： 当触发一个节点的事件时，会从当前节点开始，依次触发其祖先节点的同类型事件，直到DOM根节点。（逐级向上） “事件捕获”： 当触发一个节点的事件时，会从DOM根节点开始，依次触发其祖先节点的同类型事件，直到当前节点自身。（逐级向下） “DOM事件流”： dom同时支持两种事件模型，但捕获性事件先开始，从document开始也结束于document，dom模型的独特之处在于文本也可以触发事件。简单的说分为三个阶段：事件捕捉， 目标阶段， 事件冒泡 34.js延迟加载的方式有哪些？defer属性（页面load后执行）：脚本会被延迟到整个页面都解析完毕之后再执行。若是设置了defer属性，就等于告诉浏览器立即下载，但是会延迟执行。注意defer属性只适用于外部脚本文件。 async 属性（页面load前执行）：为了不让页面等待脚本下载和执行，异步加载页面和其他内容。async同样也只适用于外部文件（不会影响页面加载，但是不能控制加载的顺序）。 动态创建DOM方式； 使用jQuery的getScript()方法； 使用setTimeout延迟方法； 让js文件最后加载。 35.Cookie在客户机上是如何存储的cookies是服务器暂时放在我们电脑里的文本文件，好让服务器来辨认我们的计算机。 当我们在浏览网站的时候，web服务器会先发送小部分资料放在我们的计算机中，cookies会帮助我们，将我们在网站上打印的文字或一些选择记录下来，当我们再次访问同一个网站，web服务器会先检查有没有它上次留下的cookies资料。 若有，会依据cookies里面的内容来判断使用者，从而给我们推出相应的网页内容。 36.DOM和BOM是什么首先我们需要知道：javascript是由ECMAScript，DOM，BOM三部分构成的。 ECMAScript是一种语言，是对规定的语法，操作，关键字，语句的一个描述，javascript实现了ECMAScript; DOM是文档对象模型，包括了获取元素，修改样式以及操作元素等三方面的内容，也是通常我们用的最多的操作，其提供了很多兼容性的写法； BOM是浏览器对象模型，包括浏览器的一些操作，window.onload, window.open等还有浏览器时间，监听窗口的改变onresize，监听滚动事件onscroll等； 37.如何实现多个标签之间的通信 调用 localStorage； （1）、在一个标签内使用localStorage。setItem(key, value)添加（删除或修改）内容； （2）、在另一个标签页面监听storage事件； （3）、得到localStorage存储的值，即可实现不用页面之间的通信。 调用 cookie+setInterval()； （1）、将要传递的信息存储在cookie中，可以设置定时读取cookie的信息，即可随时获取想要传递的信息。 使用 Webworker； （1）、webworker作为浏览器的一个新特性，可以提供一个额外的线程来执行一些js代码，并且对浏览器用户界面不影响； （2）、普通的Webworker用 new worker()即可创建，这种webworker是当前页面专有的。然后还有种共享worker(SharedWorker)，这种是可以多个标签页、iframe共同使用； 使用 SharedWorker； （1）、SharedWorker可以被多个window共同使用，但必须保证这些标签页都是同源的(相同的协议，主机和端口号)； 38. js垃圾回收的几种方式javascript具有自动垃圾回收机制，垃圾器回收会按照固定的时间间隔周期性的执行。 常见的垃圾回收机制有两种： 标记清除，引用计数。 标记清除原理： 当变量进入环境时，将这个变量标记为“进入环境”。当变量离开时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。 工作流程： 垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记； 去掉环境中的变量以及被环境中的变量引用的变量的标记； 再被加上标记的会被视为准备删除的变量； 垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间； 引用计数原理： 跟踪记录每个值被引用的次数，声明一个变量，并将引用 类型赋值给这个变量，则这个值的引用次数+1，当变量的值变成了另一个，则这个值的引用次数-1，当值的引用次数为0的时候，就回收。 工作流程： 声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用值的引用次数就是1； 同一个值又被赋值给另一个变量，这个引用类型值此时的引用次数+1； 当包含这个引用类型值的变量又被赋值成另一个值，那么这个引用呢性值的引用次数-1； 当引用次数变成0时，说明目前无法访问此值； 当垃圾收集器下一次运行时，它会释放引用次数是0的值所占的内存； 39.在浏览器中输入URL到整个页面显示在用户面前时这个过程中到底发生了什么（1）、DNS解析 检查浏览器自身的DNS缓存； 若没有，搜索操作系统自身的DNS缓存； 若没有，尝试读取hosts文件； 若没有，可向本地配置的首选DNS服务器发起请求； .win系统若没有好到，可以操作系统查找NetBIOS name cache或查询wins服务器或广播查找或读取LMHOSTS文件； （若以上都没有，则解析失败） （2）、TCP三次握手 img （3）、浏览器向服务器发送http请求 一旦建立了TCP链接，web浏览器就会向web服务器发送请求命令。 （4）、浏览器发送请求头信息 浏览器发送其请求命令之后，还要以头信息的形式想web服务器发送一些别的信息，之后浏览器发送了一空白行开通知服务器，它已经结束了该头信息的发送。 （5）、服务器处理请求 服务器收到http请求之后，确定用相应的一眼来处理请求。读取参数并进行逻辑操作后，生成指定的数据。 （6）、服务器做出响应 客户端向服务器发送请求后，服务端向客户端做出应答。 （7）、服务器发送应答头信息 正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据以及被请求的文档。 （8）、服务器发送数据 web服务器向浏览器发送信息后，它会发送一个空白行来表示头信息的发送到此结束。接着，它会以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。 （9）、 TCP关闭（四次挥手） 一般情况下，一旦web服务器向浏览器发送了请求数据，它就要关闭tcp链接。如果浏览器或服务器在其头信息加入了Connection:keep-alive,则会保持长连接状态，也就是TCP链接在发送后仍保持打开状态，浏览器可以继续通过仙童的链接发送请求。 （优点：保持链接节省了为每个请求建立新链接所属的时间，还节约了网络宽带 ） img","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试","slug":"面试","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"js对象属性详解","date":"2021-05-27T12:21:37.000Z","path":"2021/05/27/js对象属性详解/","text":"ECMA-262使用一些内部特性来描述属性的特征。这些特征是由为js实现引擎的规范定义的，开发者在js中不能直接访问这些特性，描述内部特性，一般会把这个特性括起来类似这样[[Enumerable]] 属性的类型属性分两种 数据属性 访问器属性 1. 数据属性数值属性包含一个保存数据值的位置。 以下有4种特性描述他们的行为 [[Configurable]]： 表示属性以下特性。（默认情况下是true） 是否可以通过 delete删除并且重新定义 可以修改他的特性 是否可以把它改为访问器属性 [[Enumberable]]：表示属性。（默认情况是true） 是否可以通过 for-in循环返回 [[Writable]]：表示这个属性的值是否可以被修改呢，默认情况为true [[Value]]：包含属性实际的值。（这个就是数据属性保存数据值的位置，值会从这个位置读取，以及写入）默认值是undefined 1. 修改属性的默认特性例如： let person = { name: &#39;weng&#39; } // 这里name属性的特性[[Value]]就会被赋值为 weng // 而其他的特性默认都是为true 假如要 修改特性需要用到对象的 Object.defineProperty方法 这个方法接受三个参数 要给添加属性的对象，属性名称， 一个描述符对象（就是相关特性的描述属性，configurable，writable, enumerable, value） let person = {}; Object.defineProperty(person, &quot;name&quot;, { writable: false, value: &#39;weng&#39; }); // 这里设置了`[[Writable]]`属性为false，表示这个属性不能再被修改了 console.log(person.name) // weng person.name = &#39;helloworld&#39;; // 修改无效 console.log(person.name) // weng 上述这种情况，在严格模式之下尝试修改属性会抛出错误 创建一个不可配置的属性如下 let person = {}; Object.defineProperty(person, &#39;name&#39;, { configurable: false, value: &#39;weng&#39; }) // 这里把对象的[[Configurable]]特性设置为false delete person.name; // 删除无效 console.log(person.name) // weng 这里如果修改了[[Configurable]]特性为不可配置，之后都不能再变回可配置的了，如果再调用Object.defineProperty把这个特性设置为true会报错 并且设置这个特性为false，如果没有定义其他特性，那么其他特性都默认为false 2. 访问器属性访问器属性是不包含数据值的。 他们包含一个（getter）函数和一个（setter）函数； 读取属性时候调取 getter 决定了应该怎么返回值， 设置属性的时候调用 setter，setter函数告诉你怎么对数据做出修改 有四个属性描述他们的行为 [[Configurable]]：默认情况下为true 是否可通过delete删除并重新定义 是否可以修改它的特性 是否可以把他改为数据属性 [[Enumerable]]： 默认情况下为true 表示属性是否可以通过 for-in循环- [[Get]]： 获取函数，在读取属性时候调用。默认值为undefined [[Set]]： 设置函数，在写入属性时候调用。默认值为undefined 和数据属性一样，访问器的属性也是不能直接定义的，必须使用Object.defineProperty() 如下例子： const book = { year_: 2021, // 表示私有属性不能被外部访问 edition: 1 } Object.defineProperty(book, &quot;year&quot;, { get(){ return this.year_; } set(newValue){ if(newValue &gt; 2021){ this.year_ = newValue; this.edition += newValue - 2021 } } }) book.year = 2022; console.log(book.edition) // 2 以上是访问器属性的经典使用场景 获取函数和设置函数不一定都需要定义 只定义获取函数意味着属性是只读的 当然可以以上的Object.defineProperty只能定义单个属性，可以使用Object.defineProperties来定义多个属性值以及特性 let book = {} Object.defineProperties(book, { year_:{ value: 2021 }, edition:{ value: 1 }, year: { get(){ .... } set(){ .... } } }) 读取属性的特性1. Object.getOwnPropertyDescriptor()使用 Object.getOwnPropertyDescriptor()方法可以获取指定属性的属性描述符。 接受两个参数 属性所在对象，以及要取得其描述符号的属性名（数据属性，和访问器属性）。返回一个对象 例如： let book = {}; Object.defineProperties(book, { year_:{ value: 2021 }, edition:{ value: 1 }, year: { get(){ .... } set(){ .... } } }) let desc = Object.getOwnPropertyDescriptor(book,&quot;year_&quot;); let descYear = Object.getOwnPropertyDescriptor(book, &quot;year&quot;); desc的值如下 image-20210527212616268 image-20210527212733518 descYear值如下： image-20210527212917495 image-20210527213001469 2. Object.getOwnPropertyDescriptors()es2017新增的静态方法，这个方法会在每个自有属性上调用Object.defineProperties console.log(Object.getOwnPropertyDescriptors(book)); 打印出来的如下 image-20210527214742659 注意：这两个方法只对实例属性有效果，是不能取得原型属性上的描述符，如果需要取得原型属性上的描述符，就得直接再原型对象上面直接调用这两个方法","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"object","slug":"object","permalink":"https://github.com/NollieLeo/tags/object/"}]},{"title":"如何对两个超大数字字符串做相加操作","date":"2021-05-26T08:23:49.000Z","path":"2021/05/26/如何对两个超大数字字符串做相加操作/","text":"如何对两个超大数字字符串做相加操作var a = &#39;10000000000000000000000&#39; var b = &#39;456789345678945678945678&#39; function add(a,b) function add(a,b){ // 获取各自长度 a = a.split(&#39;&#39;), b = b.split(&#39;&#39;); let sum=[],go=0; while(a.length || b.length){ // 通过pop每次取一个 let num1 = parseInt(a.pop()) || 0; let num2 = parseInt(b.pop()) || 0; // 两值相加，如果有进位就 + go let tmp = num1 + num2 + go; if(tmp &gt; 9){ go = 1; // 取余数 tmp %= 10; }else{ go = 0; } // array.unshift(item)表示在数组array的最前面插入 sum.unshift(tmp) } if(go) sum.unshift(1); return sum.join(&#39;&#39;); }","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"从页面 A 打开一个新页面 B，B 页面关闭（包括意外崩溃），如何通知 A 页面？","date":"2021-05-26T08:23:49.000Z","path":"2021/05/26/页面通信（从页面 A 打开一个新页面 B，B 页面关闭（包括意外崩溃），如何通知 A 页面？）/","text":"从页面 A 打开一个新页面 B，B 页面关闭（包括意外崩溃），如何通知 A 页面？首先能够拆解一下这个题意 B手动关闭，如何通知A页面 B意外关闭，被线程杀死奔溃的时候如何通知A页面 1. B页面正常关闭的时候1. 首先要回答出页面关闭时会触发的事件是什么？ 页面关闭时先执行window.onbeforeunload，然后执行window.onunload 我们可以在 window.onbeforeunload 或 window.onunload 里面设置回调。 2. 然后回答如何传参？ 最先想到的是：用 window.open 方法跳转到一个已经打开的页面（A页面），url 上可以挂参传递信息。 在 chrome 浏览器下会报错“Blocked popup during beforeunload.” 在 MDN 里找到了解释：HTML规范指出在此事件中调用window.alert()，window.confirm()以及window.prompt()方法，可能会失效。Window: beforeunload event 在火狐浏览器下不会报错，可以正常打开 A 页面。 3. 成功传参后，A 页面是如何监听 URL 的？ onhashchange 是为您排忧解难。Window: hashchange event：当URL的片段标识符更改时，将触发hashchange事件 (跟在＃符号后面的URL部分，包括＃符号) 如果你传参是以 A.html?xxx 的形式，那就需要监听 window.location.href。 // 页面A &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;这是 A 页面&lt;/div&gt; &lt;button onclick=&quot;toB()&quot;&gt;点击打开 B 页面&lt;/button&gt; &lt;script&gt; window.name = &#39;A&#39; // 设置页面名 function toB() { window.open(&quot;B.html&quot;, &quot;B&quot;) // 打开新页面并设置页面名 } window.addEventListener(&#39;hashchange&#39;, function () {// 监听 hash alert(window.location.hash) }, false); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; // 页面B &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;这是 B 页面&lt;/div&gt; &lt;script&gt; window.onbeforeunload = function (e) { window.open(&#39;A.html#close&#39;, &quot;A&quot;) // url 挂参 跳回到已打开的 A 页面 return &#39;确定离开此页吗？&#39;; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 其实传参也可以通过本地缓存传参，A 页面设置监听,在 B 页面设置 loacalStorage // A.html window.addEventListener(&quot;storage&quot;, function (e) {// 监听 storage alert(e.newValue); }); // B.html window.onbeforeunload = function (e) { localStorage.setItem(&quot;name&quot;,&quot;close&quot;); return &#39;确定离开此页吗？&#39;; } 2. 奔溃的情况下这个好鸡儿恼火","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"onbeforeunload","slug":"onbeforeunload","permalink":"https://github.com/NollieLeo/tags/onbeforeunload/"},{"name":"onunload","slug":"onunload","permalink":"https://github.com/NollieLeo/tags/onunload/"}]},{"title":"windo.open(导航与打开新窗口)","date":"2021-05-26T07:59:48.000Z","path":"2021/05/26/windo-open-导航与打开新窗口/","text":"导航与打开新窗口window.open() 用于导航到指定的URL 打开新浏览器窗口 接受4个参数，指定URL，目标窗口（名字），特性字符串，表示新窗口在浏览器历史记录中是否替代当前加载页面的布尔值（一般在不打开新窗口的时候使用） window.open(&quot;https://www.baidu.com/&quot;, &quot;baidu&quot;); // 与&lt;a href=&quot;https://www.baidu.com/&quot; target=&quot;baidu&quot; /&gt; 如果有一个窗口名叫baidu，则这个窗口就会打开这URL；否者就会打开一个新窗口并将其命名为baidu 第二个参数也可以是如下几个 _self _parent _top _blank 1. 弹出窗口window.open会返回一个对象，可以通过调用他的api去操作打开的这个新窗口 const openWindow = window.open(&#39;https://www.baidu.com/&#39;,&#39;baidu&#39;,&#39;height=400,width=500,top=10,left=10,resizable=yes&#39;); // 移动打开的窗口 openWindow.moveTo(100, 100); // 关闭打开的窗口 openWindow.close(); //关闭之后这个对象仍然存在,可以判断它closed属性 window.closed // true; 弹出的窗口可以关闭自己 top.close(); 新建的窗口window对象上有个属性opener,指向他打开的窗口 这个属性只在弹出窗口的最上层window对象有定义,就是指针 opendWidon.opener === window // true 因为有了这个指针,表示的新开的窗口不能独立运行在进程当中,如果需要则需要把opener属性设置为null,与主页面切断链接之后,这个链接是不可以在恢复的 2.判断弹窗是否被屏蔽了浏览器可能存在弹窗屏蔽程序,所以可以通过检测window.open()返回的值是否为null就能确定弹窗是否被屏蔽了 但是有时候window.open都会报错 所以用一层trycatch包裹会好一点 let blocked = false; try{ let openWindow = window.open(&#39;https://baidu.com&#39;,&quot;_blank&quot;); if(openWindow === null){ blocked = true; } } catch(e){ blocked = true }","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"window.open","slug":"window-open","permalink":"https://github.com/NollieLeo/tags/window-open/"},{"name":"导航","slug":"导航","permalink":"https://github.com/NollieLeo/tags/%E5%AF%BC%E8%88%AA/"}]},{"title":"fetch配置请求头下载文件（文件流显示进度）","date":"2021-04-14T02:24:33.000Z","path":"2021/04/14/fetch配置请求头下载文件（文件流显示进度）/","text":"上代码，到时候再写为什么这么做，因为懒 import { WritableStream, } from &#39;web-streams-polyfill/ponyfill&#39;; import StreamSaver from &#39;streamsaver&#39;; const handleFileDownLoad = async (url, username, password, filename) =&gt; { const tempHeader = new Headers(); tempHeader.append(&#39;Authorization&#39;, `Basic ${Base64.encode(`${username}:${password}`)}`); fetch(`${url}?pipelineDownLoad=true`, { method: &#39;GET&#39;, headers: tempHeader, // mode: &#39;no-cors&#39;, // redirect: &#39;manual&#39;, }) .then((response) =&gt; { console.log(response); if (!window.WritableStream) { StreamSaver.WritableStream = WritableStream; window.WritableStream = WritableStream; } const fileStream = StreamSaver.createWriteStream(filename, { writableStrategy: true, readableStrategy: true, }); const readableStream = response.body; if (window.WritableStream &amp;&amp; readableStream?.pipeTo) { return readableStream.pipeTo(fileStream).then(() =&gt; { message.success(&#39;下载成功&#39;); }); } const writer = fileStream.getWriter(); window.writer = writer; const reader = response.body?.getReader(); const pump = () =&gt; reader?.read() .then((res) =&gt; (res.done ? writer.close() : writer.write(res.value).then(pump))); pump(); // message.success(&#39;下载成功&#39;); return true; }).catch((error) =&gt; { throw new Error(error); }); };","tags":[{"name":"fetch","slug":"fetch","permalink":"https://github.com/NollieLeo/tags/fetch/"},{"name":"auth认证","slug":"auth认证","permalink":"https://github.com/NollieLeo/tags/auth%E8%AE%A4%E8%AF%81/"}]},{"title":"js数据类型以及typeOf操作符号","date":"2021-03-14T08:23:49.000Z","path":"2021/03/14/js数据类型以及typeOf操作符号/","text":"ES6有6中 简单数据类型（原始类型）和一种复杂数据类型 简单：Undifined, Null, Boolean, Number, String, Symbol 复杂：object 所有的值都可以用以上7种来表示 typeof操作符ES的类型系统是松散的，typeof可以确定任意变量的数据类型。 typeof对一个值使用会返回的字符串之一 “undefined” 表示值未定义 “boolean” 布尔值 “string” 字符串 “number” 数值 “object” 表示为对象（而不是函数）或者null “function”表示函数 “symbol”表示符号 函数在es中被认为是对象，但是不代表一种数据类型 因此typeof可以很好的区别它和其他对象的区别 类型undefined只有一个值，就是特殊值undefined 当用let或者var 声明了变量但是没有初始化（给一个初始值）的时候，这个变量就相当于赋予了undefined值 let msg; console.log(msg);// undefined 我们不需要显式的去给值赋值一个undefined，因为系统自动都会给未初始化的值赋值undefined *注意: 使用typeof，未声明的变量和未初始化的变量返回都是undefined typeof a; // undefined let b; typeof b; // undefinedNULLnull类型也是同样只有一个值，特殊值Null； null逻辑上讲，表示的是一个空对象指针，毕竟typeof null的时候是‘object’; 因此在定义将来要保存对象值得变量得时候，建议使用null初始化 undefined值是由null值派生而来的，因此ECMA-262将他们定义为表面上相等。 console.log(null == undefined) *==操作符会对数据两头得数据类型进行转换，这个单独写一篇讲 Booleanboolean就两值，true or false； 虽然只有两个值，但是可以通过特定得Boolean()转型函数将其他类型得值转换为布尔值 1.Boolean()转型不同类型值转换为布尔值得转换规则如下 数据类型 转为true 转为false Boolean true false String 非空字符串 “” Undefined N/A(不存在) undefined Number 非0得数值（Infinity） 0, NaN Object 任何对象 null *像一些if等流控制语句会自动得将其他类型值转换为boolean类型值 const a = &#39;2121&#39;; if(a){ console.log(hello); } // hello; *Number最有意思得数据类型了 Number类型使用得是IEEE 754格式表示整数和浮点值 十进制 八进制(0开头，数字0~7) 十六进制（0x开头，数字09，字母AF） let a1 = 55; // 55 let a2 = 070; // 八进制的 56 let a3 = 098; // 无效八进制,自动转为十进制98 1. 浮点数表示：1.1， 1.2 ， 3.125e7， 3.125e-8 *浮点数精确度问题 if(0.1 + 0.2==0.3){ console.log(&#39;hello&#39;) } // 这里的0.1 + 0.2 是不等于0.3的 2. 值得范围内存限制，ES不能表示这世界上所有得 最小值存在：Number.MIN_VALUE中 最大值存在：Number.MAX_VALUE中 如果两个值得运算超过这两个极限值，则会是Infinity表示 3. NaN特殊得数值：NaN，意思就是不是一个数值； 用于本来是要返回数值得操作失败了（不抛错） 1）涉及任何NaN得操作都会返回NaN2）console(NaN == NaN)为false 3）isNaN()函数判断传入得值是否 ”不是数值“ 该函数会将传入得值尝试去转换为数值，任何不能转换为数值得值都会导致这个函数返回true isNaN(NaN) // true isNaN(10) // false isNaN(&#39;10&#39;) // false isNaN(&#39;blue&#39;) //true isNaN(true) // false isNaN可以用于测试对象，首先会去调用对象得valueOf()方法，确定返回得值是否可以转换为数值，如果不行再调用toString()方法并测试返回值； 4. 数值转换有3个函数可以将非数值型数据转为数值 Number(), parseInt(), parseFloat() 1) Number()转型函数可以用于任意类型得数据 转型规则如下 布尔值，true为1，false为0 数值，直接返回数值 null，返回0 undefined，返回NaN 字符串 包含数值字符串，包括前面带着+，- 号得情况，则转换为一个十进制数值 Number(&quot;1&quot;) // 1 Number(&quot;123abc&quot;) // 123 Number(&quot;0111&quot;) // 111 字符串包含浮点值字符串 Number(&quot;1.1&quot;) // 1.1 - 字符串包含有效得十六进制格式，则转换为该十六进制对应得十进制数 ```js Number(&quot;0xA&quot;) // 10 ``` - 空字符串，则返回0 - 除了以上情况外，返回NaN 对象 调用对象得valueOf()方法，并且按照上述规则转换返回得值。如果转换结果是NaN，则再调用对象得toString()方法，再按规则去转换 Number(&quot;hello world&quot;) // NaN 一元加操作符也遵循Number()转换规则 2) ParseInt()此函数更加专注于字符串是否包含数值模式 如果第一个字符不是数值字符， + -符号，则立即返回NaN 空字符串也立即返回NaN parseInt(&quot;123&quot;) //123 parseInt(&quot;123abc&quot;) // 123 parseInt(&quot;&quot;) // NaN parseInt(&quot;0xf&quot;) // 15 parseInt(&quot;07&quot;) // 7 也接受第二个参数 parseInt(&quot;0xAF&quot;,16) // 175 parseInt(&quot;AF&quot;,16) // 175 parseInt(&quot;AF&quot;) //NaN3) ParseFloat()和parseInt相似 String字符串数据类型表示零或者多个16位得Unicode字符序列 1. 字符字面量用于表示非打印字符或者其他用途字符 \\t \\n \\b \\r \\f \\\\ \\&#39; \\&quot; \\` \\xnn \\unnn 如果字符串包含双字节字符，length就不好确定了 2. 字符串特点es中得字符串是不可变的，一旦创建，值就不能再变化，要修改其中一个字符串值，必须先销毁原来得字符串再将包含新值的另一个字符串保存到该变量 3. 转换为字符串（toString &amp; String()）适用于 数值，字符串，布尔值，对象（字符串的toString只是简单的返回自身的一个副本），null和undefined没有这个方法 1）toString()toString再对数值类型进行转换的时候可以传入参数，其他的类型不允许 let num = 10; num.toString(); // &quot;10&quot; num.toString(2); // &quot;1010&quot; num.toString(8); // &quot;12&quot; num.toString(16); // &quot;a&quot; 2) String()如果不确定一个值是否为null或者undefined可以使用String()转型函数 转换规则↓ 如果值有toString()的方法，则调用该方法返回结果 如果只是null返回”null”，undefined返回”undefined” 用加号给一值加上一个空字符串””也可以将其转换为字符串 4. 模板字面量const name = &#39;lihua&#39;; console.log(`hello ${name}`); // hello lihua 模板字面量保留换行符号, 空格 const one = &#39;first line \\nsecond line&#39;; // first line // second line const two = `first line second line`; // first line // second line 模板字面量不是字符串而是一种特殊的js句法表达式，只不过求值之后是字符串 所有的插入值最后都会使用toString()强制转型维字符串，适用与任何的js表达式 let foo = { toString: ()=&gt; &#39;world&#39; }; console.log(`hello ${foo}`); 模板字面量标签函数 let a = 6; let b = 5; function simpleTag(strings, aValExpression, bValExpression, sum){ console.log(strings); console.log(aValExpression); console.log(bValExpression); console.log(sum); return &#39;motherfucker&#39;; } let resUntagged = `${a} + ${b} = ${a + b}`; let resTagged = simpleTag`${a} + ${b} = ${a + b}`; // [&quot;&quot;, &quot;+&quot;, &quot;=&quot;, &quot;&quot;] // 6 // 5 // 11 console.log(resUntagged); // 6 + 9 = 15 console.log(resTagged); // motherfucker 表达式的参数一般可变，所以用…rest 传入 let a = 6; let b = 5; function simpleTag(strings, ...rest){ console.log(strings); for(const express of rest){ console.log(express); } return &#39;motherfucker&#39;; } let resTagged = simpleTag`${a} + ${b} = ${a + b}`; // [&quot;&quot;, &quot;+&quot;, &quot;=&quot;, &quot;&quot;] // 6 // 5 // 11 console.log(resTagged); // motherfucker 如果需要通过一个标签函数得到原始字符串的话 let a = 6; let b = 9; function zipTag(strings, ...rest){ return strings[0] + rest.map((e, i)=&gt;`${e}${strings[i+1]}`).join(&#39;&#39;); } console.log(zipTag`${a} + ${b} = ${a + b}`); // 6 + 9 = 15 原始字符串获取, 可以使用String.raw标签函数，从而获取到不是被转换后的字符 console.log(`hello\\nworld`); // hello // world console.log(String.raw`hello\\nworld`) // &quot;hello\\nworld&quot; 但是对于实际的换行符号是不可以的 Symbol符号属性是对内存中符号的一个引用 1.基本用法let sym = Symbol(); let symV = Symbol(&#39;V&#39;); typeof sym; // symbol 这里不可以使用像Boolean, String, Number那样使用构造函数初始化包装对象 let sym = new Symbol(); // TypeError: Symbol is not a constructor 2.创建全局符号注册表Symbol.for()全局创建符号实现 共享 重用 let globleSym = Symbol.for(&quot;mine&quot;); 第一次调用Symbol.for()会去全局注册一个符号，如果再次调用则直接从注册表中检查，并且返回该符号实例； 全局注册和使用普通方式定义的符号实例不等 let a = Symbol.for(&#39;hello&#39;); let b = Symbol.for(&#39;hello&#39;); let c= Symbol(&#39;hello&#39;); a === b // true a === c // false 传给Symbol.for()函数的任何值都会被转换为字符串 let empty = Symbol.for(); empty // Symbol(undefined); 可以使用 Symbol.keyFor()来查询全局注册表，这个方法接受符号，返回该全局符号对应的字符串键（如果没有则返回undefined, 如果传入的不是符号则会报错 let s = Symbol.for(&#39;foo&#39;); console.log(Symbol.keyFor(s)); // foo let a = Symbol(&#39;bar&#39;); console.log(Symbol.keyFor(a)); // undefined 3. 使用符号作为属性凡是可以使用字符串或数值作属性的地方都可以使用符号，包扩了Object.defineProperty() / Object.defineProperties()定义属性 let s1 = Symbol(&#39;hello&#39;), s2 = Symbol(&#39;world&#39;), s3 = Symbol(&#39;beauty&#39;); let o = { [s1]: &#39;1212&#39; }; console.log(o); // {Symbol(hello): 1212} Object.defineProperties(o, { [s2]: &#39;ssss&#39;, [s3]: &#39;2121&#39; }) Object.getOwnPropertyNames()返回对象实例的常规属性数组 Object.getOwnPropertySymbols()返回对象实例的符号属性数组 Object.getOwnPropertyDescriptors()返回同时包含常规和符号属性描述符的对象 Reflect.ownKeys()会返回两种类型的键 4.常用的内置符号ES6引入了一些常用的内置符号，用于暴露语言内部的行为，开发者可以直接访问，重写或者模拟这些行为 改变原生行为。比如for-of循环会在相关对象上使用Symbol.iterator属性，那么就可以通过在自定义的对象上面重新定义这个[Symbol.iterator]从而改变for-of遍历对象时候的行为 1） Symbol.asyncIterator （异步迭代器符号）(ES2018)这个符号作为一个属性，标识一个方法，该方法返回对象默认的AsyncIterator，由for-await-of语句使用，也就是异步迭代API函数 class Foo{ async *[Symbol.asyncIterator](){} } let f = new Foo(); console.log(f[Symbol.asyncIterator()]); // AsyncGenerator(&lt;suspended&gt;) 由此符号函数生成的对象应该显式通过next()方法陆续返回Promise实例，也可以隐式通过异步生成器函数返回 class Emitter { constructor(max){ this.max = max; this.index = 0; } async *[Symbol.asyncIterator](){ while(this.index&lt; this.max){ yield new Promise((resolve)=&gt;resolve (this.index++)); } } } async function count(number){ let emitter = new Emitter(number); for await(const x of emitter){ console.log(x) } } count(5); // 0 // 1 // 2 // 3 // 4 // 2) Symbol.hasInstance标识一个方法，决定一个构造器对象是否认可一个对象式它的实例。由instanceof 操作符使用 function Foo(){} let f = new Foo(); console.log(f instanceof Foo); // true console.log(Foo[Symbol.hasInstance](f)) // true; class FlaseInstance(){ static [Symbol.hasInstance](){ return false } } let a = new FalseInstance(); console.log(a intanceof FalseInstance) //false 3) Symbol.isConcatSpreadable标识一个布尔值，如果是true以为着对象改用Array.prototype.concat()打平其数组元素。 ES6中的Array.prototype.concat()方法会根据接收到的对象类型选择如何将一个类数组对象拼接成数组实例。 如值为false，则会导致整个对象被追加到数组末尾，其他不是类数组对象的对象在true情况下会被忽略 let init = [&#39;foo&#39;]; let arr = [&#39;bar&#39;]; console.log(arr[Symbol.isConcatSpreadable]) // undefined console.log(init,concat(arr)) // [&#39;foo&#39;, &#39;bar&#39;] arr[Symbol.isConcatSpreadable] = false; console.log(init.concat(arr)) // [&#39;foo&#39;, Array(1)]; let likeObj = { length:1, 0: &#39;bar&#39;}; console.log(likeObj[Symbol.isConcatSpreadable]); //undefined console.log(init.cancat(likeObj)) // [&#39;foo&#39;, {...}]; likeObj[Symbol.isConcatSpreadable] = true; console.log(init.concat(likeObj)) // [&#39;foo&#39;, &#39;bar&#39;] 4) Symbol.iterator标识一个方法，返回对象默认迭代器，由for-of语句使用 这与上面的Symbol.asyncIterator相类似 class Bar { constructor(max){ this.max = max; this.index = 0; } *[Symbol.iterator](){ while(this.index &lt; this.max){ yield this.index++; } } } function count(){ let bar = new Bar(5); for(const x of bar){ console.log(x) } } // 0 // 1 // 2 // 3 // 4 5) Symbol.match标识一个正则表达式的方法，该方法用正则表达式去匹配字符串； 由String.prototype.match()方法使用，使用以Symbol.match为键的函数来对这个正则表达式求值。正则表达式的原型上默认有这个函数的定义 console.log(RegExp.prototype[Symbol.match]); // f [Symbol.match]() { [native code] } console.log(&#39;foobar&#39;.match(/bar/)); // [&quot;bar&quot;, index: 3, input: &quot;foobar&quot;, groups: undefined] 给这个方法传入非正则的表达式值会导致该值呗转换为RegExp对象，如果想要改变这行为，允许方法直接使用参数，则重新定义Symbol.match class FooMatcher { static [Symbol.match](target){ return target.includes(&#39;foo&#39;) } } console.log(&#39;foobar&#39;.match(FooMacther)) // true; class StringMatcher{ constructor(str){ this.str = str; } [Symbol.match](target){ return target.includes(this.str); } } console.log(&#39;foobar&#39;.match(new StringMacther(&#39;foo&#39;))) // true 6) Symbol.replace标识一个正则表达式的方法，替换一个字符串中匹配的子串； 由String.prototype.replace()方法会使用以Symbol.replace为键的函数来对正则表达式求值, 和上面的match一样，为了阻止默认的非正则表达式值被强行转换为RegExp对象，可以覆盖默认行为 class FooReplacer { static [Symbol.replace](target, replacememt) { return target,split(&#39;foo&#39;).join(replacement); } } console.log(&#39;barfoobaz&#39;.replace(FooReplacer, &#39;quz&#39;)); // barquxbaz class StringReplacer { constructor(str){ this.str = str; } [Symbol.replace](target, replacement){ return target.split(this.str).join(replacement); } } console.log(&#39;barfoobaz&#39;.replace(new StringReplacer(&#39;foo&#39;), &#39;quz&#39;)); // barfoobaz 7）Symbol.search标识一个正则的方法，返回字符串中匹配正则表达式的索以。 由String.prototype.search()方法使用。String.prototype.search()方法会使用以Symbol.search为键的函数来对正则表达式进行求值, 同样和上述两个方法一样，为了阻止默认的行为，可以覆盖 console.log(&#39;foobar&#39;.search(/bar/)); //3 class StringSearcher { constructor(str){ this.str = str; } [Symbol.search](target){ return target.indexOf(this.str); } } console.log(&#39;foobar&#39;.search(new StringSeacher(&#39;foo&#39;))); // 0 8) Symbol.species标识一个属性。表示一个函数值，该函数作为创建派生对象的构造函数。 用Symbol.specied定义静态的获取器（getter）方法，可覆盖 class Bar extends Array {} class Baz extends Array { static get [Symbol.species](){ return Array; } } let bar = new Bar(); console.log(bar instanceof Array) // true; console.log(bar instanceof Bar) // true; let baz = new Baz() console.log(baz instanceof Array) // true console.log(baz instanceof Baz) // true baz = baz.concat(&#39;baz&#39;); console.log(baz instanceof Array) // true console.log(baz instanceof Baz) // false 9) Symbol.toPrimitive标识一个属性标识一个方法，该方法将对象转换为相应的原始值。有ToPrimitive抽象操作使用 很多内置操作都会尝试强制将对象转换为原始的值，包括字符串数值和未指定的原始类型。对于一个自定义对象实例，通过这个实例的Symbol.toPrimitive属性覆盖默认行为 class Foo{} let foo = new Foo(); console.log(3 + foo); // 3[object Object] console.log(3 - foo); // NaN console.log(String(foo)); // [object Object] class Baz{ constructor(){ this[Symbol.toPrimitive] = function(hint){ switch(hint){ case &#39;number&#39;: return 3; case &#39;string&#39;: return &#39;string bar&#39;; case &#39;default&#39;: default: return &#39;default bar&#39;; } } } } let bar = new Bar(); console.log(3 + bar) // 3default bar console.log(3 - bar) // 0 console.log(String(3)) // string bar 10）Symbol.toStringTag标识一个属性表示一个字符串，该字符串用再创建对象的默认字符串描述。由内置方法Object.prototype.toString()使用 通过toString()方法获取对象标识时候，会自动检索由Symbol.toStringTag指定的实例表示符号，默认为”Object”。 内置类型以及指定了这个值，自定义类实力还是需要明确定义的 let s = new Set(); console.log(s) // Set(0){} console.log(s.toString()); // [object Set]; console.log(s[Symbol.toStringTag]); // Set class Baz{ constructor(){ this[Symbol.toStringTag] = &quot;Bar&quot;; } } let baz = new Baz(); // Baz {} console.log(baz.toString()) // [object Baz] console.log(baz[Symbol.toStringTag]) // Baz","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"typeOf","slug":"typeOf","permalink":"https://github.com/NollieLeo/tags/typeOf/"}]},{"title":"var, let, const声明变量","date":"2021-03-14T07:39:55.000Z","path":"2021/03/14/var-let-const声明变量/","text":"ECMAscript中变量是松散类型的，意思就是可以用于保存任何类型的数据 有3个关键字可以声明变量 var, const, let var 在所有版本ECMAscript中都能用，let const只能在ES6中使用 var 关键字var a = 11212 1. var 声明作用域使用var操作符号定义的变量会成为包含它的函数的局部变量，会被拿到函数或全局作用域得顶部 function hello(){ var a = &#39;hi&#39;; // 局部变量 } hello(); console.log(a); // 出错 这里声明了a变量，函数使用完退出之后就销毁了这个a变量 但是有一种情况，直接在函数中声明全局变量 function hello(){ a=&#39;hi&#39;; } hello(); console.log(a); // hi 调用hello()函数之后全局注入了一个a的变量，这个变量 虽然可以通过省略var操作符定义全局变量，但是不推荐。局部作用域中定义全局变量很难维护。 2. var声明提式（变量提升hoist）如下 function foo(){ console.log(a); var a = &#39;1212&#39;; } foo(); // undifined a变量在定义之前就已经被访问，但是关键字会自动提升到函数作用域的顶部 等价于 function foo(){ var a; console.log(a); a = &#39;1212&#39;; } foo(); 3. 全局变量声明在全局中使用var来声明变量，这个变量会成为window对象的属性 var name = &#39;weng&#39;; console.log(window.name) // weng let声明1. let的块作用域 let和var的作用差不多，但是有很大区别。最明显的是Let声明的范围是块作用域， 而var声明的范围是函数作用域 var if(true){ var name = &#39;a&#39;; console.log(name); // a } console.log(name); // a let if(true){ let name = &#39;a&#39;; console.log(name); // a } console.log(name); // ReferenceError:name 没有定义 这里用let声明的变量之所以不能在if块外部被引用，是因为它的作用域仅限于该块的内部 块作用域是函数作用域的子集， 函数作用域 &gt; 块作用域 因此适用于var的作用域也适用于let作用域 当然let也不允许同一个块作用域中出现冗余的声明，这样会报错 var name; var name; let age; let age; // SntaxError;标识符age已经声明过了 js引擎会记录用于变量声明的标识符以及其所在的块作用域，嵌套使用相同的标识符不会报错，因为在同一块中没有重复声明 let age =30; console.log(age); function hello(){ let age = 20; console.log(age); // 20 } 2. 暂时性死区（let不存在变量提升）let 与var的另外一个重要区别就是let声明的变量不会在所对应的块作用域中被提升 console.log(name); // ReferenceError; age未被定义 let age = 2; let和var同理，在访问name变量的时候js会去找块后面的let声明，只是var声明的变量可以提前访问，let不能够提前访问； 在let声明之前执行瞬间被称作“暂时性死区” 3.全局变量声明let age = 26; console.log(window.age) // undifined let全局声明的变量并不会成为window对象的属性这点与var有区别 不过let声明在全局作用域中发生，相对应的变量会在页面的声明周期中续存 4.for循环中的let声明在let出现之前，for循环体定义的迭代变量会渗透到循环体的外部 for(var i =0;i&lt;9;i++){ // .... } console.log(i); // 9 在使用let之后这个问题就消失了； for(let i = 0;i&lt;9;i++){ // .... } console.log(i); // ReferenceError;i 没有定义 在使用var的时候，最常见的问题就是对迭代变量的奇特声明和修改 for(var i = 0;i&lt;5;i++){ setTimeout(()=&gt;console.log(i),0); } // 你以为的输出0，1，2，3，4，5 //实际 5，5，5，5，5 之所以这样是因为在退出循环的时候，迭代变量保存的是导致循环退出的值：5. 之后执行异步逻辑的时候，所有的i都是同一个变量，因此都是同一个最终值 而使用ley声明迭代变量的时候，js引擎会在后台为每个迭代循环声明一个新的迭代变量，也就是每个内部的异步函数引用的都是不同的变量实例，所以console.log()输出的是我们期望的值 const声明 const和let相同，唯一区别就是它声明的变量时必须初始话一个值，并且后续尝试修改声明的变量会导致报错 *注意 const声明得限制只适用于它指向的变量的引用，换句话说，如果const变量的引用指向一个对象，那么修改这个对象内部的属性，并不违反const的限制 一般const用在for..of for.. in 语句中","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"变量","slug":"变量","permalink":"https://github.com/NollieLeo/tags/%E5%8F%98%E9%87%8F/"}]},{"title":"fr单位配合grid布局","date":"2021-03-12T03:09:25.000Z","path":"2021/03/12/fr单位配合grid布局/","text":"在网格布局中的运用 网格布局支持弹性尺寸（flex-size），这是一个很好的自适应布局技术。fr是一个相对尺寸单位，表示剩余空间做等分，此项分配到的百分比(如果只有一个项使用此单位，那就占剩余空间的100%，所以多个项联合使用更有意义) 弹性尺寸使用fr尺寸单位，其来自 “fraction” 或 “fractional unit” 单词的前两个字母，表示整体空间的一部分。 结合grid布局可以实现等分行列的烦恼 示例 1.png 代码如下 &lt;style&gt; .grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px 20px; width: 500px; padding: 10px; background: bisque; } .grid-item { background-color: aquamarine; } &lt;/style&gt; &lt;div class=&quot;grid&quot;&gt; &lt;div class=&quot;grid-item&quot;&gt; &lt;p&gt;12121&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;grid-item&quot;&gt; &lt;p&gt;12121&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;grid-item&quot;&gt; &lt;p&gt;12121&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 坑如果内部的元素内容很多就会容易造成不等分的情况 如图 image-20210312113529373 解决方案 grid-template-columns: repeat(3, minmax(10px,1fr)); 给了10px的最小宽度值。解决了最小宽度不确定导致的溢出问题、同时10px最小宽度比起0px避免了元素直接消失，当问题出现时可减小调试成本。","tags":[{"name":"css","slug":"css","permalink":"https://github.com/NollieLeo/tags/css/"},{"name":"grid布局","slug":"grid布局","permalink":"https://github.com/NollieLeo/tags/grid%E5%B8%83%E5%B1%80/"}]},{"title":"箭头函数理解","date":"2021-03-08T02:19:44.000Z","path":"2021/03/08/箭头函数理解/","text":"箭头函数es6语法 // ES6语法 const fn = v =&gt; v; 一. 特点1. 语法简介箭头函数省去了function关键字，用=&gt;代替function，圆括号代表参数部分，当只有一个参数时，圆括号可省略，当只有一行返回语句时，return和花括号{}都可以省略。 // 求两数之和 const fn = (a, b) =&gt; {return a + b;}; // 等价于 const fn = (a, b) =&gt; a + b; // 求一个数组各项之和 const sum = [1, 2, 3, 4, 5].reduce((x, y) =&gt; x + y, 0); // 15 // 将数组中的元素按从小到大顺序排序 const array = [2, 4, 1, 5, 9, 7].sort((x, y) =&gt; x - y); // [1, 2, 4, 5, 7, 9] // 过滤数组中为偶数的数字 const array = [0, 1, 2, 3, 4, 5, 6].filter(x =&gt; x % 2 === 0); // [0, 2, 4, 6] 2. 不绑定this 箭头函数体内的this永远指向的是定义时所在的对象，而不是调用时所在的对象。 function Fn() { this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =&gt; this.s1++, 1000); // 普通函数 setInterval(function() { this.s2++; }, 1000); } var fn = new Fn(); setTimeout(() =&gt; console.log(&#39;s1= &#39;, fn.s1), 3100); // 3.1秒后输出s1= 3 setTimeout(() =&gt; console.log(&#39;s2= &#39;, fn.s2), 3100); // 3.1秒后输出s2= 0 上面代码中，Fn函数内部设置了两个定时器，分别使用了箭头函数和普通函数。 箭头函数中的this指向定义时所在的作用域（即Fn函数），this.s1++是处在箭头函数中，这里的this就是fn，所以fn.s1的值为3。 而普通函数中的this指向运行时所在的作用域（即全局对象window），this.s2++实际等于window.s2++，fn.s2一次都没有更新，因而得到的是0。 所以，从严格意义上讲，箭头函数中不会创建自己的this，而是会从自己作用域链的上一层继承。 const Person = { name: &#39;Kimmy&#39;, age: 20, doSomething: function() { setTimeout(() =&gt; console.log(`name: ${this.name}, age: ${this.age}`), 1000); } }; Person.doSomething(); // name: Kimmy, age: 20 const Person2 = { name: &#39;Kimmy&#39;, age: 20, doSomething: () =&gt; { setTimeout(() =&gt; console.log(`name: ${this.name}, age: ${this.age}`), 1000); } }; Person2.doSomething(); // name: , age: undefined 上面两段代码的唯一区别在于doSomething()函数的写法，Person中使用了普通函数定义，Person2中使用了箭头函数定义。 在第一段代码中，Person.doSomeThing()中的this指向函数的调用体，即Person本身，在调用setTimeout()函数时，由于其函数体部分是通过箭头函数定义的，内部的this会继承父作用域的this（即Person），从而输出name: Kimmy, age: 20。 在第二段代码中，Person2.doSomething()中的this指向外层作用域，而Person2的父作用域是全局作用域window，在调用setTimeout()函数时，由于其函数体部分是通过箭头函数定义的，内部的this会继承doSomething()函数所在的作用域this（即window），而window上name属性是&#39;&#39;，age属性不存在，所以Person2.doSomething()输出name: , age: undefined。 综上所述，箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正因为它没有this，所以也就不能用作构造函数。 3. 不支持 call()、 apply()、bind() 函数的特性通过调用 call() 、apply()、bind() 函数可以改变一个函数的执行主体，即改变被调用函数中 this 的指向 但箭头函数中不支持 call() 、apply()、bind()等，因为箭头函数中没有自己的 this ，而是继承父作用域中的 this。 function fn() { return () =&gt; { console.log(`id= ${this.id}`); } } let f = fn.call({id: 1}); // id= 1 let f2 = f.call({id: 2})()(); // id = 1 let f3 = f().call({id: 3})(); // id= 1 let f4 = f()().call({id: 4}); // id= 1 上面代码中只有一个this，即函数fn的this，所以f2、f3、f4都输出同样的结果。因为内层函数时箭头函数，没有自己的this，它们的this都是最外层fn函数是this。 4. 不绑定 arguments 在普通函数function中，我们可以通过arguments对象来获取到实际传入的参数值，但在箭头函数中是不存在的。 const fn = () =&gt; { console.log(arguments); } fn(1, 2); // Uncaught ReferenceError: arguments is not defined function fn() { setTimeout(() =&gt; { console.log(arguments); }, 0); } fn(1, 2); // [1, 2] 5.支持嵌套const pipeline = (...funcs) =&gt; val =&gt; funcs.reduce((a, b =&gt; b(a)), val); const plus1 = a =&gt; a + 1; const mult2 = a =&gt; a * 2; const addThenMult = pipeline(plus1, mult2); addThenMult(5); // 12 二.箭头函数不适用场景（1）定义对象的方法且该方法内部包括thisconst Person = { name: &#39;Kimmy&#39;, age: 20, doSomething: () =&gt; { this.age++; } }; Person.doSomething()方法是一个箭头函数，调用Person.doSomething()时，如果是普通函数，该方法内部的this指向Person，如果写成上面那样的箭头函数，使得this指向全局对象。 （2）不能作为构造函数，不能使用 new 操作符构造函数时通过new操作符生成对象实例的，生成实例的过程也是通过构造函数给实例绑定this的过程，而箭头函数没有自己的this，因此不能使用箭头函数作为构造函数，也不能通过new操作符来调用箭头函数。 // 普通函数 function Person(name) { this.name = name; } let p = new Person(&#39;Kimmy&#39;); // 正常 // 箭头函数 let Person = (name) =&gt; { this.name = name; } let p = new Person(&#39;Kimmy&#39;); // Uncaught TypeError: Person is not a constructor （3）没有 prototype 属性let a = () =&gt; 1; function b() { return 2; } a.prototype // undefined b.prototype // {constructor: ƒ} （4）不适合将原型函数定义成箭头函数在给构造函数添加原型函数时，如果使用箭头函数，其中的this会指向全局作用域window，而并不会指向构造函数，因此并不会访问到构造函数本身，也就无法访问到实例属性，这就失去了作为原型函数的意义。","tags":[{"name":"es6","slug":"es6","permalink":"https://github.com/NollieLeo/tags/es6/"},{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"}]},{"title":"工作中常用的Git命令","date":"2021-03-04T07:37:00.000Z","path":"2021/03/04/工作中常用的Git命令/","text":"常用的基本操作git init这个git init不用多说，大家都知道这个命令是初始化当前目录变成可以使用git管理的仓库，并且是空的。 git init git clone 远程地址[url]通过git clone命令从远程地址下载出来，这个也不用过多描述。 git clone git statusgit status查看本次本地有多少个文件发生变更。可以看到index.cssd和index.html发生变更 git status git loggit log查看当前提交的日志。 git log git diffgit diff是查看当前改动的文件具体代码内容比对。 git diff git checkout .git checkout .就是所有有改动的全部恢复到原来的样子, 当然也可以恢复指定的如：git checkout index.css只恢复这个文件当前的修改。 git checkout git add .git add .是将修改的内容新增到暂存区，也可以提交指定的的文件。 git add git commit -m “你的要提交的注释”git commit -m这里的内容从暂存区写入到对象库中, 注意注释必须写。 git commit git tag查看当前tag标签 git tag tagName(你的tag名称)新建一个Tag标签 git tag -a tagName -m “tag备注”新建一个tag标签带有备注信息 git show tagName(你的tag标签名)查看当前tag备注信息 git show tag git push origin tagName(你的tag名称)git push origin v1.0推送到远程 git push origin branch(你的分支)git push origin branch推送到远程仓库。 git push origin branch git pull origin branch(你的分支)git pull origin branch从远程拉取到本地。 git pull origin branch git checkout branch(你的分支)git checkout branch切换到别的分支上。 git checkout branch git checkout -b branch(你的分支)git checkout -b branch(分支名称)新建一个分支并切换到该分支上。 git checkout -b git branch -vgit branch -v查看当前的分支并且后面带有最后一次提交的信息 git branch -v git branch -agit branch -a查看当前所有的分支包括远程分支 git branch -a git branch branch(你的分支)git branch barnch(你的分支名称)新建一个本地分支。 git branch git branch -D name(分支名)git branch -D name(分支名) 删除本地分支，但是不能在当前的分支上删除当前分支，必须切换到别的分支上，删除其它分支。 img git remote -vgit remote -v查看源地址 git remote -v git remove remote name(源地址名字)git remove remote name删除源地址。 git remove remote name git remote add name(源地址名字) 远程地址[url]git remote add name url添加一个源地址为要提交仓库的地址。 git remote add name git fetch origin name(远程分支名称)git fetch origin name如果我们本地没有该分支，远程有该分支，我们先拉下来远程分支，并且新建本地分支和远程分支关联上就可以了。 git fetch git merge name(要合并的分支名称)git merge name(要合并的分支名称)将要合并的分支合并到其它分支上。将test分支上的代码合并到develop上。 git merge 特殊问题场景怎么解决只想把一个提交合并到其它分支上比如一个场景develop分支上有一些特殊的代码，所以不能把这个分支上的代码合并到test分支上，我们只想合并当前修改的代码，该怎么办呢git cherry-pick就是用来解决这问题的，来看下面例子。 git cherry-pick 上面example中，git cherry-pick后面跟着一个id这个id就是别的分支提交记录的id，查看这个id的话上面说过了使用git log查看日志。我这个案例代码是没有发生冲突情况的，那么有的小伙伴发生冲突的话，先解决冲突然后git add .在git cherry-pick --continue这个参数是继续执行当前的git cherry-pick过程。下面来查看几个参数 --continue 用户解决代码冲突后，第一步将修改的文件重新加入暂存区（git add .），第二步使用下面的命令，让 Cherry pick 过程继续执行。 --abort 发生代码冲突后，放弃合并，回到操作前的样子. --quit 发生代码冲突后，退出 Cherry pick，但是不回到操作前的样子 如果commit时注释写错了怎么办？git commit --amend -m &quot;重新提交注释&quot;{% image 24.image 'git commit --amend' '' %} 远程强制覆盖到本地$ git fetch --all(下载远程库的所有内容) $ git reset --hard origin/master(远程的分支名称) $ git pull 复制代码commit提交完怎么撤回git reset HEAD~1撤回刚才的注释，如果提交了2次commit那么就撤回2次git reset HEAD~2。 git reset HEAD~1 Git开发错分支了没提交代码时 git add . git stash (把暂存区的代码放入到git暂存栈) git checkout name(切换到正确的分支) git stash pop(把git暂存栈的代码放出来) 复制代码提交代码后 git reset HEAD~1 （最近一次提交放回暂存区, 并取消此次提交） git stash (暂存区的代码放入到git暂存栈) git checkout (应该提交代码的分支) git stash pop (把git暂存栈的代码放出来) git checkout (切换到刚才提交错的分支上) git push origin 错误的分支 -f (把文件回退掉)","tags":[{"name":"git","slug":"git","permalink":"https://github.com/NollieLeo/tags/git/"}]},{"title":"读深入浅出webpack做的笔记","date":"2021-02-21T08:06:59.000Z","path":"2021/02/21/读深入浅出webpack做的笔记/","text":"第一章1.2 常见构建工具对比","tags":[{"name":"书籍","slug":"书籍","permalink":"https://github.com/NollieLeo/tags/%E4%B9%A6%E7%B1%8D/"}]},{"title":"处理文件流","date":"2021-02-05T01:41:32.000Z","path":"2021/02/05/处理文件流/","text":"如果在项目中第一次遇到下载、导出文件的时候，我们都会直接去请求API，期望会下载一个文件到本地，然后我们可以打开它。但是看到的结果却出乎意料。 并没有出现期望的情形，而是返回了一堆“乱码”。 AJAX无法下载文件的原因下载其实是浏览器的内置事件，浏览器的 GET请求（frame、a）、 POST请求（form）具有如下特点： response会交由浏览器处理 response内容可以为二进制文件、字符串等 但是AJAX请求不一样： response会交由 Javascript 处理 response内容只能接收字符串才能继续处理 因此，AJAX本身无法触发浏览器的下载功能。 Axios如何实现下载 发送请求 获得response 通过response判断返回是否为流文件 如果是文件则在页面中插入frame/a标签 利用frame/a标签实现浏览器的get下载 首先封装一个download方法，用于发送请求 // request.js import Axios form &#39;axios&#39;; /* * @params {string} url 请求地址 * @params {object} resOpts 请求配置参数 */ const download = (url, resOpts = {}) =&gt; { const { type = &#39;get&#39;, data = &#39;&#39; } = resOpts const queryArgs = { url, method: type, data, headers: { Accept: &#39;application/json&#39;, &#39;Content-Type&#39;: &#39;application/json; charset=utf-8&#39;, withCredentials: true, }, } // tips: 这里直接返回的是response整体! return Axios.request(queryArgs).catch(err =&gt; console.log(err)) } ... 拿到response之后我们需要将流文件通过浏览器下载 // utils.js export function convertRes2Blob(response) { // 提取文件名 const fileName = response.headers[&#39;content-disposition&#39;].match( /filename=(.*)/ )[1] // 将二进制流转为blob const blob = new Blob([response.data], { type: &#39;application/octet-stream&#39; }) if (typeof window.navigator.msSaveBlob !== &#39;undefined&#39;) { // 兼容IE，window.navigator.msSaveBlob：以本地方式保存文件 window.navigator.msSaveBlob(blob, decodeURI(filename)) } else { // 创建新的URL并指向File对象或者Blob对象的地址 const blobURL = window.URL.createObjectURL(blob) // 创建a标签，用于跳转至下载链接 const tempLink = document.createElement(&#39;a&#39;) tempLink.style.display = &#39;none&#39; tempLink.href = blobURL tempLink.setAttribute(&#39;download&#39;, decodeURI(filename)) // 兼容：某些浏览器不支持HTML5的download属性 if (typeof tempLink.download === &#39;undefined&#39;) { tempLink.setAttribute(&#39;target&#39;, &#39;_blank&#39;) } // 挂载a标签 document.body.appendChild(tempLink) tempLink.click() document.body.removeChild(tempLink) // 释放blob URL地址 window.URL.revokeObjectURL(blobURL) } } 缺点 download请求方法与convertRes2Blob处理文件下载的方法，需要分开调用 download使用独立的实例，不能公用一个axios，基础配置需要单独维护","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"blob","slug":"blob","permalink":"https://github.com/NollieLeo/tags/blob/"}]},{"title":"正在读的书籍","date":"2021-01-19T02:21:41.000Z","path":"2021/01/19/正在读的书籍/","text":"《深入浅出webpack》：https://webpack.wuhaolin.cn/%E5%89%8D%E8%A8%80.html","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"webpack","slug":"webpack","permalink":"https://github.com/NollieLeo/tags/webpack/"}]},{"title":"requestAnimationFrame和一般计时器处理动画区别","date":"2020-12-28T01:39:12.000Z","path":"2020/12/28/requestAnimationFrame和一般计时器处理动画区别/","text":"在Web应用中，实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout来实现，css3 可以使用 transition和 animation来实现，html5 中的 canvas 也可以实现。除此之外，html5 还提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是请求动画帧。 编写动画循环的关键是要知道延迟时间多长合适。一方面，循环间隔必须足够短，这样才能让不同的动画效果显得平滑流畅；另一方面，循环间隔还要足够长，这样才能确保浏览器有能力渲染产生的变化。 大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次。大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔是1000ms/60，约等于16.6ms。 而setTimeout和setInterval的问题是，它们都不精确。它们的内在运行机制决定了时间间隔参数实际上只是指定了把动画代码添加到浏览器UI线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行。 requestAnimationFrame采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果 相关概念1. 页面激活（可见） 当页面被最小化或者被切换成后台标签页时，页面为不可见，浏览器会触发一个 visibilitychange事件,并设置document.hidden属性为true；切换到显示状态时，页面为可见，也同样触发一个 visibilitychange事件，设置document.hidden属性为false。 2. 动画帧请求回调函数列表 每个Document都有一个动画帧请求回调函数列表，该列表可以看成是由``元组组成的集合。其中handlerId是一个整数，唯一地标识了元组在列表中的位置；callback是回调函数。 3. 屏幕刷新频率 即图像在屏幕上更新的速度，也即屏幕上的图像每秒钟出现的次数，它的单位是赫兹(Hz)。 对于一般笔记本电脑，这个频率大概是60Hz， 这个值的设定受屏幕分辨率、屏幕尺寸和显卡的影响。 4. 动画原理根据上面的原理我们知道，你眼前所看到图像正在以每秒60次的频率刷新，由于刷新频率很高，因此你感觉不到它在刷新。而动画本质就是要让人眼看到图像被刷新而引起变化的视觉效果，这个变化要以连贯的、平滑的方式进行过渡。 那怎么样才能做到这种效果呢？ 刷新频率为60Hz的屏幕每16.7ms刷新一次，我们在屏幕每次刷新前，将图像的位置向左移动一个像素，即1px。这样一来，屏幕每次刷出来的图像位置都比前一个要差1px，因此你会看到图像在移动；由于我们人眼的视觉停留效应，当前位置的图像停留在大脑的印象还没消失，紧接着图像又被移到了下一个位置，因此你才会看到图像在流畅的移动，这就是视觉效果上形成的动画。 特点requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率 在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量 requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销 用法异步，传入的函数在重绘之前调用。 requestAnimationFrame的用法与setTimeout很相似，只是不需要设置时间间隔而已。 1. 写法：handlerId = requestAnimationFrame(callback)(1) 传入一个callback函数，即动画函数; (2) 返回值handlerId为浏览器定义的、大于0的整数，唯一标识了该回调函数在列表中位置。 2. 浏览器执行过程:(1) 首先要判断document.hidden属性是否为true,即页面处于可见状态下才会执行； (2) 浏览器清空上一轮的动画函数； (3) 这个方法返回的handlerId 值会和动画函数callback，以`` 进入到动画帧请求回调函数列； (4) 浏览器会遍历动画帧请求回调函数列表，根据handlerId 的值大小，依次去执行相应的动画函数。 3. 取消动画函数的方法：cancelAnimationFrame(handlerId) setTimeout和requestAnimationFrame区别1. setTimeout 理解了上面的概念以后，我们不难发现，setTimeout其实就是通过设置一个间隔时间来不断的改变图像的位置，从而达到动画效果的。但利用seTimeout实现的动画在某些低端机上会出现卡顿、抖动的现象。 这种现象的产生有两个原因： setTimeout的执行时间并不是确定的。在Javascript中， setTimeout任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，因此 setTimeout 的实际执行时间一般要比其设定的时间晚一些。 刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷新频率可能会不同，而 setTimeout只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。 以上两种情况都会导致setTimeout的执行步调和屏幕的刷新步调不一致，从而引起丢帧现象。 那为什么步调不一致就会引起丢帧呢？ 首先要明白，setTimeout的执行只是在内存中对图像属性进行改变，这个变化必须要等到屏幕下次刷新时才会被更新到屏幕上。如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的图像。假设屏幕每隔16.7ms刷新一次，而setTimeout每隔10ms设置图像向左移动1px， 就会出现如下绘制过程： 第0ms: 屏幕未刷新，等待中，setTimeout也未执行，等待中； 第10ms: 屏幕未刷新，等待中，setTimeout开始执行并设置图像属性left=1px； 第16.7ms: 屏幕开始刷新，屏幕上的图像向左移动了1px， setTimeout未执行，继续等待中； 第20ms: 屏幕未刷新，等待中，setTimeout开始执行并设置left=2px; 第30ms: 屏幕未刷新，等待中，setTimeout开始执行并设置left=3px; 第33.4ms: 屏幕开始刷新，屏幕上的图像向左移动了3px， setTimeout未执行，继续等待中； … 从上面的绘制过程中可以看出，屏幕没有更新left=2px的那一帧画面，图像直接从1px的位置跳到了3px的的位置，这就是丢帧现象，这种现象就会引起动画卡顿。 2. requestAnimationFrame与setTimeout相比，requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。具体一点讲，如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，换句话说就是，requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。 这个API的调用很简单，如下所示： var progress = 0; //回调函数 function render() { progress += 1; //修改图像的位置 if (progress &lt; 100) { //在动画没有结束前，递归渲染 window.requestAnimationFrame(render); } } //第一帧渲染 window.requestAnimationFrame(render);复制代码 除此之外，requestAnimationFrame还有以下两个优势： CPU节能：使用setTimeout实现的动画，当页面被隐藏或最小化时，setTimeout仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而requestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统步伐走的requestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。 函数节流：在高频率事件(resize,scroll等)中，为了防止在一个刷新间隔内发生多次函数执行，使用requestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。一个刷新间隔内函数执行多次时没有意义的，因为显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。","tags":[{"name":"计时器","slug":"计时器","permalink":"https://github.com/NollieLeo/tags/%E8%AE%A1%E6%97%B6%E5%99%A8/"},{"name":"requestAnimationFrame","slug":"requestAnimationFrame","permalink":"https://github.com/NollieLeo/tags/requestAnimationFrame/"}]},{"title":"时间分片","date":"2020-12-28T01:04:38.000Z","path":"2020/12/28/时间分片/","text":"海量数据优化-时间分片时间分片的概念，就是一次性渲染大量数据，初始化的时候会出现卡顿等现象。我们必须要明白的一个道理，js执行永远要比dom渲染快的多。 ，所以对于大量的数据，一次性渲染，容易造成卡顿，卡死的情况。我们先来看一下例子 ./Content.tsx import { Button } from &#39;choerodon-ui&#39;; import Icon from &#39;choerodon-ui/lib/icon/Icon&#39;; import { map } from &#39;lodash&#39;; import { observer } from &#39;mobx-react-lite&#39;; import React, { useEffect, useRef, useState } from &#39;react&#39;; import &#39;./index.less&#39;; import { useDemos } from &#39;./stores&#39;; const Demos = () =&gt; { const { mainStore, } = useDemos(); const { lists, setLists, } = mainStore; useEffect(() =&gt; { }, []); function add() { setLists(new Array(40000).fill(0)); } function reset() { setLists([]); } return ( &lt;div className=&quot;demos&quot;&gt; &lt;div&gt; &lt;Button funcType=&quot;raised&quot; type=&quot;primary&quot; onClick={add}&gt;add +&lt;/Button&gt; &lt;Button funcType=&quot;raised&quot; type=&quot;primary&quot; onClick={reset}&gt;reset&lt;/Button&gt; { map(lists, (item:number, i:number) =&gt; ( &lt;div className=&quot;demos-item&quot; key={i}&gt; {`item-${i}`} &lt;Icon type=&quot;close&quot; /&gt; &lt;/div&gt; )) } &lt;/div&gt; &lt;/div&gt; ); }; export default observer(Demos); ./stores/index.tsx /* eslint-disable max-len */ import React, { createContext, useCallback, useContext, useMemo, } from &#39;react&#39;; import { DataSet } from &#39;choerodon-ui/pro&#39;; import { injectIntl } from &#39;react-intl&#39;; import { inject } from &#39;mobx-react&#39;; import useStore from &#39;./useStore&#39;; interface ContextProps { } const Store = createContext({} as ContextProps); export function useDemos() { return useContext(Store); } export const StoreProvider = injectIntl(inject(&#39;AppState&#39;)((props: any) =&gt; { const { children, intl: { formatMessage }, AppState: { currentMenuType: { projectId } }, } = props; const mainStore = useStore(); const value = { ...props, formatMessage, projectId, mainStore, }; return ( &lt;Store.Provider value={value}&gt; {children} &lt;/Store.Provider&gt; ); })); ./stores/useStore.tsx import { useLocalStore } from &#39;mobx-react-lite&#39;; export default function useStore() { return useLocalStore(() =&gt; ({ lists: [], setLists(value:any) { this.lists = value; }, })); } export type StoreProps = ReturnType&lt;typeof useStore&gt;; ./index.tsx import React from &#39;react&#39;; import { StoreProvider } from &#39;./stores&#39;; import Content from &#39;./Content&#39;; const Index = (props: any) =&gt; ( &lt;StoreProvider {...props}&gt; &lt;Content /&gt; &lt;/StoreProvider&gt; ); export default Index; ./index.less .demos { &amp;-item { border: 1px solid #0fc2e2; background-color: #4adcf0; color: #fff; border-radius: 4px; height: 50px; width: 400px; text-align: center; font-size: 20px; line-height: 50px; &amp; + &amp; { margin-top: 10px; } } } 最主要的代码就是Content.tsx 演示如下 gif1 我们看到 40000 个 简单列表渲染了，将近5秒的时间。为了解决一次性加载大量数据的问题。我们引出了时间分片的概念，就是用setTimeout把任务分割，分成若干次来渲染。一共40000个数据，我们可以每次渲染100个， 分次400渲染。(这里用的是window.requestAnimationFrame()) import { Button } from &#39;choerodon-ui&#39;; import Icon from &#39;choerodon-ui/lib/icon/Icon&#39;; import { map } from &#39;lodash&#39;; import { observer } from &#39;mobx-react-lite&#39;; import React, { useEffect, useRef, useState } from &#39;react&#39;; import &#39;./index.less&#39;; import { useDemos } from &#39;./stores&#39;; const Demos = () =&gt; { const { mainStore, } = useDemos(); const { lists, setLists, } = mainStore; useEffect(() =&gt; { }, []); function handleSlice(list:number[], times:number) { if (times === 400) return; window.requestAnimationFrame(() =&gt; { const newLists = list.slice(times, (times + 1) * 10); setLists(lists.concat(newLists)); handleSlice(list, times + 1); }); } function add() { handleSlice(new Array(4000).fill(0), 0); } function reset() { setLists([]); } return ( &lt;div className=&quot;demos&quot;&gt; &lt;div&gt; &lt;Button funcType=&quot;raised&quot; type=&quot;primary&quot; onClick={add}&gt;add +&lt;/Button&gt; &lt;Button funcType=&quot;raised&quot; type=&quot;primary&quot; onClick={reset}&gt;reset&lt;/Button&gt; { map(lists, (item:number, i:number) =&gt; ( &lt;div className=&quot;demos-item&quot; key={i}&gt; {`item-${i}`} &lt;Icon type=&quot;close&quot; /&gt; &lt;/div&gt; )) } &lt;/div&gt; &lt;/div&gt; ); }; export default observer(Demos); 演示: gif2","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"多数据处理","slug":"多数据处理","permalink":"https://github.com/NollieLeo/tags/%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"}]},{"title":"前端生成pdf","date":"2020-12-26T07:52:39.000Z","path":"2020/12/26/前端生成pdf/","text":"项目上要求，能够根据页面上所展示的测试报告，生成一份pdf。 根据模板： image-20201226160741507 image-20201226160741507 最终生成的效果： image-20201226160741507 image-20201226160741507 原理：通过插件js-pdf以及一个html2canvas插件结合，首先通过 html2canvas 可以在浏览器端直接对整个或部分页面进行截屏。脚本通过读取DOM并将不同的样式应用到这些元素上，从而将当页面渲染成一个Canvas图片。 之后利用js-pdf插件添加图片，将生成的canvas图片插入pdf中。 保存导出pdf 1. 获取像素比/* 根据window.devicePixelRatio获取像素比 */ function DPR() { if (window.devicePixelRatio &amp;&amp; window.devicePixelRatio &gt; 1) { return window.devicePixelRatio; } return 1; } devicePixelRatio属性是干嘛的window的该属性能够获取到当前显示设备物理分辨率与css的像素分辨率之间的比率。简单说就是告诉浏览器应该使用多少个物理像素来会在单个css像素。 2. 绘制canvas首先要看绘制canvas需要的一些参数需要配置 html2canvas(element, options);返回一个promise element 页面上的dom元素（这里要注意一些css样式是不支持的） options配置详情看这里下面只是用到项目上需要的需求 1）获取element const pdfRef = React.useRef(); return ( &lt;div className={`${prefixCls}`} ref={pdfRef}&gt; ...... &lt;/div&gt; 2) 配置optionsconst getOpts = ()=&gt; { const target:any = pdfRef.current; const width = target.offsetWidth; // 获取dom 宽度 const height = target.offsetHeight; // 获取dom 高度 const scale = DPR(); const tempCanvas = document.createElement(&#39;canvas&#39;); tempCanvas.width = width * scale; // 定义canvas 宽度 * 缩放 tempCanvas.height = height * scale; // 定义canvas高度 *缩放 const opts = { useCORS: true, allowTaint: true, canvas: tempCanvas, // 现有的画布元素用作绘图的基础 scale, // 提升画面质量，但是会增加文件大小 scrollX: 0, scrollY: 0, }; return opts; } 关于在配置项中设置跨域 useCORS和allowTaint两种都可以设置跨域； 为什么要设置跨域：我们图片一般都是放到静态资源服务器上的，资源服务器地址一般和项目地址是不一样的；虽然图片可以在页面上显示，但是用canvas绘图时却绘制不出来； 3. 根据生成的canvas生成pdfhtml2canvas(target, opts).then(async (canvas) =&gt; { (....处理逻辑) }); 1）首先转换图片 HTMLCanvasElement.toDataURL() 方法返回一个包含图片展示的 data URI const contentWidth = canvas.width; const contentHeight = canvas.height; // 将canvas转为base64图片 const pageData = canvas.toDataURL(&#39;image/jpeg&#39;, 1); 2) 设置pdf的大小以及生成的图片大小因为pdf的像素单位是不一样的，所以需要进行转换; 已知 1pt/1px = 0.75, pt = (px/scale)*0.75 这里的scale就是上面的像素比 // 设置pdf的尺寸，pdf要使用pt单位 已知 1pt/1px = 0.75 pt = (px/scale)* 0.75 // 2为上面的scale 缩放了2倍 const pdfX = (contentWidth + 10) / scale * 0.75; const pdfY = (contentHeight) / scale * 0.75; // 500为底部留白 // 设置内容图片的尺寸，img是pt单位 const imgX = pdfX; const imgY = (contentHeight / scale * 0.75); // 内容图片这里不需要留白的距离 3）插入图片并生成pdfconst pdf = new JsPDF(&#39;&#39;, &#39;pt&#39;, [pdfX, pdfY]); // 第一个参数方向：默认&#39;&#39;时为纵向 // 将内容图片添加到pdf中，因为内容宽高和pdf宽高一样，就只需要一页，位置就是 0,0 await pdf.addImage(pageData, &#39;jpeg&#39;, 0, 0, imgX, imgY); pdf.save(`API测试报告（#${viewId}）.pdf`); 4. 出现的问题以及解决方法1）导出的pdf中图片横向位置被截断如图： image-20201226181331163 这是因为需要生成的dom的宽度大于其高度，生成图片插入pdf的时候由于pdf默认设置的是纵向排列，图片会被撑大以适应pdf的高度； 按照下方处理 // 初始化jspdf 第一个参数方向：默认&#39;&#39;时为纵向，第二个参数设置pdf内容图片使用的长度单位为pt，第三个参数为PDF的大小，单位是pt let direct; if (contentHeight &lt; contentWidth) { direct = &#39;l&#39;; } else { direct = &#39;p&#39;; } const pdf = new JsPDF(direct, &#39;pt&#39;, [pdfX, pdfY]); 当高度小于宽度的时候将pdf进行横纵向的调整，以适应插入图片的宽高","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"pdf","slug":"pdf","permalink":"https://github.com/NollieLeo/tags/pdf/"}]},{"title":"undefine和void()有什么区别？","date":"2020-12-25T07:23:53.000Z","path":"2020/12/25/undefine和void-有什么区别？/","text":"在 JavaScript 中，判断是否是 undefined，一般都这样写： function isUndefined(input) { return input === void 0; } 为什么要使用 void 0 呢？ void 是 JS 中的一个运算符，语法是： void expression 它返回 undefined 的原始值，同时语句中的 expression 会被运算，也即产生了副作用。可以这样理解：它运算了表达式，但是不返回值（或者说返回 undefined）。 所以，通常使用 void 0 来得到 undefined。 但是，为什么不直接使用 undefined 呢？ 要弄清楚这个问题，先看看 undefined 这个词在不同语境下的含义。 undefined 是术语（glossary）。被用于表示一个概念时，它是一个术语，这个术语表示这样一个概念：未定义的值（即 undefined）。在 JS 中，只声明而未被赋值的变量、函数里未传实参的形参，都对应此概念。 undefined 是类型（type）。为了在语言层面实现上述的 undefined 概念，JS 为这个概念提供了一种原始类型（primitive type），即 undefined 类型。 undefined 是值（value）。上述的 undefined 类型非常特殊，不像其他诸如 string、number 类型可以定义出无限多的不同变量，undefined 类型的值只可能有一个，可以称之为 undefined 原始值（primitive value）。这个值在 JS 中没有字面量，准确的说是 JS 没有为程序员提供一个表示 undefined 原始值的字面量（可能有人会说代码里 undefined 不就是字面量吗？请看下一条）。 undefined 是属性（undefined）。代码中出现的 undefined 是全局变量的属性，所以说 JS 代码里出现的 undefined 并不是字面量。可以这样理解：JS 一开始就在内部将 undefined 原始值赋给了 undefined 属性。 现在再来回答为什么需要使用 void 0 而不直接用 undefined。 先说为什么使用 void 0。因为 void 0 返回的值是 undefined 原始值，这与我们写代码的意图完全一致。 再说为什么不使用 undefined。 因为在两种情况下它有可能与我们的意图不一致。 第一种情况：既然 undefined 是一个属性，那它就有可能被重新赋值。但是这个担心是是多余的，因为从 ES5 开始 undefined 属性就是是一个只读属性了，不可能被重新赋值。可以通过实验验证，打开 node CLI： &gt; Object.getOwnPropertyDescriptor(global, &#39;undefined&#39;) { value: undefined, writable: false, enumerable: false, configurable: false } &gt; undefined = &#39;a string&#39; &#39;a string&#39; &gt; typeof undefined &#39;undefined&#39; 但是即便如此，为兼容性考虑还是要避免直接拿 undefined 来做比较。 第二种情况：局部变量。因为 undefined 在 JS 中并不是保留字，所以在局部作用域中完全可以定义一个变量名为 undefined 的局部变量。看如下代码： (function(){ let undefined = &#39;a string&#39;; console.log(undefined) })() 代码运行的结果是: a string 总结：使用 void 0 是有足够理由的。","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"}]},{"title":"react何时render呢？","date":"2020-12-24T01:50:41.000Z","path":"2020/12/24/react何时render呢？/","text":"对于如下Demo，点击Parent组件的div，触发更新，Son组件会打印child render!么？ function Son() { console.log(&#39;child render!&#39;); return &lt;div&gt;Son&lt;/div&gt;; } function Parent(props) { const [count, setCount] = React.useState(0); return ( &lt;div onClick={() =&gt; {setCount(count + 1)}}&gt; count:{count} {props.children} &lt;/div&gt; ); } function App() { return ( &lt;Parent&gt; &lt;Son/&gt; &lt;/Parent&gt; ); } const rootEl = document.querySelector(&quot;#root&quot;); ReactDOM.render(&lt;App/&gt;, rootEl); 不会 render需要满足的条件React创建Fiber树时，每个组件对应的fiber都是通过如下两个逻辑之一创建的： render。即调用render函数，根据返回的JSX创建新的fiber。 bailout。即满足一定条件时，React判断该组件在更新前后没有发生变化，则复用该组件在上一次更新的fiber作为本次更新的fiber。 可以看到，当命中bailout逻辑时，是不会调用render函数的。 所以，Son组件不会打印child render!是因为命中了bailout逻辑。 bailout需要满足的条件什么情况下会进入bailout逻辑？当同时满足如下4个条件时： 1. oldProps === newProps ？即本次更新的props（newProps）不等于上次更新的props（oldProps）。 注意这里是全等比较。 我们知道组件render会返回JSX，JSX是React.createElement的语法糖。 所以render的返回结果实际上是React.createElement的执行结果，即一个包含props属性的对象。 即使本次更新与上次更新props中每一项参数都没有变化，但是本次更新是React.createElement的执行结果，是一个全新的props引用，所以oldProps !== newProps。 如果我们使用了PureComponent或Memo，那么在判断是进入render还是bailout时，不会判断oldProps与newProps是否全等，而是会对props内每个属性进行浅比较。 2. context没有变化即context的value没有变化。 3. workInProgress.type === current.type ？更新前后fiber.type是否变化，比如div是否变为p。 4. !includesSomeLane(renderLanes, updateLanes) ？当前fiber上是否存在更新，如果存在那么更新的优先级是否和本次整棵fiber树调度的优先级一致？ 如果一致则进入render逻辑。 就我们的Demo来说，Parent是整棵树中唯一能触发更新的组件（通过调用setCount）。 所以Parent对应的fiber是唯一满足条件4的fiber。 Demo的详细执行逻辑所以，Demo中Son进入bailout逻辑，一定是同时满足以上4个条件。我们一个个来看。 条件2，Demo中没有用到context，满足。 条件3，更新前后type都为Son对应的函数组件，满足。 条件4，Son本身无法触发更新，满足。 所以，重点是条件1。让我们详细来看下。 本次更新开始时，Fiber树存在如下2个fiber： FiberRootNode | RootFiber 其中FiberRootNode是整个应用的根节点，RootFiber是调用ReactDOM.render创建的fiber。 首先，RootFiber会进入bailout的逻辑，所以返回的App fiber和更新前是一致的。 FiberRootNode | RootFiber | App fiber由于App fiber是RootFiber走bailout逻辑返回的，所以对于App fiber，oldProps === newProps。并且bailout剩下3个条件也满足。 所以App fiber也会走bailout逻辑，返回Parent fiber。 FiberRootNode | RootFiber | App fiber | Parent fiber由于更新是Parent fiber触发的，所以他不满足条件4，会走render的逻辑。 接下来是关键 如果render返回的Son是如下形式： &lt;Son/&gt;会编译为 React.createElement(Son, null)执行后返回JSX。 由于props的引用改变，oldProps !== newProps。会走render逻辑。 但是在Demo中Son是如下形式： {props.children}其中，props.children是Son对应的JSX，而这里的props是App fiber走bailout逻辑后返回的。 所以Son对应的JSX与上次更新时一致，JSX中保存的props也就一致，满足条件1。 可以看到，Son满足bailout的所有条件，所以不会render。","tags":[{"name":"react","slug":"react","permalink":"https://github.com/NollieLeo/tags/react/"}]},{"title":"优雅的处理asnyc await","date":"2020-11-08T06:39:36.000Z","path":"2020/11/08/优雅的处理asnyc-await/","text":"上代码 const errorCaptured = async (asyncFunc) =&gt; { try { const res = await asyncFunc(); return [null, res]; } catch (error) { return [error, null]; } };","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"async await","slug":"async-await","permalink":"https://github.com/NollieLeo/tags/async-await/"}]},{"title":"useRef拿子组件方法","date":"2020-11-08T04:58:36.000Z","path":"2020/11/08/useRef拿子组件方法/","text":"img useRef是一个方法，且useRef返回一个可变的ref对象（对象！！！） initialValue被赋值给其返回值的.current对象 可以保存任何类型的值:dom、对象等任何可辨值 ref对象与自建一个{current：‘’}对象的区别是：useRef会在每次渲染时返回同一个ref对象，即返回的ref对象在组件的整个生命周期内保持不变。自建对象每次渲染时都建立一个新的。 ref对象的值发生改变之后，不会触发组件重新渲染。有一个窍门，把它的改边动作放到useState()之前。 本质上，useRef就是一个其.current属性保存着一个可变值“盒子”。目前我用到的是pageRef和sortRef分别用来保存分页信息和排序信息。 上代码 // 父组件 import React, { useRef, useEffect, useImperativeHandle, forwardRef, } from &quot;react&quot;; import Child from &#39;./TestItem&#39;; const RefDemo = () =&gt; { const domRef = useRef(1); const childRef = useRef(null); useEffect(() =&gt; { console.log(&quot;ref:deom-init&quot;, domRef, domRef.current); console.log(&quot;ref:child-init&quot;, childRef, childRef.current); },[]); const showChild = () =&gt; { console.log(&quot;ref:child&quot;, childRef, childRef.current); childRef.current.say(); }; return ( &lt;div style={{ margin: \"100px\", border: \"2px dashed\", padding: \"20px\" }}&gt; &lt;h2&gt;这是外层组件&lt;/h2&gt; &lt;div onClick={() =&gt; { console.log(&quot;ref:deom&quot;, domRef, domRef.current); domRef.current.focus(); if(!domRef.current.value){ domRef.current.value = &#39;hh&#39;; } }} &gt; &lt;label&gt;这是一个dom节点&lt;/label&gt;&lt;input ref={domRef} /&gt; &lt;/div&gt; &lt;br /&gt; &lt;p onClick={showChild} style={{ marginTop: \"20px\" }}&gt; 这是子组件 &lt;/p&gt; &lt;div style={{ border: \"1px solid\", padding: \"10px\" }}&gt; &lt;Child ref={childRef} /&gt; &lt;/div&gt; &lt;/div&gt; ); }; export default RefDemo; useImperativeHandle(ref,createHandle,[deps])可以自定义暴露给父组件的实例值。如果不使用，父组件的ref(chidlRef)访问不到任何值（childRef.current==null） useImperativeHandle应该与forwradRef搭配使用 React.forwardRef会创建一个React组件，这个组件能够将其接受的ref属性转发到其组件树下的另一个组件中。 React.forward接受渲染函数作为参数，React将使用prop和ref作为参数来调用此函数 // 子组件 import React, { useRef, useEffect, useImperativeHandle, forwardRef, } from &quot;react&quot;; const ChildComponent = (props, ref) =&gt; { useImperativeHandle(ref, () =&gt; ({ say: sayHello, })); const sayHello = () =&gt; { alert(&quot;hello,我是子组件&quot;); }; return &lt;h3&gt;子组件&lt;/h3&gt;; }; const Child = forwardRef(ChildComponent); export default Child;","tags":[{"name":"react","slug":"react","permalink":"https://github.com/NollieLeo/tags/react/"},{"name":"react hooks","slug":"react-hooks","permalink":"https://github.com/NollieLeo/tags/react-hooks/"}]},{"title":"网格布局具体实现","date":"2020-10-14T06:43:23.000Z","path":"2020/10/14/网格布局具体实现/","text":"需求类似下图的效果： 1.gif 需求分析 2.gif 这种就是网格布局 父容器的宽自适应，子容器的宽计算公式为 (100% - (n - 1) * 24) / n 。如果页面宽度大于1280px，n等于5，小于1280px时，n等于4，页面最小宽度是960px; 解决方案Grid布局教程看这里：阮一峰grid布局教程 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;style&gt; .parent { display: grid; grid-template-columns: repeat(5, 1fr); grid-row-gap: 24px; grid-column-gap: 24px; } .children { background-color: antiquewhite; height: 20px; } @media screen and (max-width: 1280px) { .parent { grid-template-columns: repeat(4, 1fr); } } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;children&quot;&gt; &lt;div class=&quot;children-content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;children&quot;&gt; &lt;div class=&quot;children-content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;children&quot;&gt; &lt;div class=&quot;children-content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;children&quot;&gt; &lt;div class=&quot;children-content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;children&quot;&gt; &lt;div class=&quot;children-content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;children&quot;&gt; &lt;div class=&quot;children-content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;children&quot;&gt; &lt;div class=&quot;children-content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;children&quot;&gt; &lt;div class=&quot;children-content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;children&quot;&gt; &lt;div class=&quot;children-content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;children&quot;&gt; &lt;div class=&quot;children-content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;","tags":[{"name":"css","slug":"css","permalink":"https://github.com/NollieLeo/tags/css/"},{"name":"grid布局","slug":"grid布局","permalink":"https://github.com/NollieLeo/tags/grid%E5%B8%83%E5%B1%80/"},{"name":"flex布局","slug":"flex布局","permalink":"https://github.com/NollieLeo/tags/flex%E5%B8%83%E5%B1%80/"}]},{"title":"策略模式","date":"2020-08-30T01:57:30.000Z","path":"2020/08/30/策略模式/","text":"策略模式 在程序设计中，要实现某一个功能有多种方案可以选择。 定义：定义一系列地算法，把他们一个个封装起来，并且使他们可以互相替换","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/NollieLeo/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"函数柯里化","date":"2020-08-24T14:19:56.000Z","path":"2020/08/24/函数柯里化/","text":"柯里化 在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。 例如需要实现以下得示例 add(1, 2, 3) // 6 add(1) // 1 add(1)(2) // 3 add(1, 2)(3) // 6 add(1)(2)(3) // 6 add(1)(2)(3)(4) // 10 本来有这么一个求和函数dynamicAdd()，接受任意个参数。 function dynamicAdd() { return [...arguments].reduce((prev, curr) =&gt; { return prev + curr }, 0) } 现在需要通过柯里化把它变成一个新的函数，这个新的函数预置了第一个参数，并且可以在调用时继续传入剩余参数。 function curry(fn,firstArg){ // 返回一个新函数 return function(){ // 将arguments转化为真正数组 var restArgs = Array.from(arguments); return fn.apply(this,[firstArg,...restArgs]) } } // 柯里化，预置参数10 var add10 = curry(dynamicAdd, 10) add10(5); // 15 // 柯里化，预置参数20 var add20 = curry(dynamicAdd, 20); add20(5); // 25 // 也可以对一个已经柯里化的函数add10继续柯里化，此时预置参数10即可 var anotherAdd20 = curry(add10, 10); anotherAdd20(5); // 25 柯里化是在一个函数的基础上进行变换，得到一个新的预置了参数的函数。最后在调用新函数时，实际上还是会调用柯里化前的原函数。 并且柯里化得到的新函数可以继续被柯里化 实际使用时也会出现柯里化的变体，不局限于只预置一个参数。 function curry(fn) { // 保存预置参数 var presetArgs = [].slice.call(arguments, 1) // 返回一个新函数 return function() { // 新函数调用时会继续传参 var restArgs = [].slice.call(arguments) // 参数合并，通过apply调用原函数 return fn.apply(this, [...presetArgs, ...restArgs]) } } 1. 参数定长的柯里化假设存在一个原函数fn，fn接受三个参数a, b, c，那么函数fn最多被柯里化三次（有效地绑定参数算一次）。 function fn(a, b, c) { return a + b + c } var c1 = curry(fn, 1); var c2 = curry(c1, 2); var c3 = curry(c2, 3); c3(); // 6 // 再次柯里化也没有意义，原函数只需要三个参数 var c4 = curry(c3, 4); c4(); 也就是说，我们可以通过柯里化缓存的参数数量，来判断是否到达了执行时机。那么我们就得到了一个柯里化的通用模式。 function curry(fn) { // 获取原函数的参数长度 const argLen = fn.length; // 保存预置参数 const presetArgs = [].slice.call(arguments, 1) // 返回一个新函数 return function() { // 新函数调用时会继续传参 const restArgs = [].slice.call(arguments) const allArgs = [...presetArgs, ...restArgs] if (allArgs.length &gt;= argLen) { // 如果参数够了，就执行原函数 return fn.apply(this, allArgs) } else { // 否则继续柯里化 return curry.call(null, fn, ...allArgs) } } } function fn(a,b,c){ return a+b+c; } var curried = curry(fn); curried(1,2,3); curried(1,2)(3); curried(1)(2,3); curried(1)(2)(3); 2. 参数不定长地柯里化 在参数不定长的情况下，要同时支持1~N次调用还是挺难 如果要支持参数不定长的场景，已经柯里化的函数在执行完毕时不能返回一个值，只能返回一个函数；同时要让JS引擎在解析得到的这个结果时，能求出我们预期的值 经curry处理，得到一个新函数，这一点不变。 // curry是一个函数 var curried = curry(add); 新函数执行后仍然返回一个结果函数。 // curried10也是一个函数 var curried10 = curried(10); var curried30 = curried10(20); 结果函数可以被Javascript引擎解析，得到一个预期的值。 curried10; // 10 关键点在于3，如何让Javascript引擎按我们的预期进行解析，这就回到Javascript基础了。在解析一个函数的原始值时，会用到toString function curry(fn) { // 保存预置参数 const presetArgs = [].slice.call(arguments, 1) // 返回一个新函数 function curried () { // 新函数调用时会继续传参 const restArgs = [].slice.call(arguments) const allArgs = [...presetArgs, ...restArgs] return curry.call(null, fn, ...allArgs) } // 重写toString curried.toString = function() { return fn.apply(null, presetArgs) } return curried; } 总结柯里化是一种函数式编程思想，实际上在项目中可能用得少，或者说用得不深入，但是如果你掌握了这种思想，也许在未来的某个时间点，你会用得上！ 大概来说，柯里化有如下特点： 简洁代码：柯里化应用在较复杂的场景中，有简洁代码，可读性高的优点。 参数复用：公共的参数已经通过柯里化预置了。 延迟执行：柯里化时只是返回一个预置参数的新函数，并没有立刻执行，实际上在满足条件后才会执行。 管道式流水线编程：利于使用函数组装管道式的流水线工序，不污染原函数。","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"闭包","slug":"闭包","permalink":"https://github.com/NollieLeo/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"单例模式","date":"2020-08-23T05:28:14.000Z","path":"2020/08/23/单例模式/","text":"单例模式 保证一个类仅有一个实例，并提供给一个访问它的全局访问点。 1. 实现简单的单例模式var Singleton = function(name){ this.name = name; } Singleton.instance = null; Singleton.prototype.getName = function(){ alert(this.name); } Singleton.getInstance = function(name){ if(!this.instance){ this.instance = new Singleton(name); } return this.instance } var a1 = Singleton.getInstance(&#39;a1&#39;); var a2 = Singleton.getInstance(&#39;a2&#39;); a1 === a2 // true; 或者直接用闭包 var Singleton = function(name){ this.name = name; } Singleton.prototype.getName = function(){ altert(this.name); } Singleton.getInstance = (function(){ var instance = null; return function(name){ if(!instance){ instance = new Singleton(name); } return this.instance; } })(); 这种方式相对简单，但是增加了这个类的“不透明性”，这个类的使用者必须知道这个是一个单例，与之前的new一个类不同，使用者要用getinstance来获取对象 2.透明的单例模式 目标：实现一个“透明的单例类”，用户从这个类中创建对象的时候，可以像使用其他任何普通类一样。 下面例子用CreateDiv单例类，负责在页面中创建唯一的div节点 var CreateDiv = (function{ var instance; var CreateDiv = function(html){ if(instance){ return instance; } this.html = html; this.init(); return instance = this; } CreateDiv.prototype.init = function(){ var div = document.createElement(&#39;div&#39;); div.innerHtml = this.html; document.body.appendChild(div); } return CreateDiv; })(); var a1 = new CreateDiv(&#39;a1&#39;); var a2 = new CreateDiv(&#39;a2&#39;); a1 === a2 // true; 虽然透明了，但有缺点，为了把instance封起来，我们使用了自执行的匿名函数和闭包，并且让这个匿名函数返回真正的Singleton构造方法，增加了复杂度。 假如某天我们需要利用这个类，再页面中创建许多div，则就要让这个单例类变成一个普通的可产生多个实例的类，那我们必须得改写CreateDiv构造函数，把控制创建唯一对象的那段去掉。 3.用代理实现由上可以知道，要想使得这个单例类变成一个普通的可以产生多个实例的类，那我们必须得改。 这时候我们把负责管理单例的代码移除出去，使他成为一个普通的创建div的类： var CreateDiv = function(html){ this.html = html; this.init(); } CreateDiv.prototype.init = function(){ var div = document.createElement(&#39;div&#39;); div.innerHTML = this.html; document.body.appendChild(div); } 接下来引入代理类ProxySingletonCreateDiv var ProxySingletonCreateDiv = (function(){ var instance; return function(html){ if(!instance){ instance = new CreateDiv(html); } return instance; } })(); var a1 = new ProxySingletonCreateDiv(&#39;a1&#39;); var a2 = new ProxySingletonCreateDiv(&#39;a2&#39;); a1 === a2; // true; 这两个连起来就就可以就可以实现单例模式的实现，通过代理类加上一个CreateDiv普通类，组合 4. js中的单例模式js是一门无类语言。传统的单例模式实现再js中并不适用 单例模式的核心是确保只有一个实例，并提供全局访问 全局变量不是单例模式，单再js开发中，我们经常会把全局变量当成单例来使用 var a ={}; 但是这样变量容易被覆盖。 因此需要降低全局变量命名的污染。 4.1 使用命名空间var namespace = { a:function(){ ... }, b:function(){ ... } } 4.2 使用闭包封装私有变量这种方法把一些变量封装再闭包内部，只暴露接口与外界通信 var user = (function(){ var _name = &#39;seven&#39;,_age = 29; return { getUserInfo:function(){ return _name + &#39;-&#39; + _age; } } })(); 我们用下划线约定_name 和 _age。 5.惰性单例惰性单例指的是需要的时候才去创建的对象实例。 例如：我们需要点击一个按钮显示一个弹窗，这个浮窗再这个页面里头是唯一的，不可能同时出现两个 方法一：在页面加载之后就去创建，然后点击btn把他显示出来 &lt;html&gt; &lt;body&gt; &lt;button id=&quot;loginBtn&quot;&gt; 登录 &lt;/button&gt; &lt;/body&gt; &lt;script&gt; var loginLayer = (function(){ var div = document.createElement(&#39;div&#39;); div.innerHTML = &#39;我是登录浮窗&#39;; div.style.display = &#39;none&#39;; document.body.appendChild(div); return div; })(); document.getElementById(&#39;loginBtn&#39;).onclick = function(){ loginLayer.style.display = &#39;block&#39; } &lt;/script&gt; &lt;/html&gt; ，但是如果有时候不需要就不需要浪费空间去创建节点，需要改进 现在是点击的时候才会去创建节点 &lt;html&gt; &lt;body&gt; &lt;button id=&quot;loginBtn&quot;&gt; 登录 &lt;/button&gt; &lt;/body&gt; &lt;script&gt; var loginLayer = function(){ var div = document.createElement(&#39;div&#39;); div.innerHTML = &#39;我是登录浮窗&#39;; div.style.display = &#39;none&#39;; document.body.appendChild(div); return div; }; document.getElementById(&#39;loginBtn&#39;).onclick = function(){ var loginLayer = createLoginLayer(); loginLayer.style.display = &#39;block&#39; } &lt;/script&gt; &lt;/html&gt; 但是虽然实现了惰性，这样就失去了单例的效果，频繁的增删不太合适。 此时可以用一个变量判断是否已经创建过浮窗了。 var createLoginLayer = (function(){ var div; return function(){ if(!div){ var div = document.createElement(&#39;div&#39;); div.innerHTML = &#39;我是登录浮窗&#39;; div.style.display = &#39;none&#39;; document.body.appendChild(div); } return div; } })() document.getElementById(&#39;loginBtn&#39;).onclick = function(){ var loginLayer = createLoginLayer(); loginLayer.style.display = &#39;block&#39; } 但是这个却违反了单一职责原则，这里创建和管理单例的逻辑全部都放在了一个func里头，但下次如果要创建iframe或者其他的东西，那就只能照抄代码了 因此把不变的部分分出来，把管理单例的逻辑抽出来，之后传创建的逻辑就行了。 var getSingle = function(fn){ var result ; return function(){ return result || result = fn.apply(this,arguments); } } 接下来就可以用于创建弹窗的方法用于参数fn的形式传入getSingle，创建啥都行，用result保存fn的己算结果。result身在闭包中，永远不会销毁，之后如果result有值，直接返回 var createLoginLayer = function(){ var div = document.createElement(&#39;div&#39;); div.innerHTML = &#39;我是登录浮窗&#39;; div.style.display = &#39;none&#39;; document.body.appendChild(div); return div; } var createSingleLoginLayer = getSingle(createLoginLayer); document.getElementById(&#39;loginBtn&#39;).onclick = function(){ var loginLayer = createSingleLoginLayer(); loginLayer.style.display = &#39;block&#39; } // 创建ifame啥的也是一样","tags":[{"name":"js设计模式","slug":"js设计模式","permalink":"https://github.com/NollieLeo/tags/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"单例模式","permalink":"https://github.com/NollieLeo/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"typeScript总结","date":"2020-08-02T14:44:13.000Z","path":"2020/08/02/typeScript总结/","text":"ts中需要理解的- any vs unknownany 表示任意类型，这个类型会逃离 Typescript 的类型检查，和在 Javascript 中一样，any 类型的变量可以执行任意操作，编译时不会报错。 unknown 也可以表示任意类型，但它同时也告诉 Typescript 开发者对其也是一无所知，做任何操作时需要慎重。这个类型仅可以执行有限的操作（==、=== 、||、&amp;&amp;、?、!、typeof、instanceof 等等），其他操作需要向 Typescript 证明这个值是什么类型，否则会提示异常。 let foo: any let bar: unknown foo.functionNotExist() bar.functionNotExist() // 对象的类型为 &quot;unknown&quot;。 if (!!bar) { // ==、=== 、||、&amp;&amp;、?、!、typeof、instanceof console.log(bar) } bar.toFixed(1) // Error if (typeof bar=== &#39;number&#39;) { bar.toFixed(1) // OK } any 会增加了运行时出错的风险，不到万不得已不要使用。表示【不知道什么类型】的场景下使用 unknown。 - {} vs object vs Objectobject 表示的是常规的 Javascript 对象类型，非基础数据类型。 declare function create(o: object): void; create({ prop: 0 }); // OK create(null); // Error create(undefined); // Error create(42); // Error create(&quot;string&quot;); // Error create(false); // Error create({ toString() { return 3; }, }); // OK {} 表示的非 null，非 undefined 的任意类型。 declare function create(o: {}): void; create({ prop: 0 }); // OK create(null); // Error create(undefined); // Error create(42); // OK create(&quot;string&quot;); // OK create(false); // OK create({ toString() { return 3; }, }); // OK Object 和 {} 几乎一致，区别是 Object 类型会对 Object 原型内置的方法（toString/hasOwnPreperty）进行校验。 declare function create(o: Object): void; create({ prop: 0 }); // OK create(null); // Error create(undefined); // Error create(42); // OK create(&quot;string&quot;); // OK create(false); // OK create({ toString() { return 3; }, }); // Error - Never 类型never 类型表示的是那些永不存在的值的类型。 例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。 // 返回never的函数必须存在无法达到的终点 function error(message: string): never { throw new Error(message); } function infiniteLoop(): never { while (true) {} } 在 TypeScript 中，可以利用 never 类型的特性来实现全面性检查，具体示例如下： type Foo = string | number; function controlFlowAnalysisWithNever(foo: Foo) { if (typeof foo === &quot;string&quot;) { // 这里 foo 被收窄为 string 类型 } else if (typeof foo === &quot;number&quot;) { // 这里 foo 被收窄为 number 类型 } else { // foo 在这里是 never const check: never = foo; } } 注意在 else 分支里面，我们把收窄为 never 的 foo 赋值给一个显示声明的 never 变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 Foo 的类型： type Foo = string | number | boolean; 然而他忘记同时修改 controlFlowAnalysisWithNever 方法中的控制流程，这时候 else 分支的 foo 类型会被收窄为 boolean 类型，导致无法赋值给 never 类型，这时就会产生一个编译错误。通过这个方式，我们可以确保controlFlowAnalysisWithNever 方法总是穷尽了 Foo 的所有可能类型。 通过这个示例，我们可以得出一个结论：使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。 - type vs interface两者都可以用来定义类型。 interface（接口） 只能声明对象类型，支持声明合并（可扩展）。 interface User { id: string } interface User { name: string } const user = {} as User console.log(user.id); console.log(user.name); type（类型别名）不支持声明合并、行为有点像const, let 有块级作用域。 type User = { id: string, } if (true) { type User = { name: string, } const user = {} as User; console.log(user.name); console.log(user.id) // 类型“User”上不存在属性“id”。 } type 更为通用，右侧可以是任意类型，包括表达式运算，以及映射类型等等。 type A = number type B = A | string type ValueOf&lt;T&gt; = T[keyof T]; 如果你是在开发一个包，模块，允许别人进行扩展就用 interface，如果需要定义基础数据类型或者需要类型运算，使用 type。 - enum vs const enum默认情况下 enum 会被编译成 Javascript 对象，并且可以通过 value 反向查找。 enum ActiveType { active = 1, inactive = 2, } function isActive(type: ActiveType) {} isActive(ActiveType.active); // ============================== compile result: // var ActiveType; // (function (ActiveType) { // ActiveType[ActiveType[&quot;active&quot;] = 1] = &quot;active&quot;; // ActiveType[ActiveType[&quot;inactive&quot;] = 2] = &quot;inactive&quot;; // })(ActiveType || (ActiveType = {})); // function isActive(type) { } // isActive(ActiveType.active); ActiveType[1]; // OK ActiveType[10]; // OK！！！ cosnt enum 默认情况下不会生成 Javascript 对象而是把使用到的代码直接输出 value，不支持 value 反向查找。 const enum ActiveType { active = 1, inactive = 2, } function isActive(type: ActiveType) {} isActive(ActiveType.active); // ============================== compile result: // function isActive(type) { } // isActive(1 /* active */); ActiveType[1]; // Error ActiveType[10]; // Error 类型运算集合运算&amp; 在 JS 中表示位与运算符，在 Typescript 中用来计算两个类型的交集。 type Type1 = &quot;a&quot; | &quot;b&quot;; type Type2 = &quot;b&quot; | &quot;c&quot;; type Type3 = Type1 &amp; Type2; // &#39;b&#39; | 在 JS 中表示位或运算符，在 Typescript 中用来计算两个类型的并集。 type Type1 = &quot;a&quot; | &quot;b&quot;; type Type2 = &quot;b&quot; | &quot;c&quot;; type Type3 = Type1 | Type2; // &#39;a&#39; &#39;b&#39; &#39;c&#39; 索引签名索引签名可以用来定义对象内的属性、值的类型，例如定义一个 React 组件，允许 Props 可以传任意 key 为 string，value 为 number 的 props。 interface Props { [key: string]: number } &lt;Component count={1} /&gt; // OK &lt;Component count={true} /&gt; // Error &lt;Component count={&#39;1&#39;} /&gt; // Error 类型键入类型键入允许 Typescript 像对象取属性值一样使用类型。 type User = { userId: string friendList: { fristName: string lastName: string }[] } type UserIdType = User[&#39;userId&#39;] // string type FriendList = User[&#39;friendList&#39;] // { fristName: string; lastName: string; }[] type Friend = FriendList[number] // { fristName: string; lastName: string; } 在上面的例子中，我们利用类型键入的功能从 User 类型中计算出了其他的几种类型。FriendList[number] 这里的 number 是关键字，用来取数组子项的类型。在元组中也可以使用字面量数字得到数组元素的类型。 type Tuple = [number, string] type First = Tuple[0] // number type Second = Tuple[1] // string typeof valuetypeof 关键字在 JS 中用来获取变量的类型，运算结果是一个字符串（值）。而在 TS 中表示的是推算一个变量的类型（类型） let str1 = &#39;fooooo&#39; type Type1 = typeof str1 // type string const str2 = &#39;fooooo&#39; type Type2 = typeof str2 // type &quot;fooooo&quot; typeof 在计算变量和常量时有所不同，由于常量时不会变的，所以 Typescript 会使用严格的类型，例如下面 Type2 的例子，str2 的是个 ‘fooooo’ 类型的字符串。而变量会是宽松的字符串类型。 keyof Typekeyof 关键字可以用来获取一个对象类型的所有 key 类型。 type User = { id: string; name: string; }; type UserKeys = keyof User; //&quot;id&quot; | &quot;name&quot; enum 在 Typescript 中有一定的特殊性（有时表示类型，又是表示值），如果要获取 enum 的 key 类型，需要先把它当成值，用 typeof 再用 keyof。 enum ActiveType { Active, Inactive } type KeyOfType = keyof typeof ActiveType // &quot;Active&quot; | &quot;Inactive&quot; extendsextends 关键字同样存在多种用途，在 interface 中表示类型扩展，在条件类型语句中表示布尔运算，在泛型中起到限制的作用，在 class 中表示继承。 // 表示类型扩展 interface A { a: string } interface B extends A { // { a: string, b: string } b: string } // 条件类型中起到布尔运算的功能 type Bar&lt;T&gt; = T extends string ? &#39;string&#39; : never type C = Bar&lt;number&gt; // never type D = Bar&lt;string&gt; // string type E = Bar&lt;&#39;fooo&#39;&gt; // string // 起到类型限制的作用 type Foo&lt;T extends object&gt; = T type F = Foo&lt;number&gt; // 类型“number”不满足约束“object”。 type G = Foo&lt;string&gt; // 类型“string”不满足约束“object”。 type H = Foo&lt;{}&gt; // OK // 类继承 class I {} class J extends I {} 泛型假设 filter 方法传入一个数字类型的数组，及一个返回布尔值的方法，最终过滤出想要的结果返回，声明大致如下。 declare function filter( array: number[], fn: (item: unknown) =&gt; boolean ): number[]; 过了一段时间，需要使用 filter 方法来过滤一些字符串，可以使用 Typescript 的函数重载的功能，filter 内部代码不变，只需要添加类型定义。 declare function filter( array: string[], fn: (item: unknown) =&gt; boolean ): string[]; declare function filter( array: number[], fn: (item: unknown) =&gt; boolean ): number[]; 又过了一段时间，需要用 filter 来过滤 boolean[], 过滤 object[], 过滤其他具体类型，如果仍然使用重载的方法将会出现非常多重复的代码。这时候就可以考虑使用泛型了，Dont repeat yourself。 泛型就像 Typescript “语言” 中的“方法”，可以通过“传参”来得到新的类型。日常开发中经常用到的泛型有 Promise、Array、React.Component 等等。 使用泛型来改造 filter 方法: declare function filter&lt;T&gt;( array: T[], fn: (item: unknown) =&gt; boolean ): T[]; 只需要在方法名后面加上尖括号&lt;T&gt;，表示方法支持一个泛型参数，(这里的 T 可以改为任意你喜欢的变量名，大部分人的偏好是从 T、U、V…开始命名)，array: T[] 表示传入的第一个参数是泛型模板类型的数组，:T[] 表示方法会返回模板类型的数组。Typescript 将会自动根据传参类型辨别出 T 实际代表的类型，这样就可以保留类型的同时，避免重复代码了 filter([1, 2, 3], () =&gt; true) // function filter&lt;number&gt;(array: number[], fn: (item: unknown) =&gt; boolean): number[] filter([&#39;1&#39;, &#39;2&#39;, &#39;3&#39;], () =&gt; true) // function filter&lt;string&gt;(array: string[], fn: (item: unknown) =&gt; boolean): string[] 把泛型比喻成“方法”之后，很多行为都很好理解。“方法”可以传参，可以有多个参数，可以有默认值，泛型也可以。 type Foo&lt;T, U = string&gt; = { // 多参数、默认值 foo: Array&lt;T&gt; // 可以传递 bar: U } type A = Foo&lt;number&gt; // type A = { foo: number[]; bar: string; } type B = Foo&lt;number, number&gt; // type B = { foo: number[]; bar: number; } 别忘了，泛型参数还可以有限制，例如下面的例子 extends 的作用是限制 T 至少是个 HTMLElement 类型。 type MyEvent&lt;T extends HTMLElement = HTMLElement&gt; = { target: T, type: string } 映射类型关键字 inin 关键字在类型中表示类型映射，和索引签名的写法有些相似。下面的例子中声明一个 Props 的类型，key 类型为 ‘count’ | ‘id’ 类型，value 为 number 类型。 type Props = { [key in &#39;count&#39; | &#39;id&#39;]: number } const props1: Props = { // OK count: 1, id: 1 } const props2: Props = { count: &#39;1&#39;, // ERROR id: 1 } const props3: Props = { count: 1, id: 1, name: 1 // ERROR } RecordRecord 定义键类型为 Keys、值类型为 Values 的对象类型。 示例 : enum ErrorCodes { Timeout = 10001, ServerBusy = 10002, } const ErrorMessageMap: Record&lt;ErrorCodes, string&gt; = { [ErrorCodes.Timeout]: &#39;Timeout, please try again&#39;, [ErrorCodes.ServerBusy]: &#39;Server is busy now&#39; } 类型映射还可以用来做全面性检查，例如上面的例子中如果漏了某个 ErrorCodes，Typescript 同样会抛出异常。 enum ErrorCodes { Timeout = 10001, ServerBusy = 10002, AuthFailed = 10003 } // 类型 &quot;{ 10001: string; 10002: string; }&quot; 中缺少属性 &quot;10003&quot;，但类型 &quot;Record&lt;ErrorCodes, string&gt;&quot; 中需要该属性 const ErrorMessageMap: Record&lt;ErrorCodes, string&gt; = { [ErrorCodes.Timeout]: &#39;Timeout, please try again&#39;, [ErrorCodes.ServerBusy]: &#39;Server is busy now&#39; } 代码实现： type Record&lt;K extends keyof any, T&gt; = { [P in K]: T; }; PartialPartial 可以将类型定义的属性变成可选。 示例： type User = { id?: string, gender: &#39;male&#39; | &#39;female&#39; } type PartialUser = Partial&lt;User&gt; // { id?: string, gender?: &#39;male&#39; | &#39;female&#39;} function createUser (user: PartialUser = { gender: &#39;male&#39; }) {} User 类型对于 gender 属性是要求必须有的(: 用户必须有性别才行。而在设计 createUser 方法时，为了方便程序会给 gender 赋予默认值。这时候可以将参数修改成 Partial，使用者就可以不用必须传 gender 了。 代码实现： type Partial&lt;T&gt; = { [U in keyof T]?: T[U]; }; RequiredRequired 和 Partial 的作用相反，是将对象类型的属性都变成必须。 示例： type User = { id?: string, gender: &#39;male&#39; | &#39;female&#39; } type RequiredUser = Required&lt;User&gt; // { readonly id: string, readonly gender: &#39;male&#39; | &#39;female&#39;} function showUserProfile (user: RequiredUser) { console.log(user.id) // 不需要加 ！ console.log(user.gender) } 任然使用 User 类型，id 属性定义的时候是可选的（要创建了才有 id），而展示的时候 User id 肯定已经存在了，这时候可以使用 Required，那么调用 showUserProfile 时 User 所有属性都必须非 undefined。 代码实现： type Required&lt;T&gt; = { [U in keyof T]-?: T[U]; }; -? 符号在这里表示的意思是去掉可选符号 ?。 ReadonlyReadonly 是将对象类型的属性都变成只读。 示例： type ReadonlyUser = Readonly&lt;User&gt; // { readonly id?: string, readonly gender: &#39;male&#39; | &#39;female&#39;} const user: ReadonlyUser = { id: &#39;1&#39;, gender: &#39;male&#39; } user.gender = &#39;femail&#39; // 无法分配到 &quot;gender&quot; ，因为它是只读属性。 代码实现： type Readonly&lt;T&gt; = { readonly [U in keyof T]: T[U]; }; PickPick 是挑选类型中的部分属性。 示例： type Location = { latitude: number longitude: number city: string address: string province: string district: string } type LatLong = Pick&lt;Location, &#39;latitude&#39; | &#39;longitude&#39;&gt; // { latitude: number; longitude: number; } const region: LatLong = { latitude: 22.545001, longitude: 114.011712 } 代码实现： type Pick&lt;T, K extends keyof T&gt; = { [P in K]: T[P]; }; OmitOmit 结合了 Pick 和 Exclude，将忽略对象类型中的部分 keys。 示例： interface Todo { title: string; description: string; completed: boolean; } type TodoPreview = Omit&lt;Todo, &quot;description&quot;&gt;; // { title: string; completed: boolean; } const todo: TodoPreview = { title: &quot;Clean room&quot;, completed: false, }; 代码实现： type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;; 条件类型三目运算符Typescript 类型运算也支持“三目运算符”，称之为条件类型，一般通过 extends 关键字判断条件成不成立，成立的话得到一个类型，不成立的话返回另一个类型。条件类型通常是与泛型同时出现的（：因为如果是已知固定类型就没必要再判断了。 type IsString&lt;T&gt; = T extends string ? true : false type A = IsString&lt;number&gt; // false type B = IsString&lt;string&gt; // true 在处理并集时，条件类型还具有条件分配的逻辑，number | string 做条件运算等价于 number 条件运算 | string 条件运算 type ToArray&lt;T&gt; = T[] type A = ToArray&lt;number | string&gt; // (string | number)[] type ToArray2&lt;T&gt; = T extends unknown ? T[] : T[]; type B = ToArray2&lt;number | string&gt;; // string[] | number[] infer除了显示声明泛型参数，Typescript 还支持动态推导泛型，用到的是 infer 关键字。什么场景下还需要动态推导？通常是需要通过传入的泛型参数去获取新的类型，这和直接定义一个新的泛型参数不一样。 例如现在定义了 ApiResponse 的两个具体类型 UserResponse 和 EventResponse，如果想得到 User 实体类型和 Event 实体类型需要怎么做？ type ApiResponse&lt;T&gt; = { code: number data: T }; type UserResponse = ApiResponse&lt;{ id: string, name: string }&gt; type EventResponse = ApiResponse&lt;{ id: string, title: string }&gt; 当然可以拎出来单独定义新的类型。 type User = { id: string, name: string } type UserResponse = ApiResponse&lt;User&gt; 但如果类型是由其他人提供的就不好处理了。这时可以尝试下使用 infer，代码如下： type ApiResponseEntity&lt;T&gt; = T extends ApiResponse&lt;infer U&gt; ? U : never; type User = ApiResponseEntity&lt;UserResponse&gt;; // { id: string; name: string; } type Event = ApiResponseEntity&lt;EventResponse&gt;; // { id: string; title: string; } 示例中，判断传入的类型 T 是不是 T extends ApiResponse 的子集，这里的 infer 既是让 Typescript 尝试去理解 T 具体是那种类型的 ApiResponse，生成新的泛型参数 U。如果满足 extends 条件则将 U 类型返回。 充分理解了条件类型和 infer关键字之后，Typescript 自带的条件泛型工具也就很好理解了。 ReturnTypeReturntype 用来获取方法的返回值类型 示例： type A = (a: number) =&gt; string type B = ReturnType&lt;A&gt; // string 代码实现： type ReturnType&lt;T&gt; = T extends ( ...args: any[] ) =&gt; infer R ? R : any; ParametersParameters 用来获取方法的参数类型 示例： type EventListenerParamsType = Parameters&lt;typeof window.addEventListener&gt;; // [type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions | undefined] 代码实现： type Parameters&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: infer P) =&gt; any ? P : never; ExcludeExclude 用来计算在 T 中而不在 U 中的类型 示例： type A = number | string type B = string type C = Exclude&lt;A, B&gt; // number 代码实现： type Exclude&lt;T, U&gt; = T extends U ? never : T; ExtractExtract 用来计算 T 中可以赋值给 U 的类型 示例： type A = number | string type B = string type C = Extract&lt;A, B&gt; // string 代码实现： type Extract&lt;T, U&gt; = T extends U ? T : never; NonNullable从类型中排除 null 和 undefined 示例： type A = { a?: number | null } type B = NonNullable(A[&#39;a&#39;]) // number 代码实现： type NonNullable&lt;T&gt; = T extends null | undefined ? never : T; Event事件对象类型常用的Event事件对象类型 ClipboardEvent&lt;T =Element&gt; 剪贴板事件对象 DragEvent&lt;T =Element&gt; 拖拽事件对象 ChangeEvent&lt;T =Element&gt; Change 事件对象 KeyboardEvent&lt;T =Element&gt; 键盘事件对象 MouseEvent&lt;T =Element&gt; 鼠标事件对象 TouchEvent&lt;T =Element&gt; 触摸事件对象 WheelEvent&lt;T =Element&gt; 滚轮事件对象 AnimationEvent&lt;T =Element&gt; 动画事件对象 TransitionEvent&lt;T =Element&gt; 过渡事件对象 import { MouseEvent } from &#39;react&#39;; interface IProps { onClick (event: MouseEvent&lt;HTMLDivElement&gt;): void, } 组件开发有状态组件export class MyForm extends React.Component&lt;FormProps, FormState&gt; { ... } 其中的FormProps和FormState分别代表这状态组件的props和state的interface 注意：在只有state而没有props的情况下，props的位置可以用{}或者object占位，这两个值都表示有效的空对象。 无状态组件无状态组件也被称为展示组件，如果一个展示组件没有内部的state可以被写为纯函数组件。 如果写的是函数组件，在@types/react中定义了一个类型type SFC = StatelessComponent;。我们写函数组件的时候，能指定我们的组件为SFC或者StatelessComponent。这个里面已经预定义了children等，所以我们每次就不用指定类型children的类型了。 import React, { ReactNode, SFC } from &#39;react&#39;; import style from &#39;./step-complete.less&#39;; export interface IProps { title: string | ReactNode; description: string | ReactNode; } const StepComplete:SFC&lt;IProps&gt; = ({ title, description, children }) =&gt; { return ( &lt;div className={style.complete}&gt; &lt;div className={style.completeTitle}&gt; {title} &lt;/div&gt; &lt;div className={style.completeSubTitle}&gt; {description} &lt;/div&gt; &lt;div&gt; {children} &lt;/div&gt; &lt;/div&gt; ); }; export default StepComplete;","tags":[{"name":"ts","slug":"ts","permalink":"https://github.com/NollieLeo/tags/ts/"}]},{"title":"30-seconds-of-js","date":"2020-07-24T06:07:43.000Z","path":"2020/07/24/30-seconds-of-js/","text":"方法- 对象转queryStrings通过Object.entries以及reduce进行queryString的累加，只能将对象中值为string的转进去，可以改进 const objectToQuerystring = (queryParams) =&gt; { return Object.entries(queryParams).reduce((queryString, [key, value], index) =&gt; { const symbol = queryString.length === 0 ? &#39;?&#39; : &#39;&amp;&#39;; queryString += typeof value === &#39;string&#39; ? `${symbol}${key}=${value}` : &#39;&#39;; return queryString; }, &#39;&#39;); } // ?name=weng&amp;address=11111 - 深度冻结一个对象使用Object.keys（）获取所传递对象的所有属性，使用Array.prototype.forEach（）遍历它们。 在所有属性上递归调用Object.freeze（obj），检查是否使用Object.isFrozen（）冻结了每个属性，并根据需要应用deepFreeze（）。 最后，使用Object.freeze（）冻结给定的对象。 const deepFreeze = obj =&gt; { Object.keys(obj).forEach(prop =&gt; { if (typeof(obj[prop]) === &#39;object&#39; &amp;&amp; !Object.isFrozen(obj[prop])) deepFreeze(obj[prop]); }); return Object.freeze(obj); }; EXAMPLES &#39;use strict&#39;; const o = deepFreeze([1, [2, 3]]); o[0] = 3; // not allowed o[1][0] = 4; // not allowed as well - 获取当前url（不带任何参数）返回没有任何参数的当前URL。 使用String.prototype.indexOf（）检查给定的url是否具有参数，使用String.prototype.slice（）删除它们（如有必要）。 const getBaseURL = url =&gt; url.indexOf(&#39;?&#39;) &gt; 0 ? url.slice(0, url.indexOf(&#39;?&#39;)) : url; - 获取当前URL下的值返回一个包含当前URL参数的对象。 使用带有适当正则表达式的String.prototype.match（）来获取所有键值对，使用Array.prototype.reduce（）来映射它们并将它们组合成一个对象。 传递location.search作为参数以应用于当前网址。 const getURLParameters = url =&gt; (url.match(/([^?=&amp;]+)(=([^&amp;]*))/g) || []).reduce( (a, v) =&gt; ((a[v.slice(0, v.indexOf(&#39;=&#39;))] = v.slice(v.indexOf(&#39;=&#39;) + 1)), a), {} ); JavaScript api-for in , for of 和 forEachfor infor … in用于迭代对象的所有可枚举属性，包括继承的可枚举属性。 该迭代语句可用于数组字符串或普通对象，但不能用于Map或Set对象。 for (let prop in [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]) console.log(prop); // 0, 1, 2 (array indexes) for (let prop in &#39;str&#39;) console.log(prop); // 0, 1, 2 (string indexes) for (let prop in {a: 1, b: 2, c: 3}) console.log(prop); // a, b, c (object property names) for (let prop in new Set([&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;d&#39;])) console.log(prop); // undefined (no enumerable properties) for offor … of用于迭代可迭代对象，迭代其值而不是其属性。 该迭代语句可用于数组，字符串，Map或Set对象，但不能用于普通对象。 for (let val of [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]) console.log(val); // a, b, c (array values) for (let val of &#39;str&#39;) console.log(val); // s, t, r (string characters) for (let val of {a: 1, b: 2, c: 3}) console.log(prop); // TypeError (not iterable) for (let val of new Set([&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;d&#39;])) console.log(val); // a, b, d (Set values) forEachforEach（）是Array原型的一种方法，它允许您遍历数组的元素。 尽管forEach（）仅迭代数组，但它可以在迭代时访问每个元素的值和索引。 [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].forEach( val =&gt; console.log(val) // a, b, c (array values) ); [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].forEach( (val, i) =&gt; console.log(i) // 0, 1, 2 (array indexes) );","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"}]},{"title":"react常用库","date":"2020-07-19T11:05:06.000Z","path":"2020/07/19/react常用库/","text":"griddle-react react-bootstrap react-cropper core-js Material UI superagent restful-error-es6 browserify react-select-popover 标签选择 react-infinite-scroll 无限滚动 semantic-ui react-date-range日期选择 react-scroll 快速定位滚动 react-timer-mixin suer timer react-autosuggest auto input react-native-swiper轮播 react-split-container分割线拖拽 ,源码已下架? reactjs-iscroll下拉上拉刷新 react-hammerjs触屏事件库 react-emoji-react emoji表情库 react-ace在线编辑器 react-highcharts highchart react-dropzone 上传 react-fileupload-progress文件上传带processor react-fontawesome 字体icon库 react-pdf pdf文档操作 react-desktop桌面UI react-intl Internationalize React apps react-image-gallery图片轮播 react-s-alert alert react-event-calendar事件日历 react-color-picker 颜色选择器 react-lazyload 延迟加载 react-tag-input tag input revalidator格式验证 react-bootstrap-daterangepicker时间范围 react-transitive-number增减数 react-css-transition-replace动画 react-images image list react-clockwall 时间画布 react-autobind fun auto bind react-simple-markdown-editor markdown编辑 react-remarkable markdown 显示 random-gem 随机数 react-masonry-component 瀑布流 react-alap 高德地图 react-baidu-map 百度地图 react-swipeable-views views滑动 react-swipnable-tabs 可横向滚动的tab react-motion 动画 react-image-fallback 图片lazy加载 react-mobile-datepicker 滚动选择时间 react-images 幻灯片灯箱 react-image-magnify 图片细节放大 urlencode node encode编码 react-mobile-datepicker 滚动选择时间 年月日 react-mobile-datetimepicker滚动选择时间 年月日时分 react-fastclick消除touch click 300ms延迟 react-sortable react-anything-sortable 拖动排序 react-autosuggest 自动提示 react-image-crop 图片裁剪 react-device-detect 检测浏览器版本的","tags":[{"name":"npm","slug":"npm","permalink":"https://github.com/NollieLeo/tags/npm/"}]},{"title":"react路由拦截自定义弹框","date":"2020-07-18T07:26:14.000Z","path":"2020/07/18/react路由拦截自定义弹框/","text":"https://medium.com/@michaelchan_13570/using-react-router-v4-prompt-with-custom-modal-component-ca839f5faf39","tags":[{"name":"react-router","slug":"react-router","permalink":"https://github.com/NollieLeo/tags/react-router/"}]},{"title":"一些整合的配置库","date":"2020-07-11T03:05:01.000Z","path":"2020/07/11/一些整合的配置库/","text":"代码规范库umi-fabric 一个包含 prettier，eslint，stylelint 的配置文件合集 github : https://github.com/umijs/fabric lint-staged Lint 就是对代码做静态分析，并试图找出潜在问题的工具，实战中我们也用 Lint 来指使用工具的过程。 npm: https://www.npmjs.com/package/lint-staged husky Husky can prevent bad git commit, git push and more 🐶 woof! npm: https://www.npmjs.com/package/husky","tags":[{"name":"webpack","slug":"webpack","permalink":"https://github.com/NollieLeo/tags/webpack/"},{"name":"gulp","slug":"gulp","permalink":"https://github.com/NollieLeo/tags/gulp/"}]},{"title":"写JS的时候一些小技巧或者常用操作","date":"2020-07-10T16:27:18.000Z","path":"2020/07/11/写JS的时候一些小技巧/","text":"记录一些平时开发过程或者编写JS过程小技巧或者注意事项 关于数组- 变量赋值const array = new Array(); // 一般不这样搞一个数组 const array = []; // 这样搞才棒 - 数组排序 sort是浏览器内置方法 const arr = [1,2,3,4,5]; arr.sort((a,b)=&gt;a-b); arr.sort((a,b)=&gt;b-a); - 数组浅拷贝一般不用一个循环将数组复制一个 const arr = [1,2,3]; //复制 const arrCopy = [ ...arr ] // 直接用拓展运算符 - 多个数组合并const arr1 = [1,2,3,4]; const arr2 = [5,6,7,8]; arr3 = [...arr1,...arr2]; // [1,2,3,4,5,6,7,8]; - 类数组转成数组const fakeArr = [0:&#39;hello&#39;,1:&#39;world&#39;,2:&#39;shit&#39;,length:3]; // bad const arr = Array.prototype.slice.call(arrLike) // good const arr = Array.from(arrLike); - 数组解构const arr = [1, 2, 3, 4] // bad const first = arr[0] const second = arr[1] // good const [first, second] = arr; // 注意不像对象那样是{}符号，而是[] - 替换数组中的特定值const arr = [1,2,3,4,5]; arr.splice(0,2,&quot;hello&quot;,&quot;world&quot;); // 0~2 开始 2除外开始按顺序替换值 // [&#39;hello&#39;,&#39;world&#39;,3,4,5] - Array.from 替换map效果const arr = [ { name:&#39;weng&#39;, age:21, }, { name:&#39;wang&#39;, age:11, }, { name:&#39;sange&#39;, age:41 }, ]; Array.from(arr,({name})=&gt;name); // [&#39;weng&#39;,&#39;wang&#39;,&#39;sange&#39;]; - 数组去重const arr = [1,2,3,4,5,5,6,6,7,7,10,10]; const uniqueArr = Array.from(new Set(arr)); const uniqueArr = [ ...new Set(arr) ]; // good - 二维数组转一维数组const arr = [[1,2,3,4],[5,6,7]]; [].concat.apply(...arr); // [1,2,3,4,5,6,7] 确保在此数组是纯二维数组的情况下 const arr = [[1,2,3,4],[5,6],7]; // 类似这样的不能用以上的方法转一维数组，可以用es6的flat arr.flat(); // [1,2,3,4,5,6,7] - 多维数组转一维数组const arr = [1,2,3,[[4,5],7,6],[0,10,8]]; arr.flat(Infinity); // 这个玩意牛逼 // 当兼容性不好的时候 var arr = [1,[2,3],[4,[5,6,[7]]]] while(arr.some(Array.isArray)){ arr = [].concat(...arr) } // 一招搞定 - 去除数组中的空对象const arr = [{name:1,age:2},{},{}]; const deleteObj=(arr)=&gt;{ if(Array.isArray(arr) &amp;&amp; arr.length&gt;1){ arr.filter(item =&gt; { return Object.keys(item).length&gt;0 }) } return []; } - 数组中的所有值是否都满足条件 如果提供的谓词函数对集合中的所有元素返回true，则返回true，否则返回false。 const all = (arr, fn = Boolean) =&gt; arr.every(fn); all([4,2,3],x=&gt; x&gt;1) // true all([1,2,3],x=&gt;x&gt;1) // false; - 数组中是否有一项满足[1,2,3].some(item =&gt; item &gt;2); - 判断数组中是否存在某个值const arr = [1,2,3,4,5,6]; arr.indexOf(1)!==-1 // true 方法1 arr.includes(1) // true 方法2 arr.find(item =&gt; item === 1); // 返回数组中满足条件的第一个元素的值，如果没有，返回undefined - 返回两个数组不一样的值const difference = (a,b)=&gt; { const s = new Set(b); return a.filter(x=&gt;!s.has(x)); } difference([1,2,3],[3]) // [1,2]; - 数组累加累乘const arr = [1,2,3,4,5,6]; // 累乘 arr.reduce((t,v)=&gt;t*v,1); // t就是总乘积 eval(arr.join(&#39;*&#39;)); // eval会将传进去的string用作js代码执行 // 累加 arr.reduce((t,v)=&gt;t+v,0); eval(arr.join(&#39;+&#39;)); // eval会将传进去的string用作js代码执行 - 将数组转换为对象const arr = [&#39;weng&#39;,&#39;wang&#39;,&#39;zhang&#39;,&#39;li&#39;]; objArr = {...arr}; // {0:&#39;weng&#39;,1:&#39;wang&#39;,2:&#39;zhang&#39;,3:&#39;li&#39;} 关于对象- 对象结构赋值 更推荐使用扩展运算符 …，而不是 Object.assign。解构赋值获取对象指定的几个属性时，推荐用 rest 运算符，也是 …。 const obj = { name:&#39;hello&#39;, age:23, }; // bad const copy = Object.assign({}, obj, { c: 3 }) // copy =&gt; { name: &#39;hello&#39;, age: 23, c: 3 } // so good const objCopy = { ...obj, address:&#39;beijing&#39; }; // objCopy =&gt; {name: &#39;hello&#39;, age: 23,address:&#39;beijing&#39;} // 解构拆分对象得时候 const {address,...restObj} = objCopy; // address = &#39;beijing&#39; resObj ={name:&#39;hello&#39;,age:23,} - 对象属性值的缩写const age = 23; const name = &#39;wengkaimin&#39;; // bad const Obj = { name:name, age:age, } //good const objG = { name, age, } 属性的缩写要放在对象的开头才舒服点 // bad const Obj = { address:&#39;beijing&#39; name, age, } //good const objG = { name, age, address:&#39;beijing&#39; } - 使用动态对象属性创建对象function getName({name}){ return `VIP${name}` } const obj = { age:23, realName:&#39;wengkaimin&#39;, [getName(&#39;xiaohua&#39;)]: true, } clg(obj) // obj=&gt; {age:23,realName:&#39;wengkaimin&#39;,VIPxiaohua:true} - 对象里存在方法时候// bad const obj = { name:&#39;hello world&#39;, getName:function(){ return this.name }, } // goooooood const obj = { name:&#39;hello world&#39;, getName(){ return this.name }, } - 不要直接调用Object原型中的方法 Object.prototype 中的hasOwnProperty，isPrototypeOf等等，不能写出object.hasOwnProperty const objTest = {name:&#39;1&#39;,hasOwnProperty:true}; //bad console.log(objTest.hasOwnProperty(key)) // error 这玩意hasOwnProperty在这个对象中是属性，从原型链最顶层找的话第一层就被找到了，就不会再去找objTest的原型下的hasOwnProperty函数了 // goooood console.log(Object.prototype.hasOwnProperty.call(objTest,name)); // &#39;1&#39; // best const has = Object.prototype.hasOwnProperty // 存起来，这个模块内就可以多次查找,就不需要每次写那么长 console.log(has.call(objTest,name)); /* or */ import has from &#39;has&#39;; // https://www.npmjs.com/package/has console.log(has(object, name)); - 浅拷贝const shallowClone = obj =&gt; Object.assign({},obj);// 上面说了不推荐这样写法 const shallowClone = obj =&gt; {...obj}; - 深拷贝const deepMapKeys = (obj, fn) =&gt; Array.isArray(obj) ? obj.map(val =&gt; deepMapKeys(val, fn)) : typeof obj === &#39;object&#39; ? Object.keys(obj).reduce((acc, current) =&gt; { const key = fn(current); const val = obj[current]; acc[key] = val !== null &amp;&amp; typeof val === &#39;object&#39; ? deepMapKeys(val, fn) : val; return acc; }, {}) : obj; 关于函数- 函数参数使用默认值替代使用条件语句进行赋值。// good function newFun(name = &#39;Jack&#39;) { ... } // bad function newFun(name) { const userNameName = name || &#39;Jack&#39; ... } - 函数参数使用结构语法 函数参数越少越好，如果参数超过两个，要使用 ES6 的解构语法，不用考虑参数的顺序。 // good function createMenu({ title, body, buttonText, cancellable }) { ... } createMenu({ title: &#39;Foo&#39;, body: &#39;Bar&#39;, cancellable: true, buttonText: &#39;Baz&#39;, }) // bad function createMenu(title, body, buttonText, cancellable) { // ... } - 优先使用 rest 语法…，而不是arguments// bad function concatenateAll() { const args = Array.prototype.slice.call(arguments) // arguments是伪数组，处理成数组，这里用上面说的Array.from(arguments)才好 return args.join(&#39;&#39;) } // good function concatenateAll(...args) { return args.join(&#39;&#39;) } - 函数返回值是多个的情况下// 当我们调用函数并将值分配给 a,b,c,d 时，我们需要注意返回数据的顺序。这里的一个小错误可能会成为调试的噩梦,而且倘若只需要c,d值，那么就无法确切获取 const func =()=&gt;{ const a = 1; const b = 2; const c = 3; const d = 4; return [a,b,c,d]; // very bad } const [a,b,c,d] = func(); // 使用对象结构 const func =()=&gt;{ const a = 1; const b = 2; const c = 3; const d = 4; return {a,b,c,d}; // good } const {c,d} = func(); 关于字符串- 字符串翻转function reverseStr(str = &quot;&quot;) { return str.split(&quot;&quot;).reduceRight((t, v) =&gt; t + v); } const str = &quot;reduce123&quot;; console.log(reverseStr(str)); // &quot;321recuder&quot; 关于数字- 判断奇偶数const num=5; !!(num &amp; 1) // true !!(num % 2) // true - 数字千分位// 方法一 function thousandNum(num = 0) { const str = (+num).toString().split(&quot;.&quot;); const int = nums =&gt; nums.split(&quot;&quot;).reverse().reduceRight((t, v, i) =&gt; t + (i % 3 ? v : `${v},`), &quot;&quot;).replace(/^,|,$/g, &quot;&quot;); const dec = nums =&gt; nums.split(&quot;&quot;).reduce((t, v, i) =&gt; t + ((i + 1) % 3 ? v : `${v},`), &quot;&quot;).replace(/^,|,$/g, &quot;&quot;); return str.length &gt; 1 ? `${int(str[0])}.${dec(str[1])}` : int(str[0]); } thousandNum(1234); // &quot;1,234&quot; thousandNum(1234.00); // &quot;1,234&quot; thousandNum(0.1234); // &quot;0.123,4&quot; console.log(thousandNum(1234.5678)); // &quot;1,234.567,8&quot; // 方法二 (121314).toLocaleString(); - 字符串转数字方法一 实际就是用 *1来转化为数字，实际上是调用了.valueOf的方法 &#39;32&#39; * 1 // 32 &#39;ds&#39; * 1 // NaN null * 1 // 0 undefine * 1 // NaN 1 * { valueOf:()=&gt;&#39;3&#39;}; 方法二+ &#39;123&#39; // 123 + &#39;ds&#39; // NaN + &#39;&#39; // 0 + null // 0 + undefine // NaN + {valueOf: ()=&gt;&#39;3&#39;} // 3 - 判断小数是否相等方法1：Number.EPSILON=(function(){ //解决兼容性问题 return Number.EPSILON?Number.EPSILON:Math.pow(2,-52); })(); //上面是一个自调用函数，当JS文件刚加载到内存中，就会去判断并返回一个结果 function numbersequal(a,b){ return Math.abs(a-b)&lt;Number.EPSILON; } //接下来再判断 const a=0.1+0.2, b=0.3; console.log(numbersequal(a,b)); //这里就为true了 方法2：(0.1*100+0.2*100)/100===0.3 - 双位运算符 双位运算符比Math.floor()和Math.ceil()速度快 ~~7.5 // 7 Math.ceil(7.5) // 8 Math.floor(7.5) // 7 ~~-7.5 // -7 Math.floor(-7.5) // -8 Math.ceil(-7.5) // -7 所以负数时，双位运算符和Math.ceil结果一致，正数时和Math.floor结果一致 - 取整和奇偶性判断取整 3.3 | 0 // 3 -3.9 | 0 // -3 parseInt(3.3) // 3 parseInt(-3.3) // -3 // 四舍五入取整 Math.round(3.3) // 3 Math.round(-3.3) // -3 // 向上取整 Math.ceil(3.3) // 4 Math.ceil(-3.3) // -3 // 向下取整 Math.floor(3.3) // 3 Math.floor(-3.3) // -4 判断奇偶 const num=5; !!(num &amp; 1) // true !!(num % 2) // true 布尔型其他非空判断之前写法 if(value !== null &amp;&amp; value !== undefined &amp;&amp; value !== &#39;&#39;){ //... } 现在 if(value??&#39;&#39; !== &#39;&#39;){ //... }","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"}]},{"title":"防抖动和节流","date":"2020-05-03T06:27:27.000Z","path":"2020/05/03/防抖动和节流/","text":"场景： 在页面中很多的事件是会频繁执行的、如： window的resize，scroll事件 拖拽过程中的 mousemove事件 文字输入过程中的keyup等事件 这些事件一旦触发会频繁执行、但是实际上我们可能只需要在特定的时候去执行绑定了这些事件的函数 例如：我需要检测一次拖拉浏览器，移动过程中都算是一次，知道最后鼠标抬起来了，才算是完成了一次拉伸窗口；有比如，我们输入搜索框内的文字的时候，需要发ajax 到后台去请求数据，实际上我们并不需要每一次的输入都发送一个请求，而是在用户已经输完了一整段话或者是几个文字之后再去发送一个ajax，这样会节省很多的资源开销 。等等的这些问题都需要函数防抖动或者函数节流来解决 防抖（debounce）原理： 当我们调用一个动作的时候，会设置在n毫秒后才执行，而在这n毫秒内，如果这个动作再次被调用的话则将重新在计算n毫秒，采取执行这个东西。 当一次事件发生后，事件处理器要等一定阈值的时间，如果这段时间过去后 再也没有 事件发生，就处理最后一次发生的事件。假设还差 0.01 秒就到达指定时间，这时又来了一个事件，那么之前的等待作废，需要重新再等待指定时间。 例如： &lt;body&gt; &lt;style&gt; #container { width: 200px; height: 300px; background-color: aquamarine; } &lt;/style&gt; &lt;div id=&quot;container&quot;&gt; &lt;/div&gt; &lt;script&gt; var count = 1; var containerDom = document.getElementById(&#39;container&#39;); function addNumber() { containerDom.innerHTML = count++; } containerDom.onmousemove = addNumber; &lt;/script&gt; &lt;/body&gt; 鼠标只要移动那么就会频繁的去触发addNumber的函数 这个时候我们对他进行防抖动 先写我们的第一版函数 function debounce(fun, wait) { var time; return function () { clearTimeout(time); time = setTimeout(fun, wait); } } 之后包裹住这个addnumber的函数 现在随你怎么移动，反正你移动完 1000ms 内不再触发，我才执行事件。看看使用效果： 顿时就从 165 次降低成了 1 次! 之后我们对他优化 this指向优化如果我们再addNumber函数中加入console.log(this)，没有再addNumber外层包裹debounce的时候this指向是 &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; 但是包裹了debounce之后this就会指向windows对象 所以需要对它进行修改 var count = 0; var containerDom = document.getElementById(&#39;container&#39;); function addNumber() { containerDom.innerHTML = `&lt;div&gt; 值为${++count} &lt;/div&gt;`; console.log(this); } function debounce(fun, wait) { var time; return function () { var that = this; clearTimeout(time); time = setTimeout(fun.bind(that), wait); } } containerDom.onmousemove = debounce(addNumber, 1000); 但是这里又有一个问题，就是这样包裹debounce的时候，onmousemove自带的事件对象event就会丢失，没有将参数传进去，故我们需要修改一哈，这样再我们需要用到event对象的时候就能拿得到 image-20200503153245577 var count = 0; var containerDom = document.getElementById(&#39;container&#39;); function addNumber(e) { containerDom.innerHTML = `&lt;div&gt; 值为${++count} &lt;/div&gt;`; console.log(this); console.log(e); } function debounce(fun, wait) { var time; return function () { var that = this, args = arguments; clearTimeout(time); time = setTimeout(fn.bind(that, ...args), wait); } } containerDom.onmousemove = debounce(addNumber, 1000); 这个时候我们函数就非常的完善了。 第一次立刻执行假设我需要立即触发这个函数，但是又想防抖，就是相当于先执行函数再N秒内如果再此触发这个函数，就给他重新计算等待值。 function debounce(fun, wait, immediate) { var time; return function () { var that = this, args = arguments; if (time) clearTimeout(time); if (immediate) { // 如果已经执行过，不再执行 var callNow = !time; time = setTimeout(function () { time = null }, wait); if (callNow) fun.apply(that, args); } else { time = setTimeout(function () { fun.apply(that, args); }, wait); } } } 完~ 节流 可以理解为事件在一个管道中传输，加上这个节流阀以后，事件的流速就会减慢。实际上这个函数的作用就是如此，它可以将一个函数的调用频率限制在一定阈值内，例如 1s，那么 1s 内这个函数一定不会被调用两次 以下是一个简版的节流,这里的this和argument处理方式和上面的防抖是一样的处理方式 function throttle(fn, wait) { let prev = new Date(); return function() { const args = arguments; const now = new Date(); if (now - prev &gt; wait) { fn.apply(this, args); prev = new Date(); } } } 按照以上的实现，第一次进入的时候就立马执行事件，但是如果最后一次的时间和pre的时间插值小于我们的wait时间，这时候的函数是不执行的，但是我们想要让它执行，这时候加入定时器，让他在最后一次调用执行函数的时候，算出它距离wait的时间还剩多少，然后让他在剩余时间内再执行； 最终的代码是这样 function throttle(fn, wait) { let prev = new Date(); let time; return function () { const args = arguments; const now = new Date(); clearTimeout(time); if (now - prev &gt;= wait) { fn.apply(this, args); prev = new Date(); } else { time = setTimeout(fn.bind(this, args), wait - (prev - now)); } }; }","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"防抖动","slug":"防抖动","permalink":"https://github.com/NollieLeo/tags/%E9%98%B2%E6%8A%96%E5%8A%A8/"},{"name":"节流","slug":"节流","permalink":"https://github.com/NollieLeo/tags/%E8%8A%82%E6%B5%81/"}]},{"title":"动态创建文本域如何判断文本是否超出所在容器","date":"2020-04-07T13:27:19.000Z","path":"2020/04/07/动态创建文本域如何判断文本是否超出所在容器/","text":"在项目上开发的时候碰到了一个这样的需求 每一个操作记录都是动态创建出来的，包括文本域，后端返回一个content表示文本的内容；每个文本都是定宽的（当然必须在这个容器内部），一旦content数据超出了文本域的定宽就会以省略号的形式表示还有更多文本，并且重点来了：超出的每个模块必须在头部展现出一个button按钮，点击button按钮能够展示更多的数据 下面说一下我刚开始的思路：通过判断content字符的长度去动态渲染这个button（不行）。 因为不仅仅content当中包括了中文字符，英文字符，还包括标点符号数字等等，不能单纯的通过此方法来去判断。 因此想了一下，可以设置一个监听器，通过监听对应的文本，判断它宽度的变化满足什么条件，从而进行页面的二次渲染，再第一次渲染的基础上加上button 经过一个大佬的指导，发现可以用此方法实现 通过new ResizeObserver()的api去监听一个dom元素的文本域变化，详细用法可以看下面这个文章，ResizeObserver是什么？ 还有这 ResizeObserver API 至于为什么要用 scrollWidth 和width来判断，懂得都懂，不懂得去查概念去，scrollWidth, clientWidth, offsetWidth的区别 我用的是react hooks，所以要实现监听，必须再useEffect里面模拟出window.onload 下面说一下我详细得解法： 要控制button得显隐，既然用了react肯定是要面向数据层来改变页面，因此在刚开始获取到这个操作记录的数据的时候，给他每一项加上一个参数叫做display，之后再在所需要渲染的button上手动加上style（这里用的是猪齿鱼pro组件的DataSet） 之后在useEffect当中去监听这些动态渲染的文本域 useEffect(() =&gt; { const flow = document.getElementsByClassName(&#39;c7n-pOverflow&#39;); if (flow &amp;&amp; flow.length &gt; 0) { for (let i = 0; i &lt; flow.length; i += 1) { new ResizeObserver((entries) =&gt; { entries.forEach((entry) =&gt; { const pDom = entry.target; const scrollW = Math.ceil(pDom.scrollWidth); const width = Math.ceil(pDom.clientWidth); if (scrollW &gt; width) { optsDs.records[i].set(&#39;display&#39;, &#39;block&#39;); } }); }).observe(flow[i]); } } }); 注意，useEffect的最后一个参数不能写。 通过循环这个请求到list数据的文本数组，去监听每一个文本域的变化， 通过判定这个文本域的scrollWidth和width去动态地再次改变对应数据中的display属性，就能实现页面的二次渲染。 if (scrollW &gt; width) { optsDs.records[i].set(&#39;display&#39;, &#39;block&#39;); } 这是文本域的样式 p { font-size: .12rem; font-weight: 400; margin: .08rem 0 0 0; color: rgba(58, 52, 95, 0.65); line-height: .2rem; max-width: 4.09rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } 这里一定是要设置宽度的，无论是width还是max-width只要能实现它超出溢出就行。","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"react hooks","slug":"react-hooks","permalink":"https://github.com/NollieLeo/tags/react-hooks/"},{"name":"useEffect","slug":"useEffect","permalink":"https://github.com/NollieLeo/tags/useEffect/"}]},{"title":"JS中typeof和instanceof的区别","date":"2020-03-31T01:29:49.000Z","path":"2020/03/31/JS中typeof和instanceof的区别/","text":"undefined, number, string, boolean属于简单的值类型，不是对象。剩下的几种情况——函数、数组、对象、null、new Number(10)都是对象。他们都是引用类型。 基本数据类型和引用类型 typeofconsole.log(typeof (x)); // &#39;undefined&#39; console.log(typeof (10)); // &#39;number&#39; console.log(typeof (&#39;abc&#39;)); // &#39;string&#39; console.log(typeof (true)); // &#39;boolean&#39; console.log(typeof (function () { })); // &#39;function&#39; console.log(typeof ([1, &#39;dsa&#39;, true])); // &#39;object&#39; console.log(typeof ({ a: 123, b: true })); // &#39;object&#39; console.log(typeof (null)); // &#39;object&#39; console.log(typeof (new Number(0))); // &#39;object&#39; console.log(typeof(new Date())); // &#39;object&#39; console.log(typeof(/a/g)); // &#39;object&#39; 我们可以用typeof判断一个变量是否存在 if(typeof a !==&#39;undefined&#39;){ alert(&#39;OK&#39;) } 而不是if(a)这样的用法，因为如果这样a为定义就会报错。 简单的值类型直接用typeof就能够判断出来 但是引用类型使用 typeof 判断就不太准确。如上代码所示，例如数组，正则表达式，日期，对象等typeof返回值都是为 object 函数的返回值则是function 在 JavaScript 中，判断一个变量的类型尝尝会用 typeof 运算符，在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 “object”。这就需要用到instanceof来检测某个对象是不是另一个对象的实例。 instanceof语法：object instanceof constructor 参数：object（要检测的对象.）constructor（某个构造函数） 描述：instanceof运算符用来检测constructor.prototype是否存在于参数object的原型链上 对象与函数的关系： 函数是一种对象，但函数不像数组正则日期这些对象。其他的对象（函数除外）都是对象的一个子集，但是函数却可以创造出对象来 function People(){ this.name = &#39;hello world&#39;; this.birth - 1998; } var people = new People(); people这个对象是由People的构造函数创建出来的， instanceof的使用规则：A instanceof B A沿着proto这条线来找，同时B沿着prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。 例如： 可以用于判断一个变量是否是某个对象的实例console.log(people instanceof People); // true console.log(people instanceof Object); // true 因为people是由 People构造函数搞出来的，而People又是object的子类 可以在继承关系中用来判断一个实例是否属于它的父类型例如： function People() { this.name = &#39;hello world&#39;; this.birth = 1998; } function Male(){} Male.prototype = new People(); const man = new Male(); console.log(man instanceof Male); // true console.log(man instanceof People); // true 又如： // 定义构造函数 function C(){} function D(){} var o = new C(); // true，因为 Object.getPrototypeOf(o) === C.prototype o instanceof C; // false，因为 D.prototype不在o的原型链上 o instanceof D; o instanceof Object; // true,因为Object.prototype.isPrototypeOf(o)返回true C.prototype instanceof Object // true,同上 C.prototype = {}; var o2 = new C(); o2 instanceof C; // true o instanceof C; // false,C.prototype指向了一个空对象,这个空对象不在o的原型链上. D.prototype = new C(); // 继承 var o3 = new D(); o3 instanceof D; // true o3 instanceof C; // true 需要注意的是，如果表达式 obj instanceof Foo 返回true，则并不意味着该表达式会永远返回true，因为Foo.prototype属性的值有可能会改变，改变之后的值很有可能不存在于obj的原型链上，这时原表达式的值就会成为false。另外一种情况下，原表达式的值也会改变，就是改变对象obj的原型链的情况，虽然在目前的ES规范中，我们只能读取对象的原型而不能改变它，但借助于非标准的__proto__魔法属性，是可以实现的。比如执行obj.__proto__ = {}之后，obj instanceof Foo就会返回false了。 function People(){ this.name = &#39;hello&#39; } const a = new People(); console.log(a instanceof People); // true a.__proto__ = {}; console.log(a instanceof People); // false","tags":[{"name":"ES6","slug":"ES6","permalink":"https://github.com/NollieLeo/tags/ES6/"},{"name":"基本数据类型和引用类型","slug":"基本数据类型和引用类型","permalink":"https://github.com/NollieLeo/tags/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"}]},{"title":"实现边框loading动画效果","date":"2020-03-30T05:44:04.000Z","path":"2020/03/30/实现边框loading动画效果/","text":"效果图如下 代码如下： &lt;body&gt; &lt;style&gt; .box { display: inline-block; position: relative; width: 220px; height: 100px; box-sizing: border-box; } .box::before { content: &#39;&#39;; position: absolute; left: -4px; top: -4px; right: 0; width: 228px; height: 108px; bottom: 0; z-index: -1; box-sizing: border-box; border-radius: 5px; background: linear-gradient(to right, #0638a8, #0ab7f9, #06a892); box-sizing: border-box; animation: borderAround 1.5s infinite linear; } @keyframes borderAround { 0%, 100% { clip: rect(0 228px 4px 76px); } 10% { clip: rect(0, 152px, 4px, 0); } 20% { clip: rect(0, 76px, 54px, 0); } 30% { clip: rect(0, 4px, 112px, 0); } 40% { clip: rect(54px, 76px, 112px, 0); } 50% { clip: rect(104px, 152px, 112px, 0); } 60% { clip: rect(104px, 228px, 112px, 76px); } 70% { clip: rect(54px, 228px, 112px, 152px); } 80% { clip: rect(0, 228px, 112px, 224px); } 90% { clip: rect(0, 228px, 54px, 152px); } } .child { width: 100%; height: 100%; background: #FFF; z-index: 999; } &lt;/style&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;child&quot;&gt; dsadasd &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;","tags":[{"name":"css","slug":"css","permalink":"https://github.com/NollieLeo/tags/css/"},{"name":"loading动画","slug":"loading动画","permalink":"https://github.com/NollieLeo/tags/loading%E5%8A%A8%E7%94%BB/"}]},{"title":"垂直居中的几种方式","date":"2020-03-26T02:09:04.000Z","path":"2020/03/26/垂直居中的几种方式/","text":"在阅读此文章之前要搞明白行内元素和块级元素的区别，和其常用的标签 行内元素和块级元素 行内元素垂直居中1. 设置外层块元素的height，line-height为相同的值适用范围：作用于单行为文字，使文字垂直居中显示 原理：line-height与font-size的计算之差（在css中成为“行间距”）分为两半，分别加到一个文本行内容的顶部和底部。（可以包含这些内容的最小框就是行框）实现了单行文字居中，代码如下： &lt;body&gt; &lt;style&gt; .container { height: 50px; line-height: 50px; background:aqua; } .content { background-color: bisque; } &lt;/style&gt; &lt;div class=&quot;container&quot;&gt; &lt;span class=&quot;content&quot;&gt;垂直居中&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; 2. vertical-align适用范围：外层块元素包含大于一个行内元素需要垂直居中时 （如图片和文字需要垂直居中显示时），可以通过对图片的标签或文字的标签（行内元素）设置vertical-align，可以达到效果； 特点： 父级块元素不需要设置宽高 只需将基线较高的行内元素设置vertial-align就行 vertical-align属性的定义：该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。允许指定负长度值和百分比值。这会使元素降低而不是升高。在表单元格中，这个属性会设置单元格框中的单元格内容的对齐方式。 &lt;body&gt; &lt;style&gt; .container { background: aqua; } .content { background-color: bisque; } img { vertical-align: middle; } &lt;/style&gt; &lt;div class=&quot;container&quot;&gt; &lt;span class=&quot;content&quot;&gt;垂直居中&lt;/span&gt; &lt;img src=&quot;https://www.baidu.com/img/bd_logo1.png&quot; /&gt; &lt;/div&gt; &lt;/body&gt; 3. 外层父元素display: table-cell;vertical-align: middle特点： 外层元素需要设置高度 适用范围： 适用于在块元素内存在单个行内块元素，将它垂直居中； &lt;body&gt; &lt;style&gt; .container { background: aqua; height: 300px; display: table-cell; vertical-align: middle; } &lt;/style&gt; &lt;div class=&quot;container&quot;&gt; &lt;img src=&quot;https://www.baidu.com/img/bd_logo1.png&quot; /&gt; &lt;/div&gt; &lt;/body&gt; 4. display:flex; align-items:center特点： flex布局 父元素可以不设置高度，宽度由内部行内元素撑起（这里设置高度是为了看的更清楚） &lt;body&gt; &lt;style&gt; .container { height: 300px; background: aqua; display: flex; align-items: center; } img { max-width: 300px; } &lt;/style&gt; &lt;div class=&quot;container&quot;&gt; &lt;span&gt;12111111111111111111111111111111111111111111111111eeeeeeeeeeee1111111dwaedwqqqqqqqqqqqqqqqqq&lt;/span&gt; &lt;img src=&quot;https://www.baidu.com/img/bd_logo1.png&quot; /&gt; &lt;/div&gt; &lt;/body&gt; 5. 绝对定位+负外边距；适用范围：包裹的行内元素必须是可以设置高度的，但是像文本元素是不建议使用这个的，因为文本的内容不确定，除非定高且设置超出溢出 &lt;body&gt; &lt;style&gt; .container { height: 300px; background: aqua; position: relative; } img { height: 200px; margin-top: -100px; top: 50%; position: absolute; } &lt;/style&gt; &lt;div class=&quot;container&quot;&gt; &lt;img src=&quot;https://www.baidu.com/img/bd_logo1.png&quot; /&gt; &lt;/div&gt; &lt;/body&gt; 块级元素垂直居中类似，不解释 多行文本垂直居中利用 display：table；和display:table-cell; 来实现多行文本的垂直居中 &lt;body&gt; &lt;style&gt; .container { height: 300px; background: aqua; display: table; } p { display: table-cell; vertical-align: middle; background-color: bisque; } &lt;/style&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt; dsadwqdssacadseqdsfcdsfsasddsa dwqdssacadseqdsfcdsfsasddsadwqd ssacadseqdsfcdsfsasddsadwqdssaca dseqdsfcdsfsasddsadwqdssacadseqds fcdsfsasddsadwqdssacadseqdsfcdsfsasd &lt;/p&gt; &lt;/div&gt; &lt;/body&gt; 未知元素的宽高情况在前面的实现行内元素的垂直居中中有提到几种方法 1. 组合使用display：table-cell和vertical-align、text-align，使父元素内的所有行内元素水平垂直居中（内部div设置display：inline-block即可）这在子元素不确定宽度和高度时 与其他一些display属性类似，table-cell同样会被其他一些css属性破坏，例如float，position：absolute，所以在使用display：table-cell时，尽量不要使用float或者position:absolute（可以考虑为之增加一个父div定义float等属性。）；设置了table-cell的元素对宽度和高度敏感（在父元素上设置table-row等属性，也会使其不感知height。），对margin值无反应，响应padding属性 &lt;body&gt; &lt;style&gt; .father { width: 400px; height: 200px; border: 1px solid #000; display: table-cell; text-align: center; vertical-align: middle; } .son { width: 200px; height: 100px; background: red; display: inline-block; } &lt;/style&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt; display:table-cell;&lt;/br&gt;text-align:center;&lt;/br&gt; vertical-align:middle &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 对table-cell元素设置百分比（如100%）的宽高值是无效的，但是可以将元素设置display:table，再将父元素设置百分比跨高，子元素table-cell会自动撑满父元素。这就可以做相对于整个页面的水平垂直居中。嗯，看下面的代码 &lt;body&gt; &lt;style&gt; html, body { height: 100%; margin: 0; padding: 0; } #box { display: table; width: 100%; height: 100%; } .father { width: 400px; height: 200px; border: 1px solid #000; display: table-cell; text-align: center; vertical-align: middle; } .son { width: 200px; height: 100px; background: red; display: inline-block; } &lt;/style&gt; &lt;div id=&quot;box&quot;&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt; display:table-cell;&lt;/br&gt;text-align:center;&lt;/br&gt; vertical-align:middle &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 2. display:flex的方法参考上面所说的行内元素的方法 设置container的display的类型为flex，激活为flexbox模式。 justify-content定义水平方向的元素位置 align-items定义垂直方向的元素位置 3. display:inline-block +伪元素生成content内容实现原理：原理：利用inline-block的vertical-align: middle去对齐before伪元素，before伪元素的高度与父对象一样，就实现了高度方向的对齐。居中块的尺寸可以做包裹性、自适应内容，兼容性也相当好。缺点是水平居中需要考虑inline-block间隔中的留白（代码换行符遗留问题。）。（宽度是已知的，高度可以是未知的） (这里子元素加了宽高是为了方便看，去掉也无所谓) &lt;body&gt; &lt;style&gt; .father { width: 400px; height: 200px; border: 1px solid #000; text-align: center; } .father:before { content: &quot; &quot;; display: inline-block; vertical-align: middle; height: 100%; } .son { width: 200px; height: 100px; background: red; display: inline-block; vertical-align: middle; } &lt;/style&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt; display:inline-block;&lt;/br&gt;伪元素生成content内容&lt;/br&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 4. 绝对定位+transform反向偏移。position:absolute; transform:translate(-50%,-50%); 原理很简单：由于top、left偏移了父对象的50%宽度高度，所以需要利用transform反向偏移居中块的50%宽高 transform的计算基准是元素本身，所以这里可以用50%来做反向偏移 (这里子元素加了宽高是为了方便看，去掉也无所谓) &lt;body&gt; &lt;style&gt; .father { width: 400px; height: 200px; border: 1px solid #000; position: relative; } .son { width: 200px; height: 100px; background: red; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } &lt;/style&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt; position:absolute;&lt;/br&gt;left:50%;top:50%;&lt;/br&gt;transform &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 知道元素宽高的情况下1.绝对定位相对定位（ 绝对定位+margin：auto；position:absolute; left:0; top:0; right:0; bottom:0; margin:auto）一个条件都不能少 &lt;body&gt; &lt;style&gt; .father { width: 400px; height: 200px; position: relative; border: 1px solid #000; } .son { width: 200px; height: 100px; background: red; position: absolute; left: 0; top: 0; bottom: 0; right: 0; margin: auto; } &lt;/style&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt; position:absolute;&lt;/br&gt; left:0; top:0;&lt;/br&gt; right:0; bottom:0; &lt;/br&gt;margin:auto &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 原理： 当一个绝对定位元素，其对立定位方向属性同时有具体定位数值的时候，流体特性就发生了。 具有流体特性绝对定位元素的margin:auto的填充规则和普通流体元素一模一样： 如果一侧定值，一侧auto，auto为剩余空间大小；如果两侧均是auto, 则平分剩余空间；例如，下面的CSS代码： .father { width: 300px; height:150px; position: relative; } .son { position: absolute; top: 0; right: 0; bottom: 0; left: 0; } 如图所示流体元素会布满整个父元素，此时.son这个元素的尺寸表现为“格式化宽度和格式化高度”，和的“正常流宽度”一样，同属于外部尺寸，也就是尺寸自动填充父级元素的可用尺寸的 然后，此时我们给.son设置尺寸，例如 .son { position: absolute; top: 0; right: 0; bottom: 0; left: 0; width: 200px; height: 100px; } 此时宽高被限制，原本应该填充的空间就被多余了出来，这多余的空间就是margin:auto计算的空间，因此，如果这时候，我们再设置一个margin:auto，那么： .son { position: absolute; top: 0; right: 0; bottom: 0; left: 0; width: 200px; height: 100px; margin: auto; } 我们这个.son元素就水平和垂直方向同时居中了 2. 绝对定位+margin反向偏移在上面的行内块元素种有提及到 position：absolute; top:50%; left:50%; margin-left:-(width+padding)/2+&#39;px&#39;; margin-top:-(height+padding)/2+&#39;px&#39;; margin值的设置不能使用百分比，因为margin是基于父元素的宽度来计算百分比的 这个原理和上面的方案4很相似，由于top、left偏移了父对象的50%宽度高度，所以需要利用margin反向偏移居中块的50%宽高","tags":[{"name":"css","slug":"css","permalink":"https://github.com/NollieLeo/tags/css/"},{"name":"垂直居中","slug":"垂直居中","permalink":"https://github.com/NollieLeo/tags/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"}]},{"title":"块级元素，行内元素和行内块元素","date":"2020-03-26T01:00:44.000Z","path":"2020/03/26/块级元素，行内元素和行内块元素/","text":"块级元素每个块级元素都是独占一行或者多行，可以对其单独设置高度，宽度以及对齐等属性 块级元素有div、p、table，nav、aside、header、footer、section、article、ul，li、 ~ ，address等。 块级元素的特点 块级元素会独占一行B 高度，行高，外边距和内边距都可以单独设置 宽度默认是容器的100% 可以容纳内联元素和其他块级元素 行内元素行内元素（内联元素）不占有独立的区域，仅仅依靠自己的字体大小或者是图像大小来支撑结构，一般不可以设置宽度，高度以及对齐等属性 常见的行内元素有：,,,,,等 行内元素的特点： 和相邻的行内元素在同一行上 高度宽度上无效，但是水平方向上的padding和margin可以设置，垂直方向上无效 默认的宽度就是它本身的宽度 行内元素只能容纳纯文本或者是其他的行类元素，除了（a标签） notes： 只有文字才能组成段落，因此类似,~,等都是文字块级标签，所以里面不能放块级元素 链接里面不能再存放链接 行内块元素 常见的有：, , 可以设置他们的宽高度和对齐的属性 行内块元素的特点： 和相邻的行内元素（行内块）再一行上，但是中间会有空白的间隙 默认的宽度就是本身内容的宽度 高度，行高，内边距和外边距都可以设置 显示模式的转换块转行内：display:inline 行内转块：display:block 块，行内元素转换为行内块：display:inline-block","tags":[{"name":"html","slug":"html","permalink":"https://github.com/NollieLeo/tags/html/"}]},{"title":"浏览器的渲染机制","date":"2020-03-25T04:40:54.000Z","path":"2020/03/25/浏览器的渲染机制/","text":"浏览器的渲染过程*面试题：在浏览器地址栏里输入一个URL,到这个页面呈现出来，中间会发生什么？ 目前市面上常见的浏览器内核可以分为这四种：Trident（IE）、Gecko（火狐）、Blink（Chrome、Opera）、Webkit（Safari）。这里面大家最耳熟能详的可能就是 Webkit 内核了，Webkit 内核是当下浏览器世界真正的霸主。本文我们就以 Webkit 为例，对现代浏览器的渲染过程进行一个深度的剖析。 1. 页面加载的过程首先需要找到这个URL域名的服务器IP 寻找缓存， 查看缓存中是否有记录（浏览器缓存 -&gt; 系统缓存 -&gt; 路由器缓存 ），缓存中没则去查找系统的hosts文件记录，如果再没有就去查询DNS服务器。 浏览器会根据DNS服务器得到域名的IP地址 根据这个IP 以及相应的端口号 构建一个HTTP请求，并将这个HTTP请求封装在一个TCP包中，发送给服务器（依次经过传输层，网络层，数据链路层，物理层，服务器） 服务器收到这个包并且解析这个http请求返回相应的HTML给浏览器 其实就是一堆 HMTL 格式的字符串，因为只有 HTML 格式浏览器才能正确解析，这是 W3C 标准的要求。接下来就是浏览器的渲染过程。 2. 浏览器的渲染过程 1） 浏览器会解析三个东西 HTML/SVG/XHML，HTML字符串描述了一个页面的结构，浏览器会把HTML结构字符串解析转换DOM树形结构（DOM的构建）（在dom树的构建过程中如果遇到JS脚本和外部JS连接，则会停止构建DOM树来执行和下载相应的代码，造成阻塞，后面会说到）。 CSS，解析CSS产生CSS rule tree，和他DOM树的结构比较像 JS脚本，等到JS脚本文件加载完成之后，通过DOM API和CSSOM API来操作DOM tree和CSS rule tree 2）解析完成，浏览器引擎会通过DOM tree和css Rule Tree来构造Rendering Tree。 Rendering Tree 渲染树并不等同于DOM树，渲染树只会包括需要显示的节点和这些节点的样式信息 （这里主要做的是排除非视觉节点，比如script，meta标签和排除display为none的节点） CSS的rule tree主要是为了完成匹配并且把CSS rule附加上Rendering tree上的每一个Element（也就是每一个Frame） 然后计算每个Frame的位置，得到节点的几何信息（位置，大小），这个又叫做回流（layout） 根据渲染树以及回流得到的几何信息，得到节点的绝对像素，这个过程叫做重绘（painting） display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层 3）最后通过调用操作系统Native GUI的api绘制 接下来叙述一些详细步骤 构建DOM树 浏览器会遵守一套步骤将HTML 文件转换为 DOM 树。宏观上，可以分为几个步骤： 浏览器从磁盘或网络读取HTML的原始字节，并且根据文件的指定编码（例：UTF-8）来将他们转换成字符串。（网络中传输的内容其实都是0 1这些字节数据。当浏览器收到这些字节数据以后，会将他们转成字符串，也就是我们写的代码） 将字符串转换成TOKEN，例如：&lt; html &gt;,&lt; body &gt;等。Token中会自动标识出当前Token是“开始标签”还是“结束标签”或者是“文本”等信息。 生成节点对象并且构建DOM。（ 构建DOM的过程中，不是等所有Token都转换完成后再去生成节点对象，而是一边生成Token一边消耗Token来生成节点对象。换句话说，每个Token被生成后，会立刻消耗这个Token创建出节点对象。注意：带有结束标签标识的Token不会创建节点对象。 ） 构建CSSOMDOM会捕获页面的内容，但浏览器还需要知道页面如何展示，所以需要构建CSSOM。 构建CSSOM的过程与构建DOM的过程非常相似，当浏览器接收到一段CSS，浏览器首先要做的是识别出Token，然后构建节点并生成CSSOM。 在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。 注意：CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去。 构建渲染树 当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。 在这一过程中，不是简单的将两者合并就行了。为了构建渲染树，浏览器主要完成了以下工作： 从DOM树的根节点开始遍历每个可见节点。 对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。 根据每个可见节点以及其对应的样式，组合生成渲染树。 第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括： 一些不会渲染输出的节点，比如script、meta、link等。 一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。 注意：渲染树只包含可见的节点 回流和重绘在另一篇文章（包含了渲染性能的优化策略等） 一些疑问渲染过程中碰到JS文件应该如何处理？渲染过程中如果遇到了标签就停止渲染，执行JS代码。因为浏览器有GUI渲染线程和JS引擎线程，为了防止渲染出现不可预期的结果，这两个线程是互斥的关系，JS的加载，解析和执行会阻塞DOM的构建，也就是说，在构建DOM的时候,HTML解析器遇到了JS，那么会暂停构建DOM，将控制权移交给JS引擎，等JS引擎运行完毕，浏览器再从中断的地方恢复DOM构建。 也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性（下文会介绍这两者的区别） JS文件不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建。 原本DOM和CSSOM的构建是互不影响，井水不犯河水，但是一旦引入了JavaScript，CSSOM也开始阻塞DOM的构建，只有CSSOM构建完毕后，DOM再恢复DOM构建。 这是什么情况？ 这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。因为不完整的CSSOM是无法使用的，如果JavaScript想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成CSSOM的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM。","tags":[{"name":"浏览器相关","slug":"浏览器相关","permalink":"https://github.com/NollieLeo/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/"}]},{"title":"画一条0.5px的边","date":"2020-03-25T02:20:15.000Z","path":"2020/03/25/画一条0-5px的边/","text":"什么是像素？ 像素是屏幕显示最小的单位，在一个1080p的屏幕上，它的像素数量是1920 1080，即横边有1920个像素，而竖边为1080个。一个像素就是一个单位色块，是由rgba四个通道混合而成。对于一个1200万像素的相机镜头来说，它有1200万个感光单元，它能输出的最大图片分辨率大约为3000 4000。 那么像素本身有大小吗，一个像素有多大？ 有的，如果一个像素越小，那么在同样大小的屏幕上，需要的像素点就越多，像素就越密集，如果一英寸有435个像素，那么它的dpi/ppi就达到了435。Macbook Pro 15寸的分辨率为2880 x 1800，15寸是指屏幕的对角线为15寸（具体为15.4），根据长宽比换算一下得到横边为13寸，所以ppi为2880 / 13 = 220 ppi. 像素越密集即ppi(pixel per inch)越高，那么屏幕看起来就越细腻越高清。 怎么在高清屏上画一条0.5px的边呢？0.5px相当于高清屏物理像素的1px。这样的目的是在高清屏上看起来会更细一点，效果会更好一点，例如更细的分隔线。 理论上px的最小单位是1，但是会有几个特例，高清屏的显示就是一个特例。高清屏确实可以画0.5px，对比效果如下： 猜想方法如下： 1. 直接设置如果我们直接设置0.5px，在不同的浏览器会有不同的表现，使用如下代码： &lt;body&gt; &lt;style&gt; div{ width: 300px; background: #000; } .half-px { height: .5px; } .one-px { height: 1px; } &lt;/style&gt; &lt;p&gt;0.5px&lt;/p&gt; &lt;div class=&quot;half-px&quot;&gt;&lt;/div&gt; &lt;p&gt;1px&lt;/p&gt; &lt;div class=&quot;one-px&quot;&gt;&lt;/div&gt; &lt;/body&gt; 在PC上的不同浏览器上测试测试结果如下所示： 其中Chrome把0.5px四舍五入变成了1px，而firefox/safari能够画出半个像素的边，并且Chrome会把小于0.5px的当成0，而Firefox会把不小于0.55px当成1px，Safari是把不小于0.75px当成1px，进一步在手机上观察iOS的Chrome会画出0.5px的边，而安卓(5.0)原生浏览器是不行的。所以直接设置0.5px不同浏览器的差异比较大，并且我们看到不同系统的不同浏览器对小数点的px有不同的处理。所以如果我们把单位设置成小数的px包括宽高等，其实不太可靠，因为不同浏览器表现不一样。 2. 缩放scale 0.5&lt;body&gt; &lt;style&gt; div{ width: 300px; background: #000; } .half-px { height: 1px; transform: scaleY(.5); } .one-px { height: 1px; } &lt;/style&gt; &lt;p&gt;1px + scaleY(.5)&lt;/p&gt; &lt;div class=&quot;half-px&quot;&gt;&lt;/div&gt; &lt;p&gt;1px&lt;/p&gt; &lt;div class=&quot;one-px&quot;&gt;&lt;/div&gt; &lt;/body&gt; 效果图如下： 我们发现Chrome/Safari都变虚了，只有Firefox比较完美看起来是实的而且还很细，效果和直接设置0.5px一样。所以通过transform: scale会导致Chrome变虚了，而粗细几乎没有变化，所以这个效果不好。 我们还想到做移动端的时候还使用了rem做缩放，但实际上rem的缩放最后还是会转化成px，所以和直接使用0.5px的方案是一样的 3. 线性渐变linear-gradient&lt;body&gt; &lt;style&gt; .hr { width: 300px; height: 1px; background-color: #000; } .hr.gradient { height: 1px; background: linear-gradient(0deg, #fff, #000); } &lt;/style&gt; &lt;p&gt;linear-gradient(0deg, #fff, #000)&lt;/p&gt; &lt;div class=&quot;hr gradient&quot;&gt;&lt;/div&gt; &lt;p&gt;1px&lt;/p&gt; &lt;div class=&quot;hr&quot;&gt;&lt;/div&gt; &lt;/body&gt; linear-gradient(0deg, #fff, #000)的意思是：渐变的角度从下往上，从白色#fff渐变到黑色#000，而且是线性的，在高清屏上，1px的逻辑像素代表的物理（设备）像素有2px，由于是线性渐变，所以第1个px只能是#fff，而剩下的那个像素只能是#000，这样就达到了画一半的目的。逻辑分析很完美，实际的效果又怎么样呢，如下图所示： 我们发现这种方法在各个流览器上面都不完美，效果都是虚的，和完美的0.5px还是有差距。这个效果和scale 0.5的差不多，都是通过虚化线，让人觉得变细了。 4. box-shadow&lt;body&gt; &lt;style&gt; .hr { width: 300px; height: 1px; background-color: #000; } .hr.boxShadow { height: 1px; background: none; box-shadow: 0 0.5px 0 #000; } &lt;/style&gt; &lt;p&gt;boxShadow&lt;/p&gt; &lt;div class=&quot;hr boxShadow&quot;&gt;&lt;/div&gt; &lt;p&gt;1px&lt;/p&gt; &lt;div class=&quot;hr&quot;&gt;&lt;/div&gt; &lt;/body&gt; 设置box-shadow的第二个参数为0.5px，表示阴影垂直方向的偏移为0.5px，效果如下： 这个方法在Chrome和Firefox都非常完美，但是Safari不支持小于1px的boxshadow，所以完全没显示出来了。不过至少找到了一种方法能够让PC的Chrome显示0.5px。 5. 设置viewport的scale 在移端开发里面一般会把viewport的scale设置成 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-sacle=1&quot;&gt; 其中width=device-width表示将viewport视窗的宽度调整为设备的宽度，这个宽度通常是指物理上宽度。默认的缩放比例为1，如iphone 6竖屏的宽度为750px，它的dpr=2，用2px表示1px，这样设置之后viewport的宽度就变成375px。这时候0.5px的边就使用我们上面讨论的方法。 但是你可以把scale改成0.5： &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-sacle=0.5&quot;&gt; 这样的话，viewport的宽度就是原本的750px，所以1个px还是1px，正常画就行，但这样也意味着UI需要按2倍图的出，整体面面的单位都会放大一倍。 在iPhone X和一些安卓手机等dpr = 3的设备上，需要设置scale为0.333333，这个时候就是3倍地画了。 综上讨论了像素和viewport的一些概念，并介绍和比较了在高清屏上画0.5px的几种方法——可以通过直接设置宽高border为0.5px、设置box-shadow的垂直方向的偏移量为0.5px、借助线性渐变linear-gradient、使用transform: scaleY(0.5)的方法","tags":[{"name":"css","slug":"css","permalink":"https://github.com/NollieLeo/tags/css/"},{"name":"html","slug":"html","permalink":"https://github.com/NollieLeo/tags/html/"}]},{"title":"CSS盒子模型","date":"2020-03-25T01:22:07.000Z","path":"2020/03/25/CSS盒子模型/","text":"css盒子模型先看例子： &lt;style&gt; div { width: 300px; height: 400px; border: 5px solid #ccc; background-color: aqua; padding: 20px; } &lt;/style&gt; &lt;div&gt;&lt;/div&gt; 如图所示：设置一个宽300px,高400px的div，border为5px，padding值设为20px. 这里我们会发现明明我们设置了300*400长宽比，为什么呈现出来的是一个350*450的盒子呢？ 我们可以看一下这个图： 在这张图中，我们发现我们设置的300*400出现在了最里面的那个蓝框中，与此同时我们可以发现在这个盒模型中除了我们设置的内容（content），还有margin（外边距）、border（边框）、padding（内边框） margin(外边距) - 清除边框外的区域，外边距是透明的。border(边框) - 围绕在内边距和内容外的边框。padding(内边距) - 清除内容周围的区域，内边距是透明的。content(内容) - 盒子的内容，显示文本和图像。 为了正确设置元素在所有浏览器中的宽度和高度，你需要知道盒模型是如何工作的。 而我们在测试效果图看到的350*450盒子， 350（width） = 300（content） + 20（padding）* 2 + 5（border）* 2450（height）= 400 （content）+ 20（padding）* 2 + 5（border）* 2 css的两种盒子模型css的两种盒子模型不同 W3C的标准盒模型 在标准的盒子模型中，width指content部分的宽度 IE的盒模型 在IE盒子模型中，width表示content+padding+border这三个部分的宽度 我们可以看出我们上面的使用的默认正是W3C标准盒模型 盒子模型类型的切换如果想要切换盒模型也很简单，这里需要借助css3的box-sizing属性 box-sizing: content-box 是W3C盒子模型 box-sizing: border-box 是IE盒子模型 box-sizing的默认属性是content-box","tags":[{"name":"css","slug":"css","permalink":"https://github.com/NollieLeo/tags/css/"},{"name":"盒子模型","slug":"盒子模型","permalink":"https://github.com/NollieLeo/tags/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"}]},{"title":"回流和重绘(重排)","date":"2020-03-24T02:12:58.000Z","path":"2020/03/24/回流和重绘-重排/","text":"回流和重绘 浏览器渲染机制","tags":[{"name":"回流和重绘","slug":"回流和重绘","permalink":"https://github.com/NollieLeo/tags/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/"},{"name":"浏览器的渲染机制","slug":"浏览器的渲染机制","permalink":"https://github.com/NollieLeo/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"}]},{"title":"如何画一个三角形","date":"2020-03-23T03:04:07.000Z","path":"2020/03/23/如何画一个三角形/","text":"用css如何画一个三角形？&lt;style&gt; div { width: 0; height: 0; border-top: 10px solid green; border-bottom: 10px solid transparent; border-left: 10px solid transparent; border-right: 10px solid transparent; } &lt;/style&gt; &lt;div/&gt; 三角形原理：边框的均分原理","tags":[{"name":"css","slug":"css","permalink":"https://github.com/NollieLeo/tags/css/"}]},{"title":"HTTP常用请求头","date":"2020-03-23T02:50:27.000Z","path":"2020/03/23/HTTP常用请求头/","text":"常用请求头 协议头 说明 Accept 可接受的响应内容类型（Content-Types）。 Accept-Charset 可接受的字符集 Accept-Encoding 可接受的响应内容的编码方式。 Accept-Language 可接受的响应内容语言列表。 Accept-Datetime 可接受的按照时间来表示的响应内容版本 Authorization 用于表示HTTP协议中需要认证资源的认证信息 Cache-Control 用来指定当前的请求/回复中的，是否使用缓存机制。 Connection 客户端（浏览器）想要优先使用的连接类型 Cookie 由之前服务器通过Set-Cookie（见下文）设置的一个HTTP协议Cookie Content-Length 以8进制表示的请求体的长度 Content-MD5 请求体的内容的二进制 MD5 散列值（数字签名），以 Base64 编码的结果 Content-Type 请求体的MIME类型 （用于POST和PUT请求中） Date 发送该消息的日期和时间（以RFC 7231中定义的”HTTP日期”格式来发送） Expect 表示客户端要求服务器做出特定的行为 From 发起此请求的用户的邮件地址 Host 表示服务器的域名以及服务器所监听的端口号。如果所请求的端口是对应的服务的标准端口（80），则端口号可以省略。 If-Match 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要用于像 PUT 这样的方法中，仅当从用户上次更新某个资源后，该资源未被修改的情况下，才更新该资源。 If-Modified-Since 允许在对应的资源未被修改的情况下返回304未修改 If-None-Match 允许在对应的内容未被修改的情况下返回304未修改（ 304 Not Modified ），参考 超文本传输协议 的实体标记 If-Range 如果该实体未被修改过，则向返回所缺少的那一个或多个部分。否则，返回整个新的实体 If-Unmodified-Since 仅当该实体自某个特定时间以来未被修改的情况下，才发送回应。 Max-Forwards 限制该消息可被代理及网关转发的次数。 Origin 发起一个针对跨域资源共享的请求（该请求要求服务器在响应中加入一个Access-Control-Allow-Origin的消息头，表示访问控制所允许的来源）。 Pragma 与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生。 Proxy-Authorization 用于向代理进行认证的认证信息。 Range 表示请求某个实体的一部分，字节偏移以0开始。 Referer 表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面。Referer其实是Referrer这个单词，但RFC制作标准时给拼错了，后来也就将错就错使用Referer了。 TE 浏览器预期接受的传输时的编码方式：可使用回应协议头Transfer-Encoding中的值（还可以使用”trailers”表示数据传输时的分块方式）用来表示浏览器希望在最后一个大小为0的块之后还接收到一些额外的字段。 User-Agent 浏览器的身份标识字符串 Upgrade 要求服务器升级到一个高版本协议。 Via 告诉服务器，这个请求是由哪些代理发出的。 Warning 一个一般性的警告，表示在实体内容体中可能存在错误。","tags":[{"name":"http","slug":"http","permalink":"https://github.com/NollieLeo/tags/http/"}]},{"title":"HTTP返回状态码","date":"2020-03-23T02:40:35.000Z","path":"2020/03/23/HTTP返回状态码/","text":"状态码100 Continue 继续。客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 200 OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容。服务器成功处理了部分GET请求 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 409 Conflict 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理","tags":[{"name":"http","slug":"http","permalink":"https://github.com/NollieLeo/tags/http/"}]},{"title":"面试题","date":"2020-03-23T01:10:29.000Z","path":"2020/03/23/面试题/","text":"*说一下http和https(1) http和https的概念： http：超文本传输协议，是互联网上使用广泛的一种网络协议，是一种客户端和服务器端请求和应答的标准（TCP的标准），是用于从www服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使得网络传输减少 https：是http的安全版，http下加入了SSL层，HTTPS的安全基础是SSL，因此加密详细内容就需要SSL，https的作用就是建立一条安全的通道，来确保传输数据的安全性，简单来说https协议就是由http和ssl协议构建的可进行加密传输和身份确认的网络协议。 (2) http和https区别： https需要ca证书，费用高 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 使用不同链接方式：端口不同，http是80，https是443 http连接简单，无状态的；https是由SSL+http协议构建的数据加密传输身份认证的网络协议。 (3) https协议的优点 确保数据的传输安全性和正确发送到对应的客户机和服务器。 加密传输和身份认证使得其在数据传输的过程中不容易被窃取改变，保证数据的完整性 (4) https协议的缺点 握手阶段比较费时 缓存效率不高，增加数据开销 SLL协议要钱 SLL需要绑定IP，一个IP不能绑定多个域名 *TCP三次握手，一句话概括客户端和服务端都需要直到各自可收发，因此需要三次握手。 简化三次握手： &lt;img width=&quot;487&quot; alt=&quot;2018-07-10 3 42 11&quot; src=&quot;https://user-images.githubusercontent.com/17233651/42496289-1c6d668a-8458-11e8-98b3-65db50f64d48.png&quot;&gt; 从图片可以得到三次握手可以简化为：C发起请求连接S确认，也发起连接C确认我们再看看每次握手的作用：第一次握手：S只可以确认 自己可以接受C发送的报文段，第二次握手：C可以确认 S收到了自己发送的报文段，并且可以确认 自己可以接受S发送的报文段第三次握手：S可以确认 C收到了自己发送的报文段。 TCP和UDP的区别 TCP是面向连接的，UDP是无连接的，就是发送连接之前不需要先建立连接 TCP提供可靠的服务。通过TCP传输的数据，无差错，不丢失，不重复，按序到达。UDP尽最大努力交付，不保证可靠的交付。因为TCP可靠且面向连接，不会丢失数据因此适合大数据量的交换。 TCP是面向字节流，UDP面向报文，如果网络故障出现拥塞不会使得发送速率降低，会出现丢包。 TCP只能1对1，UDP能够1对1，1对多 TCP首部较大的字节为20字节，UDP只有8字节 TCP是面向连接的可靠性传输，而UDP是不可靠的 一个图片url访问后直接下载怎样实现？参考回答：请求的返回头里面，用于浏览器解析的重要参数就是OSS的API文档里面的返回http头，决定用户下载行为的参数。 下载的情况下： \\1. x-oss-object-type: Normal \\2. x-oss-request-id: 598D5ED34F29D01FE2925F41 \\3. x-oss-storage-class: Standard http返回的状态码HTTP返回的状态码 http常用请求头HTTP常用请求头 几个很实用的BOM属性对象方法?说一下http2.0http2.0是基于http1.0之后的首次更新 提升了访问的速率：相比较于HTTP1.0请求资源所需要的时间更少，访问的速度更快 允许多路复用：多路复用允许同时通过单一的HTTP/2连接发送多重请求-响应信息 二进制分帧：在http2.0会将所有的传输信息分割为更小的信息或者帧，并且对他们进行二进制编码的首部压缩 *在地址栏里输入一个URL,到这个页面呈现出来，中间会发生什么？ 首先需要找到这个URL域名的服务器IP，浏览器首先会寻找缓存，查看缓存中是否有记录（浏览器缓存 -&gt; 系统缓存 -&gt; 路由器缓存 ），缓存中没则去查找系统的hosts文件记录，如果再没有就去查询DNS服务器。 浏览器根据得到的IP以及相应的端口号，构建一个HTTP请求，并将这个HTTP请求封装在一个TCP包中，发送给服务器（依次经过传输层，网络层，数据链路层，物理层，服务器） 服务器解析请求，返回相应的HTML给浏览器，浏览器根据HTML构建DOM树（在dom树的构建过程中如果遇到JS脚本和外部JS连接，则会停止构建DOM树来执行和下载相应的代码，造成阻塞）。 之后根据外部样式，内部样式，内联样式去构建一个CSS对象模型树叫CSSOM树，构建完成之后和DOM树合并为渲染树（ 这里主要做的是排除非视觉节点，比如script，meta标签和排除display为none的节点 ） 进行布局，确定各个元素位置和尺寸 渲染页面。（ 因为html文件中会含有图片，视频，音频等资源，在解析DOM的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是4-6个，当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过Cache-Control、Last-Modify、Expires等首部字段控制。 Cache-Control和Expires的区别在于Cache-Control使用相对时间，Expires使用的是基于服务器 端的绝对时间，因为存在时差问题，一般采用Cache-Control，在请求这些有设置了缓存的数据时，会先 查看是否过期，如果没有过期则直接使用本地缓存，过期则请求并在服务器校验文件是否修改，如果上一次 响应设置了ETag值会在这次请求的时候作为If-None-Match的值交给服务器校验，如果一致，继续校验 Last-Modified，没有设置ETag则直接验证Last-Modified，再决定是否返回304 ） 浏览器缓存可以查看这篇文章：深入理解浏览器的缓存机制 渲染机制可以看：深入浅出浏览器渲染原理 GET和POST的区别参考回答： get参数通过url传递，post放在request body中。 get请求在url中传递的参数是有长度限制的，而post没有。 get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。 get请求只能进行url编码，而post支持多种编码方式 get请求会浏览器主动cache，而post支持多种编码方式。 get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。 GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 GET产生一个TCP数据包；POST产生两个TCP数据包。 *Cookie、sessionStorage、localStorage的区别共同点：都是保存在浏览器端，并且是同源的 不同点： 存储环境和大小: cookie数据始终在同源的HTTP请求中携带（即便是不需要），即cookie在浏览器和服务器之间来回传递，cookie的数据还有路径的概念，可以限制cookie只属于某个路劲下，存储大小只有4k左右；sessionStorage 和localStorage不会自动把数据发送给服务器，仅在本地缓存，数据量都比cookie来的要大的多 数据持久性不同: sessionStorage仅在当前浏览器窗口关闭之前有效果，自然不可能持续保存；localstorage始终有效，窗口或者浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即窗口或浏览器关闭。 （key：本身就是一个回话过程，关闭浏览器后消失，session为一个回话，当页面不同即使是同一页面打开两次，也被视为同一次回话） 作用域不同（共享范围）：sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面 ；localStorage在所有的同源窗口中都是共享的；cookie也是在所有的同源窗口中都是共享的。（ 同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与否都会始终生效 ） cookie的作用 保存用户的登录状态： 例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。 跟踪用户的行为： 例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。","tags":[{"name":"面试题","slug":"面试题","permalink":"https://github.com/NollieLeo/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":".gitingnore匹配规则以及语法","date":"2020-03-19T01:17:13.000Z","path":"2020/03/19/gitingnore匹配规则以及语法/","text":"Git配置 .gitignore文件git 廖雪峰git教程 git官网 一. 忽略规则匹配语法 通配符 说明 空格 仅作为分隔符 # 注释 ! 不忽略某个文件 / 开头 仅仅匹配根目录 结束 / 匹配该文件夹及该文件夹下的所有内容 * 匹配多个字符 ** 匹配多级目录 ？ 匹配单个字符 [] 匹配包含单个字符的列表 Tips: 当前目录定义的规则优先级高于父级目录定义的规则 每行指定一条忽略规则 如果一行规则不包含“/”，则它匹配当前.gitignore文件所在路径的内容 二. 匹配示例 规则 说明 abc/ # 忽略当前路径下的 abc 文件夹 /abc # 忽略根目录下的 abc 文件 /*.txt # 忽略根目录下的 abc.txt，不忽略 app/abc.txt abc/*.txt # 忽略 abc/abc.txt，不忽略 abc/def/abc.txt 和 app/abc/abc.txt **/abc # 忽略 /abc、a/abc、a/b/abc a/**/b # 忽略 a/b、a/x/y/b !/app/abc.txt # 不忽略 app 目录下的 abc.txt 文件 *.log # 忽略所有 .log 文件 abc.txt #忽略当前路径下的 abc.txt 文件 *abc/ #忽略名词中末尾为abc的文件夹 * abc */ #忽略名称中间包含abc的文件夹 三. .gitignore文件不生效.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。所以一定要养成在项目开始就创建.gitignore文件的习惯。 解决方法就是先把本地缓存删除(改变成未track状态)，然后再提交： 如果远程仓库原来就已经存在现在.gitignore规则中忽略的内容，那么现在那些规则对那些内容是无效的，必须先删除本地缓存 $ git rm -r --cached 不过，这样做虽然可以删除远程仓库里被 .gitignore 规则忽略的内容，但是这些内容的 git 压缩版本依然被保存在可回滚记录中以备以后回滚，这会导致 git 仓库过大。虽然有一些办法可以给 git 仓库进行瘦身，但是操作比较繁琐，非常的不推荐。因此，个人觉得还是应该有良好的 git 使用习惯，对于不用提交到仓库的内容，要第一时间用 .gitignore 进行过滤。对于占用空间小的内容，可以不予理会，但如果有较多、较大文件，不光是占了太多的远程仓库空间和本地空间，并且在 clone、push 的时候，也会因为仓库过大，而影响 clone 速度。 四. 模板java 开发通用版本模板#java *.class #package file *.war *.ear *.zip *.tar.gz *.rar #maven ignore target/ build/ #eclipse ignore .settings/ .project .classpatch #Intellij idea .idea/ /idea/ *.ipr *.iml *.iws # temp file *.log *.cache *.diff *.patch *.tmp # system ignore .DS_Store Thumbs.db 前端项目# Numerous always-ignore extensions *.bak *.patch *.diff *.err # temp file for git conflict merging *.orig *.log *.rej *.swo *.swp *.zip *.vi *~ *.sass-cache *.tmp.html *.dump # OS or Editor folders .DS_Store ._* .cache .project .settings .tmproj *.esproj *.sublime-project *.sublime-workspace nbproject thumbs.db *.iml # Folders to ignore .hg .svn .CVS .idea node_modules/ jscoverage_lib/ bower_components/ dist/","tags":[{"name":"git","slug":"git","permalink":"https://github.com/NollieLeo/tags/git/"}]},{"title":"常用网站","date":"2020-03-19T01:03:44.000Z","path":"2020/03/19/常用网站/","text":"react react官方文档](https://reactjs.org/docs/getting-started.html) git 廖雪峰git教程 git官网 JavaScript 菜鸟教程JS参考手册 webpack NPM https://www.npmjs.com/ 秦枫的git blog: https://github.com/mqyqingfeng/Blog","tags":[{"name":"js","slug":"js","permalink":"https://github.com/NollieLeo/tags/js/"},{"name":"webpack","slug":"webpack","permalink":"https://github.com/NollieLeo/tags/webpack/"},{"name":"git","slug":"git","permalink":"https://github.com/NollieLeo/tags/git/"},{"name":"react","slug":"react","permalink":"https://github.com/NollieLeo/tags/react/"}]},{"title":"项目初始化-HTML模板","date":"2020-03-18T14:56:11.000Z","path":"2020/03/18/项目初始化-HTML模板/","text":"我们在项目初始化的时候，都会有一个html的模板，里面会做各种兼容和声明等工作。PC端如果需要适配IE8需要加入很多垫片，而且还要做好双核浏览器的优先选择配置等；M端更是需要做到不同分辨率屏幕的适配，另外还有300ms延迟问题。这里送上笔者在项目当中整理的两个模板，已经经过了一定项目的考验，供大家参考。 另外，本文中涉及的M端适配并非rem，而是修改viewport的显示比例，这个方案相较rem来说起码有2个优点：一是省字符，二是不用计算，设计稿是多少就是多少。不过在实践当中，UC浏览器貌似不认user-scalabe=0，还是会被双击放大，不过笔者认为还是可以接受的。如果还遇到了其他bug，请反馈，谢谢。 PC模板&lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;//cdn.staticfile.org/html5shiv/r29/html5.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//cdn.staticfile.org/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//cdn.staticfile.org/es5-shim/4.5.9/es5-shim.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//cdn.staticfile.org/es5-shim/4.5.9/es5-sham.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.staticfile.org/normalize/6.0.0/normalize.min.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; M模板&lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; (function() { var w = 750; // 设计稿尺寸 document.write(&#39;&lt;meta name=&quot;viewport&quot; content=&quot;width=&#39; + w + &#39;, initial-scale=&#39; + window.screen.width / w + &#39;, user-scalable=0&quot; /&gt;&#39;); })() &lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.staticfile.org/normalize/6.0.0/normalize.min.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;//cdn.staticfile.org/fastclick/1.0.6/fastclick.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; document.addEventListener(&#39;DOMContentLoaded&#39;, function() { Origami.fastclick(document.body); }, false); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 公共部分说明1、在 HTML 4.01 中，&lt;!DOCTYPE&gt; 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。HTML5 不基于 SGML，所以不需要引用 DTD。请始终向 HTML 文档添加 &lt;!DOCTYPE&gt; 声明，这样浏览器才能获知文档类型。它不是 HTML 标签，是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令；必须是 HTML 文档的第一行，位于 标签之前，没有结束标签，对大小写不敏感；参考文献：http://www.w3school.com.cn/tags/tag_doctype.asp 2、HTML 的 lang 属性可用于网页或部分网页的语言。这对搜索引擎和浏览器是有帮助的。根据 W3C 推荐标准，您应该通过 标签中的 lang 属性对每张页面中的主要语言进行声明。参考文献：http://www.w3school.com.cn/tags/html_ref_language_codes.asp 3、当你的 html 文件是以 UTF-8 编码保存的，而且里面有中文，你试试加与不加在 Chrome 的效果你就知道有没有区别了 4、告诉浏览器是否识别特定格式的文本。根据项目需求修改值。 PC部分说明1、控制IE渲染内核的选择。chrome=1针对装了chrome frame插件的IE浏览器起作用，以防万一写上。参考文献：https://msdn.microsoft.com/en-us/library/ff955275(v=vs.85).aspx 2、控制双核浏览器渲染引擎，content的取值为webkit、ie-comp、ie-stand之一，区分大小写，分别代表用webkit内核，IE兼容内核，IE标准内核。参考文献：http://se.360.cn/v6/help/meta.html 3、&lt;!–[if lt IE 9]&gt; //code here兼容IE9以下（不含）的写法，只有IE认。（例子中js为IE9-的垫片）参考文献：http://www.weste.net/2013/8-9/93104.html M部分说明1、js输出viewport缩放屏幕，适配不同大小设备 (function() { var w = 750; //设计稿设备宽度 document.write(&#39;&lt;meta name=&quot;viewport&quot; content=&quot;width=&#39; + w + &#39;, initial-scale=&#39; + window.screen.width / w + &#39;, user-scalable=0&quot; /&gt;&#39;); })() 加入以上代码，需修改变量值为设计稿的设备宽度，样式全部按照设计稿的数值和单位写就可以。详见：移动端常用布局方法参考文献：http://www.cnblogs.com/2050/p/3877280.html 2、fastclick解决iphone等手机的300ms延迟问题 &lt;script src=&quot;//st01.chrstatic.com/themes/chr-cdn/fastclick/v1.0.6/fastclick.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; document.addEventListener(&#39;DOMContentLoaded&#39;, function() { Origami.fastclick(document.body); }, false); &lt;/script&gt; 先加载fastclick.min.js，之后将需要去除300ms的dom挂上，压缩版写Origami.fastclick(document.body);，非压缩版写FastClick.attach(document.body);即可参考文献：https://github.com/ftlabs/fastclick/","tags":[{"name":"html","slug":"html","permalink":"https://github.com/NollieLeo/tags/html/"}]},{"title":"配置前端脚手架的时候碰到的问题","date":"2020-03-18T14:42:30.000Z","path":"2020/03/18/配置前端脚手架的时候碰到的问题/","text":"这段时间在自己搭建前端的脚手架，配置参照 从零搭建前端开发环境（零）——基础篇：1.npm、git及项目初始化 从零搭建前端开发环境（零）——基础篇：2.webpack生产与开发环境配置 webpack引入jquery的几种方法 配置过程中出现了一些问题， Cannot find module &#39;@babel/core&#39; babel-loader@8 requires Babel 7.x (the package &#39;@babel/c 解决帮助文章：babel安装问题，Cannot find module ‘@babel/core’ babel-loader@8 requires Babel 7.x (the package ‘@babel/c Error: Cannot find module &#39;webpack/bin/config-yargs 解决帮助文章：Error: Cannot find module ‘webpack/bin/config-yargs’ 报错原因, webpack@4.X踩的坑~ Error: Loading PostCSS Plugin failed: Cannot find module &#39;autoprefixer&#39;，解决帮助文章： webpack4 postcss-loader autoprefixer无效问题 Error: Loading PostCSS Plugin failed: Cannot find module ‘autoprefixer’ 问题正在发生…","tags":[{"name":"webpack","slug":"webpack","permalink":"https://github.com/NollieLeo/tags/webpack/"},{"name":"npm","slug":"npm","permalink":"https://github.com/NollieLeo/tags/npm/"}]},{"title":"BFC块级格式化上下文","date":"2020-03-16T14:56:11.000Z","path":"2020/03/16/BFC块级格式化上下文/","text":"参考文章 参考文章2 什么是BFC？BFC的全称为：块格式化上下文(Block Formatting Context) ，它是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。简单来说，BFC是一个独立的渲染区域 官方解释： 一个块格式化上下文（block formatting context） 是Web页面的可视化CSS渲染出的一部分。它是块级盒布局出现的区域，也是浮动层元素进行交互的区域。 一个块格式化上下文由以下之一创建： 根元素或其它包含它的元素 浮动元素 (元素的 float 不是 none) 绝对定位元素 (元素具有 position 为 absolute 或 fixed) 内联块 (元素具有 display: inline-block) 表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性) 表格标题 (元素具有 display: table-caption, HTML表格标题默认属性) 具有overflow 且值不是 visible 的块元素， display: flow-root column-span: all 应当总是会创建一个新的格式化上下文，即便具有 column-span: all 的元素并不被包裹在一个多列容器中。 一个块格式化上下文包括创建它的元素内部所有内容，除了被包含于创建新的块级格式化上下文的后代元素内的元素。 块格式化上下文对于定位 (参见 float) 与清除浮动 (参见 clear) 很重要。定位和清除浮动的样式规则只适用于处于同一块格式化上下文内的元素。浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只能清除同一块格式化上下文中在它前面的元素的浮动。 按照综上所述的话，BFC是一个html盒子然后呢必须至少满足下列其中的任意一个条件 float的值不为none position不为static或者relative display的值为 table-cell, table-caption, inline-block, flex, 或者 inline-flex中的其中一个 overflow的值不为visible 遵循规则 BFC在Web页面上是一个独立的容器，容器内外互不影响 和标准文档流一样，BFC内的元素垂直方向的边距会发生重叠 BFC不会与浮动元素的盒子重叠 计算BFC高度时即使子元素浮动也参与计算 实现一个BFC.container { overflow: hidden; } &lt;div class=&quot;container&quot;&gt; test BFC &lt;/div&gt; BFC常见作用（特性，功能）一. BFC中的盒子对齐 在BFC中，每个盒子的左外边框紧挨着包含块的左边框（从右到左的格式，则为紧挨右边框）。即使存在浮动也是这样的（尽管一个盒子的边框会由于浮动而收缩），除非这个盒子的内部创建了一个新的BFC浮动，盒子本身将会变得更窄）。 简单来说，在上图中我们可以看到，所有属于同一个BFC的盒子都左对齐（左至右的格式），他们的左外边框紧贴着包含块的左边框。在最后一个盒子里我们可以看到尽管那里有一个浮动元素（棕色）在它的左边，另一个元素（绿色）仍然紧贴着包含块的左边框。关于为什么会发生这种情况的原理将会在下面的文字环绕部分进行讨论 二. BFC导致的外边距折叠 在常规文档流中，盒子都是从包含块的顶部开始一个接着一个垂直堆放。两个兄弟盒子之间的垂直距离是由他们个体的外边距所决定的，但不是他们的两个外边距之和。 在上图中我们看到在红色盒子（一个div）中包含两个绿色的兄弟元素（p元素），一个BFC已经被创建。 .container { overflow: hidden; background-color: yellow; } .container p { margin: 10px 0; background-color: green; } &lt;div class=&quot;container&quot;&gt; &lt;p&gt;hsdsdsddd&lt;/p&gt; &lt;p&gt;hsdsdsddd&lt;/p&gt; &lt;/div&gt; 理论上两个兄弟元素之间的边距应该是来两个元素的边距之和（20px），但它实际上为10px。这就是被称为外边距折叠。当兄弟元素的外边距不一样时，将以最大的那个外边距为准。 另一种情况就是两个元素的margin值不一样，那么他们两个元素直接的距离就是他们最大的margin距离 .container p:first-of-type { margin: 10px 0; background-color: green; } .container p:nth-of-type(2){ margin: 20px 0; background-color: green; } 三. 使用BFC防止外边距折叠毗邻块盒子的垂直外边距折叠只有他们是在同一BFC时才会发生。如果他们属于不同的BFC，BFC是独立的容器， 容器内外互不影响 ，所以他们之间的外边距将不会折叠。所以通过创建一个新的BFC我们可以防止外边距折叠。 &lt;div class=&quot;container&quot;&gt; &lt;p&gt;hsdsdsddd&lt;/p&gt; &lt;p&gt;hsdsdsddd&lt;/p&gt; &lt;div class=&quot;newBfc&quot;&gt; &lt;p&gt;sdadsadsa&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; .container { overflow: hidden; width: 200px; background-color: yellow; } .container p { margin: 10px 0; background-color: green; } .newBfc { overflow: hidden; } 四. BFC和浮动问题一个BFC可以包含住浮动的元素。一个容器中有浮动元素，我们大多时候是通过清除浮动的方式clearfix来解决，但也可以通过定义一个BFC来达到目的。 下面一个例子： &lt;style&gt; .container { border: 10px solid yellow; min-height: 20px; } .in { height: 50px; width: 200px; float: left; background-color: forestgreen; } &lt;/style&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;in&quot;&gt;&lt;/div&gt; &lt;/div&gt; 此时如果加上float:left的话，就会脱离普通的文档流 通过使得外层元素产生一个BFC从而包裹住内层浮动的元素 &lt;style&gt; .container { border: 10px solid yellow; min-height: 20px; overflow: hidden; /* 产生BFC其中一个条件 */ } .in { height: 50px; width: 200px; float: left; background-color: forestgreen; } &lt;/style&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;in&quot;&gt;&lt;/div&gt; &lt;/div&gt; 5. 解决浮动后发生元素重叠的问题普通文档流中，当一个元素使用float:left脱离正常的文档流之后，会使得其他的元素与其发生重叠，BFC可以解决这个问题。 &lt;style&gt; .container { background: grey; } .left { height: 100px; width: 100px; background-color: red; float: left; } .right { height: 150px; width: 150px; background: green; } &lt;/style&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt; 为了使其不发生重叠，可以使得right元素产生BFC（BFC容器内外互不影响） .right { height: 150px; width: 150px; background: green; overflow: hidden; } 六. 和浮动的元素能够产生边界​ 第五点说到了如何用BFC解决浮动产生的两个元素重叠的问题，一般来说要解决这种浮动的问题，都会让第五点中right元素的margin-left设置为left元素宽度，如果说要和浮动的元素产生边距的话，就需要 距离+left元素宽度 。 ​ 此时让right元素产生BFC之后，得让left的margin-right设置为你想要的边距。 &lt;style&gt; .container { background: grey; } .left { height: 100px; width: 100px; background-color: red; float: left; margin-right: 10px; } .right { height: 150px; width: 150px; background: green; overflow: hidden; margin-left: 10px; } &lt;/style&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt; 七. 使用BFC防止文字环绕 有时候一个浮动div周围的文字环绕着它（如下图中的左图所示）但是在某些案例中这并不是可取的，我们想要的是外观跟下图中的右图一样的。为了解决这个问题，我们可能使用外边距，但是我们也可以使用一个BFC来解决。 首先让我们理解文字为什么会环绕。为此我们需要知道当一个元素浮动时盒子模型是如何工作的。 这个p元素并没有移动，但是它却出现在浮动元素的下方。p元素的line boxes（指的是文本行）进行了移位。此处line boxes的水平收缩为浮动元素提供了空间。 随着文字的增加，因为line boxes不再需要移位,最终将会环绕在浮动元素的下方，因此出现了那样的情况。这就解释了为什么即使在浮动元素存在时，段落也将紧贴在包含块的左边框上，还有为什么line boxes会缩小以容纳浮动元素。 如果我们能够移动整个p元素，那么这个环绕的问题就可以解决了。 在BFC中，每个盒子的左外边框紧挨着左边框的包含块（从右到左的格式化时，则为右边框紧挨）。即使在浮动里也是这样的（尽管一个盒子的边框会因为浮动而萎缩），除非这个盒子的内部创建了一个新的BFC（这种情况下,由于浮动，盒子本身将会变得更窄） &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;floated&quot;&gt;Floated div&lt;/div&gt; &lt;p&gt; Quae hic ut ab perferendis sit quod architecto,dolor debitis quam rem provident aspernatur tempora expedita. &lt;/p&gt; &lt;/div&gt; 因此为了使其不产生这样文字环绕的效果可以使得p产生一个BFC，这样就不会紧紧挨了。 &lt;style&gt; .container { background: grey; } .floated { height: 20px; width: 100px; background-color: red; float: left; } p{ display: flow-root; } &lt;/style&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;floated&quot;&gt;Floated div&lt;/div&gt; &lt;p&gt; Quae hic ut ab perferendis sit quod architecto,dolor debitis quam rem provident aspernatur tempora expedita. &lt;/p&gt; &lt;/div&gt; 八. 在多列布局中使用BFC 如果我们正在创建的一个多列布局占满了整个容器的宽度，在某些浏览器中最后一列有时候将会被挤到下一行。会发生这样可能是因为浏览器舍入（取整）了列的宽度使得总和的宽度超过了容器的宽度。然而，如果我们在一个列的布局中建立了一个新的BFC，它将会在前一列填充完之后的后面占据所剩余的空间。 &lt;style&gt; .column { width: 31.33%; height: 100px; background-color: green; float: left; margin: 0 1%; } .column:last-child { float: none; overflow: hidden; } &lt;/style&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;column&quot;&gt;column 1&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;column 2&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;column 3&lt;/div&gt; &lt;/div&gt;","tags":[{"name":"BFC","slug":"BFC","permalink":"https://github.com/NollieLeo/tags/BFC/"},{"name":"css","slug":"css","permalink":"https://github.com/NollieLeo/tags/css/"}]},{"title":"原型模式和基于原型继承的Javascript对象系统","date":"2020-03-16T14:28:09.000Z","path":"2020/03/16/原型模式和基于原型继承的Javascript对象系统/","text":"在以类为中心的面向对象编程语言中，类和对象的关系可以想象成铸模和铸件的关系，对象总是从类中创建而来。而在原型编程的思想中，类并不是必需的，对象未必需要从类中创建而来，一个对象是通过克隆另外一个对象所得到的。 1. 使用克隆的原型模式从设计模式的角度讲，原型模式是用于创建对象的一种模式，如果我们想要创建一个对象，一种方法是先指定它的类型，然后通过类来创建这个对象。原型模式选择了另外一种方式，我们不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象 既然原型模式是通过克隆来创建对象的，那么很自然地会想到，如果需要一个跟某个对象一模一样的对象，就可以使用原型模式 原型模式的实现关键，是语言本身是否提供了 clone 方法。ECMAScript 5提供了 Object.create方法 var Plane = function () { this.blood = 100; this.attackLevel = 1; this.defenceLevel = 1; } var myPlane = new Plane(); myPlane.blood = 500; myPlane.attackLevel = 10; myPlane.defenceLevel = 7; // 在不支持 Object.create 方法的浏览器中，则可以使用以下代码 Object.create = Object.create || function (obj) { var F = function () { }; F.prototype = obj; return new F(); } var clonePlane = Object.create(myPlane); console.log(clonePlane); 2. 原型编程范型的一些规则 所有的数据都是对象 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。 对象会记住它的原型。 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。 3. JavaScript中的原型继承(构建对象系统)同理，js也同样遵循以上的编程规则 1. 所有的数据都是对象JavaScript在设计的时候，模仿 Java 引入了两套类型机制：基本类型和对象类型。基本类型包括 undefined 、 number 、 boolean 、 string 、 function 、 object 除了 undefined 之外，一切都应是对象。为了实现这一目标，number 、 boolean 、 string 这几种基本类型数据也可以通过“包装类”的方式变成对象类型数据来处理 不能说在 JavaScript中所有的数据都是对象，但可以说绝大部分数据都是对象。那么相信在 JavaScript中也一定会有一个根对象存在，这些对象追根溯源都来源于这个根对象。 JavaScript 中的根对象是 Object.prototype 对象。 Object.prototype 对象是一个空的对象。我们在JavaScript 遇到的每个对象，实际上都是从 Object.prototype 对象克隆而来的，Object.prototype 对象就是它们的原型。 可以利用 ECMAScript 5提供的 Object.getPrototypeOf 来查看这两个对象的原型： var obj1 = new Object(); var obj2 = {}; console.log( Object.getPrototypeOf( obj1 ) === Object.prototype ); // 输出：true console.log( Object.getPrototypeOf( obj2 ) === Object.prototype ); // 输出：true 2. 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它在 JavaScript语言里，我们并不需要关心克隆的细节，因为这是引擎内部负责实现的。我们所需要做的只是显式地调用 var obj1 = new Object() 或者 var obj2 = {} 。此时，引擎内部会从Object.prototype 上面克隆一个对象出来，我们最终得到的就是这个对象. 用 new 运算符从构造器中得到一个对象 function Person( name ){ this.name = name; }; Person.prototype.getName = function(){ return this.name; }; var a = new Person( &#39;sven&#39; ) console.log( a.name ); // 输出：sven console.log( a.getName() ); // 输出：sven console.log( Object.getPrototypeOf( a ) === Person.prototype ); // 输出：true 这里 Person 并不是类，而是函数构造器，JavaScript 的函数既可以作为普通函数被调用，也可以作为构造器被调用,当使用 new 运算符来调用函数时，此时的函数就是一个构造器。 用new 运算符来创建对象的过程，实际上也只是先克隆 Object.prototype 对象，再进行一些其他额外操作的过程。 可以模拟new的过程： // 模拟new的实现方式 // 先来一个Person构造器 function Person(name) { this.name = name; } Person.prototype.getName = function () { return this.name; } var objectFactory = function () { var obj = new Object(), //从Object.prototype上克隆一个空的对象{} Constructor = [].shift.call(arguments); // 取得外部传入的构造器，此例是 Person obj.__proto__ = Constructor.prototype; // 指向正确的原型 var ret = Constructor.apply(obj, arguments); // 借用外部传入的构造器给 obj 设置属性 return typeof ret === &#39;object&#39; ? ret : obj; // 确保构造器总是会返回一个对象 } var a = objectFactory(Person, &#39;weng&#39;); console.log(a.getName()); 3. 对象会记住它的原型对象的原型”，就 JavaScript 的真正实现来说，其实并不能说对象有原型，而只能说对象的构造器有原型。对于“对象把请求委托给它自己的原型”这句话，更好的说法是对象把请求委托给它的构造器的原型 JavaScript 给对象提供了一个名为 __proto__ 的隐藏属性，某个对象的 __proto__ 属性默认会指向它的构造器的原型对象，即 {Constructor}.prototype。在一些浏览器中， __proto__ 被公开出来 var a = new Object(); console.log ( a.__proto__=== Object.prototype ); // 输出：true __proto__ 就是对象跟“对象构造器的原型”联系起来的纽带。正因为对象要通过_proto__ 属性来记住它的构造器的原型，所以我们的 objectFactory 函数来模拟用 new创建对象时， 需要手动给 obj 对象设置正确的 __proto__ 指向 obj.__proto__ = Constructor.prototype; 让 obj.proto 指向 Person.prototype ，而不是原来的 Object.prototype 4. 如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型在 JavaScript 中，每个对象都是从 Object.prototype 对象克隆而来的，如果是这样的话，我们只能得到单一的继承关系，即每个对象都继承自 Object.prototype 对象，这样的对象系统显然是非常受限的。 实际上，虽然 JavaScript 的对象最初都是由 Object.prototype 对象克隆而来的，但对象构造器的原型并不仅限于 Object.prototype 上，而是可以动态指向其他对象。这样一来，当对象 a 需要借用对象 b 的能力时，可以有选择性地把对象 a 的构造器的原型指向对象 b ，从而达到继承的效果 常用原型继承代码解析var obj = { name: &#39;sven&#39; }; var A = function(){}; A.prototype = obj; var a = new A(); console.log( a.name ); // 输出：sven 首先，尝试遍历对象 a 中的所有属性，但没有找到 name 这个属性 查找 name 属性的这个请求被委托给对象 a 的构造器的原型，它被 a. __proto__ 记录着并且指向 .prototype ，而 A.prototype 被设置为对象 obj 在对象 obj 中找到了 name 属性，并返回它的值 当我们期望得到一个“类”继承自另外一个“类”的效果时，往往会用下面的代码来模拟实现 var A = function(){}; A.prototype = { name: &#39;sven&#39; }; var B = function(){}; B.prototype = new A(); var b = new B(); console.log( b.name ); // 输出：sven 首先，尝试遍历对象 b 中的所有属性，但没有找到 name 这个属性 查找 name 属性的请求被委托给对象 b 的构造器的原型，它被 b. __proto__ 记录着并且指向B.prototype ，而 B.prototype被设置为一个通过 new A()创建出来的对象 在该对象中依然没有找到 name 属性，于是请求被继续委托给这个对象构造器的原型A.prototype 在 A.prototype 中找到了 name 属性，并返回它的值","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/NollieLeo/tags/javascript/"},{"name":"js设计模式","slug":"js设计模式","permalink":"https://github.com/NollieLeo/tags/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"原型链","slug":"原型链","permalink":"https://github.com/NollieLeo/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"}]},{"title":"基本数据类型和引用数据类型","date":"2020-03-16T14:28:09.000Z","path":"2020/03/16/基本数据类型和引用数据类型/","text":"ECMA script中的数据类型 1. 基本数据类型（undefined，boolean，number，string，null）基本数据类型主要是：undefined，boolean，number，string，null。 1.1 基本数据类型存放在栈中存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配，是直接按值存放的，所以可以直接访问。 1.2 基本数据类型值不可变 javascript中的原始值（undefined、null、布尔值、数字和字符串）与对象（包括数组和函数）有着根本区别。原始值是不可更改的：任何方法都无法更改（或“突变”）一个原始值。对数字和布尔值来说显然如此 —— 改变数字的值本身就说不通，而对字符串来说就不那么明显了，因为字符串看起来像由字符组成的数组，我们期望可以通过指定索引来假改字符串中的字符。实际上，javascript 是禁止这样做的。字符串中所有的方法看上去返回了一个修改后的字符串，实际上返回的是一个新的字符串值。 基本数据类型的值是不可变的，动态修改了基本数据类型的值，它的原始值也是不会改变的，例如： var str = &quot;abc&quot;; console.log(str[1]=&quot;f&quot;); // f console.log(str); // abc 这一点其实开始我是比较迷惑的，总是感觉 js 是一个灵活的语言，任何值应该都是可变的，真是图样图森破，我们通常情况下都是对一个变量重新赋值，而不是改变基本数据类型的值。就如上述引用所说的那样，在 js 中没有方法是可以改变布尔值和数字的。倒是有很多操作字符串的方法，但是这些方法都是返回一个新的字符串，并没有改变其原有的数据。 所以，记住这一点：基本数据类型值不可变。 1.3 基本类型的比较是值的比较基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的，例如： var a = 1; var b = 1; console.log(a === b);//true 比较的时候最好使用严格等，因为 == 是会进行类型转换的，比如： var a = 1; var b = true; console.log(a == b);//true 2. 引用类型2.1 引用类型存放在堆中引用类型（object）是存放在堆内存中的，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配，例如。 var person1 = {name:&#39;jozo&#39;}; var person2 = {name:&#39;xiaom&#39;}; var person3 = {name:&#39;xiaoq&#39;}; 堆内存 2.2 引用类型值可变引用类型是可以直接改变其值的，例如： var a = [1,2,3]; a[1] = 5; console.log(a[1]); // 5 2.3 引用类型的比较是引用的比较所以每次我们对 js 中的引用类型进行操作的时候，都是操作其对象的引用（保存在栈内存中的指针），所以比较两个引用类型，是看其的引用是否指向同一个对象。例如： var a = [1,2,3]; var b = [1,2,3]; console.log(a === b); // false复制代码 虽然变量 a 和变量 b 都是表示一个内容为 1，2，3 的数组，但是其在内存中的位置不一样，也就是说变量 a 和变量 b 指向的不是同一个对象，所以他们是不相等的。 3. 传值与传址了解了基本数据类型与引用类型的区别之后，我们就应该能明白传值与传址的区别了。在我们进行赋值操作的时候，基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中。例如： var a = 10; var b = a; a ++ ; console.log(a); // 11 console.log(b); // 10 所以说，基本类型的赋值的两个变量是两个独立相互不影响的变量。 但是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响。例如： var a = {}; // a保存了一个空对象的实例 var b = a; // a和b都指向了这个空对象 a.name = &#39;jozo&#39;; console.log(a.name); // &#39;jozo&#39; console.log(b.name); // &#39;jozo&#39; b.age = 22; console.log(b.age);// 22 console.log(a.age);// 22 console.log(a == b);// true","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/NollieLeo/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://github.com/NollieLeo/tags/ES6/"},{"name":"基本数据类型和引用类型","slug":"基本数据类型和引用类型","permalink":"https://github.com/NollieLeo/tags/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"}]},{"title":"鸭子类型","date":"2020-03-16T14:22:27.000Z","path":"2020/03/16/鸭子类型/","text":"我们可以通过一个小故事来更深刻地了解鸭子类型。 从前在 JavaScript王国里，有一个国王，他觉得世界上最美妙的声音就是鸭子的叫声，于是国王召集大臣，要组建一个 1000 只鸭子组成的合唱团。大臣们找遍了全国，终于找到 999只鸭子，但是始终还差一只，最后大臣发现有一只非常特别的鸡，它的叫声跟鸭子一模一样，于是这只鸡就成为了合唱团的最后一员。 这个故事告诉我们，国王要听的只是鸭子的叫声，这个声音的主人到底是鸡还是鸭并不重要。鸭子类型指导我们只关注对象的行为，而不关注对象本身，也就是关注 HAS-A, 而不是 IS-A。 var duck = { type: &#39;duck&#39;, duckSinging: function () { console.log(&#39;gagagag&#39;); } } var chicken = { type: &#39;chicken&#39;, duckSinging: function () { console.log(&#39;gagagag&#39;); } } var choir = []; var joinChoir = function (animal) { if (animal &amp;&amp; typeof animal.duckSinging === &#39;function&#39;) { choir.push(animal); console.log(`恭喜${animal.type}加入合唱团`); console.log(`合唱团已有人数为${choir.length}`); } } joinChoir(duck); joinChoir(chicken); 我们看到，对于加入合唱团的动物，大臣们根本无需检查它们的类型，而是只需要保证它们拥有 duckSinging 方法。如果下次期望加入合唱团的是一只小狗，而这只小狗刚好也会鸭子叫，我相信这只小狗也能顺利加入。 在动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用鸭子类型的思想，我们不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程，而不是面向实现编程*”。例如，一个对象若有 push 和 pop 方法，并且这些方法提供了正确的实现，它就可以被当作栈来使用。一个对象如果有 length 属性，也可以依照下标来存取属性（最好还要拥有 slice 和 splice 等方法），这个对象就可以被当作数组来使用。 在静态类型语言中，要实现“面向接口编程”并不是一件容易的事情，往往要通过抽象类或者接口等将对象进行向上转型。当对象的真正类型被隐藏在它的超类型身后，这些对象才能在类型检查系统的“监视”之下互相被替换使用。只有当对象能够被互相替换使用，才能体现出对象多态性的价值。 “面向接口编程”是设计模式中最重要的思想，但在 JavaScript语言中，“面向接口编程”的过程跟主流的静态类型语言不一样，因此，在 JavaScript中实现设计模式的过程与在一些我们熟悉的语言中实现的过程会大相径庭。","tags":[{"name":"js设计模式","slug":"js设计模式","permalink":"https://github.com/NollieLeo/tags/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"鸭子类型","slug":"鸭子类型","permalink":"https://github.com/NollieLeo/tags/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/"}]},{"title":"深拷贝与浅拷贝","date":"2020-03-16T14:02:38.000Z","path":"2020/03/16/浅拷贝和深拷贝2/","text":"深拷贝与浅拷贝一下部分参照知乎中的提问： javascript中的深拷贝和浅拷贝 浅拷贝赋值（=）和浅拷贝的区别那么赋值和浅拷贝有什么区别呢，我们看下面这个例子： var obj1 = { &#39;name&#39; : &#39;zhangsan&#39;, &#39;age&#39; : &#39;18&#39;, &#39;language&#39; : [1,[2,3],[4,5]], }; var obj2 = obj1; var obj3 = shallowCopy(obj1); function shallowCopy(src) { var dst = {}; for (var prop in src) { if (src.hasOwnProperty(prop)) { dst[prop] = src[prop]; } } return dst; } obj2.name = &quot;lisi&quot;; obj3.age = &quot;20&quot;; obj2.language[1] = [&quot;二&quot;,&quot;三&quot;]; obj3.language[2] = [&quot;四&quot;,&quot;五&quot;]; console.log(obj1); //obj1 = { // &#39;name&#39; : &#39;lisi&#39;, // &#39;age&#39; : &#39;18&#39;, // &#39;language&#39; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]], //}; console.log(obj2); //obj2 = { // &#39;name&#39; : &#39;lisi&#39;, // &#39;age&#39; : &#39;18&#39;, // &#39;language&#39; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]], //}; console.log(obj3); //obj3 = { // &#39;name&#39; : &#39;zhangsan&#39;, // &#39;age&#39; : &#39;20&#39;, // &#39;language&#39; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]], //}; 先定义个一个原始的对象 obj1，然后使用赋值得到第二个对象 obj2，然后通过浅拷贝，将 obj1 里面的属性都赋值到 obj3 中。也就是说： obj1：原始数据 obj2：赋值操作得到 obj3：浅拷贝得到 然后我们改变 obj2 的 name 属性和 obj3 的 name 属性，可以看到，改变赋值得到的对象 obj2 同时也会改变原始值 obj1，而改变浅拷贝得到的的 obj3 则不会改变原始对象 obj1。这就可以说明赋值得到的对象 obj2 只是将指针改变，其引用的仍然是同一个对象，而浅拷贝得到的的 obj3 则是重新创建了新对象。 然而，我们接下来来看一下改变引用类型会是什么情况呢，我又改变了赋值得到的对象 obj2 和浅拷贝得到的 obj3 中的 language 属性的第二个值和第三个值（language 是一个数组，也就是引用类型）。结果见输出，可以看出来，无论是修改赋值得到的对象 obj2 和浅拷贝得到的 obj3 都会改变原始数据。 这是因为浅拷贝只复制一层对象的属性，并不包括对象里面的为引用类型的数据。所以就会出现改变浅拷贝得到的 obj3 中的引用类型时，会使原始数据得到改变。 深拷贝：将 B 对象拷贝到 A 对象中，包括 B 里面的子对象， 浅拷贝：将 B 对象拷贝到 A 对象中，但不包括 B 里面的子对象 – 和原数据是否指向同一对象 第一层数据为基本数据类型 原数据中包含子对象 赋值 是 改变会使原数据一同改变 改变会使原数据一同改变 浅拷贝 否 改变不会使原数据一同改变 改变会使原数据一同改变 深拷贝 否 改变不会使原数据一同改变 改变不会使原数据一同改变 深拷贝看了这么半天，你也应该清楚什么是深拷贝了吧，如果还不清楚，我就剖腹自尽(ಥ_ಥ) 深拷贝是对对象以及对象的所有子对象进行拷贝。 那么问题来了，怎么进行深拷贝呢？ 思路就是递归调用刚刚的浅拷贝，把所有属于对象的属性类型都遍历赋给另一个对象即可。我们直接来看一下 Zepto 中深拷贝的代码： // 内部方法：用户合并一个或多个对象到第一个对象 // 参数： // target 目标对象 对象都合并到target里 // source 合并对象 // deep 是否执行深度合并 function extend(target, source, deep) { for (key in source) if (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) { // source[key] 是对象，而 target[key] 不是对象， 则 target[key] = {} 初始化一下，否则递归会出错的 if (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key])) target[key] = {} // source[key] 是数组，而 target[key] 不是数组，则 target[key] = [] 初始化一下，否则递归会出错的 if (isArray(source[key]) &amp;&amp; !isArray(target[key])) target[key] = [] // 执行递归 extend(target[key], source[key], deep) } // 不满足以上条件，说明 source[key] 是一般的值类型，直接赋值给 target 就是了 else if (source[key] !== undefined) target[key] = source[key] } // Copy all but undefined properties from one or more // objects to the `target` object. $.extend = function(target){ var deep, args = slice.call(arguments, 1); //第一个参数为boolean值时，表示是否深度合并 if (typeof target == &#39;boolean&#39;) { deep = target; //target取第二个参数 target = args.shift() } // 遍历后面的参数，都合并到target上 args.forEach(function(arg){ extend(target, arg, deep) }) return target } 利用weakMap实现递归clonefunction clone(target, weakMap = new weakMap) { if ((typeof target === &#39;object&#39;)) { let cloneTarget = Array.isArray.call(target) ? [] : {}; if (weakMap.get(target)) { return weakMap.get(target); } weakMap.set(target, cloneTarget); for (const key in target) { cloneTarget[key] = clone(target[key], weakMap); } return cloneTarget; } else { return target; } } 扩展运算符（…） 是什么类型的拷贝？ 浅拷贝","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/NollieLeo/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://github.com/NollieLeo/tags/ES6/"},{"name":"深拷贝与浅拷贝","slug":"深拷贝与浅拷贝","permalink":"https://github.com/NollieLeo/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"}]},{"title":"静态类型语言与动态类型语言区别","date":"2020-03-16T09:46:53.000Z","path":"2020/03/16/静态类型语言与动态类型语言区别/","text":"编程语言按照数据类型大体可以分为两类，一类是静态类型语言，另一类是动态类型语言 区别静态类型语言在编译时便已确定变量的类型，而动态类型语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。 静态类型语言的优点首先是在编译时就能发现类型不匹配的错误，编辑器可以帮助我们提前避免程序在运行期间有可能发生的一些错误。其次，如果在程序中明确地规定了数据类型，编译器还可以针对这些信息对程序进行一些优化工作，提高程序执行速度 静态类型语言的缺点首先是迫使程序员依照强契约来编写程序，为每个变量规定数据类型，归根结底只是辅助我们编写可靠性高程序的一种手段，而不是编写程序的目的，毕竟大部分人编写程序的目的是为了完成需求交付生产。其次，类型的声明也会增加更多的代码，在程序编写过程中，这些细节会让程序员的精力从思考业务逻辑上分散开来。 动态类型语言的优点是编写的代码数量更少，看起来也更加简洁，程序员可以把精力更多地放在业务逻辑上面。虽然不区分类型在某些情况下会让程序变得难以理解，但整体而言，代码量越少，越专注于逻辑表达，对阅读程序是越有帮助的。 动态类型语言的缺点是无法保证变量的类型，从而在程序的运行期有可能发生跟类型相关的错误。 javascript是一门动态类型语言，动态类型语言对变量类型的宽容给实际编码带来了很大的灵活性。由于无需进行类型检测，我们可以尝试调用任何对象的任意方法，而无需去考虑它原本是否被设计为拥有该方法。","tags":[{"name":"js设计模式","slug":"js设计模式","permalink":"https://github.com/NollieLeo/tags/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"高阶组件","date":"2020-03-16T09:43:47.000Z","path":"2020/03/16/高阶组件/","text":"高阶组件1.高阶组件定义 高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件 2.函数模拟高阶函数function banana() { let name = &#39;wengkaimin&#39;; console.log(`${name} likes banana`); } function apple(myName) { let name = &#39;wengkaimin&#39;; console.log(`${name} likes apple`); } banana(); apple(); 以上有冗余的代码，在平时开发过程中可能会有一大堆写一个中间函数来处理这个相同的代码 function banana(myName) { console.log(`${myName} likes banana`); } function apple(myName) { console.log(`${myName} likes apple`) } function getFruit(fun) { let myFruit = (() =&gt; { let myName = &#39;wengkaimin&#39;; fun(myName); }) return myFruit } banana = getFruit(banana); apple = getFruit(apple); banana(); apple(); getFruit函数就叫做一个高阶函数，他帮我们处理了前面两个函数的相同模块，帮忙把myName自动的加入了所有继承getFruit的函数，此场景在react中的高阶组件有广泛的应用。 3.react中的高阶组件改成react高阶组件形式 import React, { Component } from &#39;react&#39; class Banana extends Component { constructor(props) { super(props); this.state = { username: &#39;&#39; } } componentWillMount() { let username = &#39;wengkaimin&#39; this.setState({ username: username }) } render() { return ( &lt;div&gt; {this.state.username} likes banana&lt;/div&gt; ) } } export default Banana; import React, { Component } from &#39;react&#39; class Apple extends Component { constructor(props) { super(props); this.state = { username: &#39;&#39; } } componentWillMount() { let username = &#39;wengkaimin&#39; this.setState({ username: username }) } render() { return ( &lt;div&gt; {this.state.username} likes apple&lt;/div&gt; ) } } export default Apple; 从两段代码来看有很多重复的组件代码。按照高阶函数的思想我们中间封装一个高阶组件来处理这些东西。 import React, {Component} from &#39;react&#39; export default (fruitComponent) =&gt; { class Myfruit extends Component { constructor() { super(); this.state = { username: &#39;&#39; } } componentWillMount() { let username = &#39;wengkaimin&#39; this.setState({ username: username }) } render() { return &lt;fruitComponent username={this.state.username}/&gt; } } return Myfruit } 简化apple和banana组件 import React, {Component} from &#39;react&#39;; import Myfruit from &#39;Myfruit&#39;; class Banana extends Component { render() { return ( &lt;div&gt; {this.props.username} likes banana&lt;/div&gt; ) } } Banana = Myfruit(Banana); export default Banana; 同理apple高阶组件把username通过props把他传给目标组件。","tags":[{"name":"高阶组件","slug":"高阶组件","permalink":"https://github.com/NollieLeo/tags/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"}]},{"title":"this,call和apply","date":"2020-03-16T09:16:30.000Z","path":"2020/03/16/this-call和apply/","text":"this, call 和apply1. this JavaScript的 this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境 1.1 this指向 作为对象方法调用 作为普通函数调用 构造器调用 Function.prototype.apply或``Function.prototype.call` 1.1.1 作为对象方法调用var obj = { a:1, getA:function(){ alert(this === obj); alert(this.a); } } obj.getA(); 1.1.2 作为普通函数调用当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，此时的 this 总是指向全局对象。在浏览器的 JavaScript里，这个全局对象是 window 对象 window.name = &#39;globalName&#39;; var myObject = { name: &#39;sven&#39;, getName: function () { return this.name; } }; var getName = myObject.getName; //作为普通函数，这时候this指向全局，因为它不是以对象的属性调用的，可以看1.2 console.log(getName()); // globalName 1.1.3 构造器调用 JavaScript 中没有类，但是可以从构造器中创建对象，同时也提供了 new 运算符，使得构造器看起来更像一个类 除了宿主提供的一些内置函数，大部分 JavaScript函数都可以当作构造器使用。构造器的外表跟普通函数一模一样，它们的区别在于被调用的方式。当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的 this 就指向返回的这个对象 var MyClass = function(){ this.name = &#39;sven&#39;; }; var obj = new MyClass(); alert ( obj.name ); // 输出：sven 但用 new 调用构造器时，还要注意一个问题，如果构造器显式地返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的 this var MyClass = function(){ this.name = &#39;sven&#39;; return { // 显式地返回一个对象 name: &#39;anne&#39; } }; var obj = new MyClass(); alert ( obj.name ); // 输出：anne 如果构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题： var MyClass = function(){ this.name = &#39;sven&#39; return &#39;anne&#39;; // 返回 string 类型 }; var obj = new MyClass(); alert ( obj.name ); // 输出：sven 1.1.4 Function.prototype.call 或 Function.prototype.apply 调用跟普通的函数调用相比，用 Function.prototype.call 或 Function.prototype.apply 可以动态地改变传入函数的 this ： var obj1 = { name: &#39;sven&#39;, getName: function(){ return this.name; } }; var obj2 = { name: &#39;anne&#39; }; console.log( obj1.getName() ); // 输出: sven console.log( obj1.getName.call( obj2 ) ); // 输出：anne 1.2 丢失的thisvar obj = { myName: &#39;sven&#39;, getName: function(){ return this.myName; } }; console.log( obj.getName() ); // 输出：&#39;sven&#39; var getName2 = obj.getName; console.log( getName2() ); // 输出：undefined 当调用 obj.getName 时， getName 方法是作为 obj 对象的属性被调用的，当用另外一个变量 getName2 来引用 obj.getName ，并且调用getName2 时，此时是以普通函数的形式来调用的， this 是指向全局 window 的 再来个栗子 document.getElementById = (function( func ){ return function(){ return func.apply( document, arguments ); } })( document.getElementById ); var getId = document.getElementById; var div = getId( &#39;div1&#39; ); alert (div.id); // 输出： div1 利用 apply 把 document 当作 this 传入 getId 函数，帮助“修正” this 否则如果想要简化document.getElementById单纯的是不可取的 var getId = document.getElementById; console.log(getId(&#39;hello&#39;)); 2. call 和apply2.1 区别Function.prototype.call和 Function.prototype.apply都是非常常用的方法。它们的作用一模一样，区别仅在于传入参数形式的不同 apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组,apply 方法把这个集合中的元素作为参数传递给被调用的函数 call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数 var func = function (a, b, c) { alert([a, b, c]); // 输出 [ 1, 2, 3 ] }; func.call(null, 1, 2, 3); func.apply(null, [1, 2, 3]); 当调用一个函数时，JavaScript 的解释器并不会计较形参和实参在数量、类型以及顺序上的区别，JavaScript的参数在内部就是用一个数组来表示的。从这个意义上说， apply 比 call 的使用率更高，我们不必关心具体有多少参数被传入函数，只要用 apply 一股脑地推过去就可以了 当使用 call 或者 apply 的时候，如果我们传入的第一个参数为 null ，函数体内的 this 会指向默认的宿主对象，在浏览器中则是 window 有时候我们使用 call 或者 apply 的目的不在于指定 this 指向，而是另有用途，比如借用其他对象的方法。那么我们可以传入 null 来代替某个具体的对象： Math.max.apply( null, [ 1, 2, 5, 3, 4 ] ) // 输出：5 2.2 call 和 apply 的用途2.2.1 改变 this 指向window.name = &#39;motherfucker&#39;; obj1 = { name: &#39;helloobj1&#39;, } obj2 = { name: &#39;hellowobj2&#39;, } var getName = function () { console.log(this.name); } getName(); getName.apply(obj1); getName.apply(obj2); 实际开发过程中会遇到this指向被不经意改变 例如： document.getElementById( &#39;div1&#39; ).onclick = function(){ alert( this.id ); // 输出：div1 }; 假如该事件函数中有一个内部函数 func ，在事件内部调用 func 函数时， func 函数体内的 this就指向了 window ，而不是我们预期的 div document.getElementById( &#39;div1&#39; ).onclick = function(){ alert( this.id ); // 输出：div1 var func = function(){ alert ( this.id ); // 输出：undefined } func(); }; 解决方法有两种，一种是之前提到的 document.getElementById(&#39;hello&#39;).onclick = function () { var that = this; console.log(that.id); // 输出：hello var func = function () { console.log(that.id); // 输出：undefined } func(); }; 第二种就是call和apply document.getElementById( &#39;div1&#39; ).onclick = function(){ var func = function(){ alert ( this.id ); // 输出：div1 } func.call( this ); };","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/NollieLeo/tags/javascript/"},{"name":"js this指向","slug":"js-this指向","permalink":"https://github.com/NollieLeo/tags/js-this%E6%8C%87%E5%90%91/"},{"name":"call,apply","slug":"call-apply","permalink":"https://github.com/NollieLeo/tags/call-apply/"}]},{"title":"多态","date":"2020-03-16T09:16:30.000Z","path":"2020/03/16/多态/","text":"多态的实际含义是：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。 var makeSound = function (animal) { if(animal instanceof Duck){ console.log(&#39;嘎嘎嘎&#39;); }else if(animal instanceof Dog){ console.log(&#39;汪汪&#39;); } } var Duck = function(){}; var Dog = function(){}; makeSound(new Duck()); makeSound(new Dog()); ​ 这段代码确实体现了“多态性”，当我们分别向鸭和鸡发出“叫唤”的消息时，它们根据此消息作出了各自不同的反应。但这样的“多态性”是无法令人满意的，如果后来又增加了一只动物，比如狗，显然狗的叫声是“汪汪汪”，此时我们必须得改动 makeSound 函数，才能让狗也发出叫声。修改代码总是危险的，修改的地方越多，程序出错的可能性就越大，而且当动物的种类越来越多时， makeSound 有可能变成一个巨大的函数。 ​ 多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来，也就是将“不变的事物”与 “可能改变的事物”分离开来。在这个故事中，动物都会叫，这是不变的，但是不同类型的动物具体怎么叫是可变的。把不变的部分隔离出来，把可变的部分封装起来，这给予了我们扩展程序的能力，程序看起来是可生长的，也是符合开放 — 封闭原则的，相对于修改代码来说，仅仅增加代码就能完成同样的功能，这显然优雅和安全得多 1. 对象的多态性var makeSound = function (animal) { if (typeof animal === &#39;object&#39; &amp;&amp; animal.sound) { animal.sound(); } else { console.log(&#39;我不是动物我不能叫&#39;) } } var Duck = function () { }; var Dog = function () { }; Duck.prototype.sound = function () { console.log(&#39;嘎嘎嘎嘎&#39;); } makeSound(new Duck()); makeSound(new Dog()); 2. JavaScript的多态多态的思想实际上是把“做什么”和“谁去做”分离开来，要实现这一点，归根结底先要消除类型之间的耦合关系。如果类型之间的耦合关系没有被消除，那么我们在 makeSound 方法中指定了发出叫声的对象是某个类型，它就不可能再被替换为另外一个类型。 在 Java中，可以通过向上转型来实现多态。 而 JavaScript的变量类型在运行期是可变的。一个 JavaScript对象，既可以表示 Duck 类型的对象，又可以表示 Chicken 类型的对象，这意味着 JavaScript对象的多态性是与生俱来的 这种与生俱来的多态性并不难解释。JavaScript作为一门动态类型语言，它在编译时没有类型检查的过程，既没有检查创建的对象类型，又没有检查传递的参数类型。 由此可见，某一种动物能否发出叫声，只取决于它有没有 makeSound 方法，而不取决于它是否是某种类型的对象，这里不存在任何程度上的“类型耦合”。在 JavaScript中，并不需要诸如向上转型之类的技术来取得多态的效果。 3. 多态在面向对象程序设计中的作用有许多人认为，多态是面向对象编程语言中最重要的技术。但我们目前还很难看出这一点，毕竟大部分人都不关心鸡是怎么叫的，也不想知道鸭是怎么叫的。让鸡和鸭在同一个消息之下发出不同的叫声，这跟程序员有什么关系呢？ Martin Fowler在《重构：改善既有代码的设计》里写到：多态的最根本好处在于，你不必再向对象询问“你是什么类型”而后根据得到的答案调用对象的某个行为——你只管调用该行为就是了，其他的一切多态机制都会为你安排妥当。 换句话说，多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。 Martin Fowler的话可以用下面这个例子很好地诠释： 在电影的拍摄现场，当导演喊出“action”时，主角开始背台词，照明师负责打灯光，后面的群众演员假装中枪倒地，道具师往镜头里撒上雪花。在得到同一个消息时，每个对象都知道自己应该做什么。如果不利用对象的多态性，而是用面向过程的方式来编写这一段代码，那么相当于在电影开始拍摄之后，导演每次都要走到每个人的面前，确认它们的职业分工（类型），然后告诉他们要做什么。如果映射到程序中，那么程序中将充斥着条件分支语句。 利用对象的多态性，导演在发布消息时，就不必考虑各个对象接到消息后应该做什么。对象应该做什么并不是临时决定的，而是已经事先约定和排练完毕的。每个对象应该做什么，已经成为了该对象的一个方法，被安装在对象的内部，每个对象负责它们自己的行为。所以这些对象可以根据同一个消息，有条不紊地分别进行各自的工作。 将行为分布在各个对象中，并让这些对象各自负责自己的行为，这正是面向对象设计的优点。","tags":[{"name":"js设计模式","slug":"js设计模式","permalink":"https://github.com/NollieLeo/tags/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"多态","slug":"多态","permalink":"https://github.com/NollieLeo/tags/%E5%A4%9A%E6%80%81/"}]},{"title":"封装","date":"2020-03-16T09:16:30.000Z","path":"2020/03/16/封装/","text":"封装封装的目的是将信息隐藏。一般而言，我们讨论的封装是封装数据和封装实现。这一节将讨论更广义的封装，不仅包括封装数据和封装实现，还包括封装类型和封装变化。 1. 封装数据在许多语言的对象系统中，封装数据是由语法解析来实现的，这些语言也许提供了 private 、public 、 protected 等关键字来提供不同的访问权限。 但 JavaScript并没有提供对这些关键字的支持，我们只能依赖变量的作用域来实现封装特性，而且只能模拟出 public 和 private 这两种封装性。 var myObject = (function () { var _name = &#39;sven&#39;; return { getName: function () { return _name; } } })() console.log(myObject.getName()); 2. 封装实现封装的目的是将信息隐藏，封装应该被视为“任何形式的封装”，也就是说，封装不仅仅是隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等 从封装实现细节来讲，封装使得对象内部的变化对其他对象而言是透明的，也就是不可见的。对象对它自己的行为负责。其他对象或者用户都不关心它的内部实现。封装使得对象之间的耦合松散，对象之间只通过暴露的 API接口来通信。当我们修改一个对象时，可以随意地修改它的内部实现，只要对外的接口没有变化，就不会影响到程序的其他功能。","tags":[{"name":"js设计模式","slug":"js设计模式","permalink":"https://github.com/NollieLeo/tags/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"布局详解","date":"2020-03-16T09:05:18.000Z","path":"2020/03/16/flex布局详解/","text":"flex布局深入了解1. flex布局flex容器的属性 属性名称 属性含义 属性可能的值 flex-direction 决定主轴的方向 row(默认) 水平，起点在左端row-reverse水平，起点在右端column:垂直，起点在上沿column-reverse:垂直，起点在下沿 flex-wrap 决定一条轴线放不下，如何换行 Nowrap(默认) 不换行Wrap:换行，第一行在上面Wrap-reverse:换行，第一行在下面 flex-flow 是上面两个属性的简写 默认值是 row nowrap justify-content 定义项目在主轴上的对齐方式 Flex-start(默认值）左对齐Flex-end 右对齐Center居中Space-between:两端对齐，项目之间的间隔都相等Space-around:每个项目之间的间隔相等，所以项目之间的间隔比项目与边框之间的间隔大一倍 align-items 定义项目在交叉轴上如何对齐 Flex-start交叉轴的起点对齐Flex-end交叉轴的终点对齐Center:交叉轴的中点对齐Baseline：项目的第一行文字的基线对齐Stretch （默认值）如果项目未设置高度或者设为auto，将占满整个容器的高度 align-content 定义多跟轴线对齐方式，一条轴线该属性不起作用 Flex-start: 与交叉轴的起点对齐Flex-end 与交叉轴的终点对齐Center:与交叉轴的中点对齐Space-between:与交叉轴的两端对齐，轴线之间的间隔平均分布Space-around：每根轴线之间的间隔都相等，所以轴线之间的间隔比轴线与边框之间的间隔大一倍 *flex容器下面项目的属性 * 属性名称 属性含义 属性可能的值 order 定义项目的排列顺序，数值越小，排列越靠前 默认0 flex-grow 定义项目的放大比例，如果存在剩余空间，不放大 默认0（如果所有项目的flex-grow属性为1，则等分剩余空间） flex-shrink 定义项目的缩小比例 默认1 负值对该属性无效 flex-basis 定义在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性来计算主轴是否有多余空间 默认auto,即项目本来大小 flex 是上面三个的简写 默认值 0 1 auto 后两个值可选 align-self 允许单个项目与其他项目不一样的对齐方式，可覆盖align-items属性 默认值auto 表示继承父元素的align-items属性，如果没有父元素，则等同于stretch 2.1 常用的垂直居中css.container { display: flex; align-items: center; justify-content: center; height: 500px; background: #666; } .box { width: 200px; height: 200px; background: #ff0; } Html&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box&quot;&gt;hello 翁恺敏&lt;/div&gt; &lt;/div&gt; 效果图： 2.2 常用的ul,li布局横向等宽排列 Html&lt;ul class=&quot;container&quot;&gt; &lt;li&gt;翁&lt;/li&gt; &lt;li&gt;恺&lt;/li&gt; &lt;li&gt;敏&lt;/li&gt; &lt;li&gt;你&lt;/li&gt; &lt;li&gt;好&lt;/li&gt; &lt;/ul&gt; css.container { width: 500px; display: flex; list-style: none; padding: 0; } .container &gt;li{ flex: 1; height: 50px; } .container &gt;li:nth-of-type(2n){ background: red } .container &gt;li:nth-of-type(2n-1){ background: green } 2.3 骰子布局详解 2.3.1 单项目 首先，只有左上角1个点的情况。Flex布局默认就是首行左对齐，所以一行代码就够了。 .box { display: flex; } 设置项目的对齐方式，就能实现居中对齐和右对齐。 .box { display: flex; justify-content: center; } .box { display: flex; justify-content: flex-end; } 设置交叉轴对齐方式，可以垂直移动主轴。垂直居中 .box { display: flex; align-items: center; } .box { display: flex; justify-content: center; align-items: center; } .box { display: flex; justify-content: center; align-items: flex-end; } .box { display: flex; justify-content: flex-end; align-items: flex-end; } 2.3.2 双项目 .box { display: flex; justify-content: space-between; } .box { display: flex; flex-direction: column; justify-content: space-between; } .box { display: flex; flex-direction: column; justify-content: space-between; align-items: center; } .box { display: flex; flex-direction: column; justify-content: space-between; align-items: center; } .box { display: flex; } .item:nth-child(2) { align-self: center; } .box { display: flex; justify-content: space-between; } .item:nth-child(2) { align-self: flex-end; } 2.3.3 三项目 .box { display: flex; } .item:nth-child(2) { align-self: center; } .item:nth-child(3) { align-self: flex-end; } 2.3.3 四项目 .box { display: flex; flex-wrap: wrap; justify-content: flex-end; align-content: space-between; } HTML &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; css .box { display: flex; flex-wrap: wrap; align-content: space-between; } .column { flex-basis: 100%; display: flex; justify-content: space-between; } 2.3.4 六项目 .box { display: flex; flex-wrap: wrap; align-content: space-between; } .box { display: flex; flex-direction: column; flex-wrap: wrap; align-content: space-between; } 2.4 圣杯布局（常见） html&lt;div class=&quot;container&quot;&gt; &lt;header&gt;Header&lt;/header&gt; &lt;div class=&quot;content&quot;&gt; &lt;main&gt;Main&lt;/main&gt; &lt;nav&gt;Nav&lt;/nav&gt; &lt;aside&gt;Aside&lt;/aside&gt; &lt;/div&gt; &lt;footer&gt;Footer&lt;/footer&gt; &lt;/div&gt; css* { margin: 0; padding: 0; } html, body { width: 100%; height: 100%; } .container { display: flex; /* 垂直*/ flex-direction: column; width: 100%; /*视口被均分为100单位的vh 占据整个窗口*/ min-height: 100vh; } header, footer { background: #999; /*放大缩小比例为0 占据垂直方向80px*/ flex: 0 0 80px; } .content { display: flex; /*1 1 auto 后两个值省略*/ flex: 1; } nav { /*默认 0 数值越小 排列越靠前*/ order: -1; flex: 0 0 80px; background: royalblue; } aside { flex: 0 0 80px; background: aqua; } main { flex: 1; background: green; }","tags":[]},{"title":"==与===区别","date":"2020-03-16T09:02:08.000Z","path":"2020/03/16/==与===区别/","text":"1. 相等操作符（==和===）1.1 使用==时，不同类型的值也可以被看作相等 如果x和y是相同类型，JavaScript会比较它们的值或对象值。其他没有列在这个表格中的情况都会返回falsetoNumber和toPrimitive方法是内部的 toNumber方法对不同类型返回的结果如下： toPrimitive方法对不同类型返回的结果如下： 验证： 显而易见结果并不相同，为啥？ 首先，布尔值会被toNumber方法转成数字，因此得到wengkaimin == 1。 其次，用toNumber转换字符串值。因为字符串包含有字母，所以会被转成NaN，表达式 就变成了NaN == 1，结果就是false。 这行代码也是同样原理 首先，布尔值会被toNumber方法转成数字，因此得到wengkaimin == 0。 其次，用toNumber转换字符串值。因为字符串包含有字母，所以会被转成NaN，表达式 就变成了NaN == 0，结果就是false 一样的，只是将字符串转数字了，‘1’转1（number）类型 1.2 === 操作符 如果比较的两个值类型不同，比较的结果就是false。如果 比较的两个值类型相同，结果会根据下表判断 如果x和y类型不同，结果就是false。*例子： * console.log(&#39;packt&#39; === true); //false console.log(&#39;packt&#39; === &#39;packt&#39;); //true var person1 = {name:&#39;John&#39;}; var person2 = {name:&#39;John&#39;}; console.log(person1 === person2); //false，不同的对象","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/NollieLeo/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://github.com/NollieLeo/tags/ES6/"}]},{"title":"nodejs学习记录","date":"2020-03-16T07:17:47.000Z","path":"2020/03/16/nodejs学习记录/","text":"1.node自带模块fs文件管理nodejs官方文档 1.1 readdir和readdirSync的区别 两者都用与读取文件或者文件夹里的文件有啥 fs.readdir(path[, options], callback)异步函数，需要传入一个回调 path options encoding 默认值: &#39;utf8&#39;。 withFileTypes 默认值: false。 callback(两个参数，错误回调优先) err 默认值为null files 错误处理代码： let dirs = fs.readdir(&#39;./hello.txt&#39;, (err, files) =&gt; { if(err){ console.log(err); }else{ console.log(files); } }) fs.readdirSync(path[, options]) 同步函数 path options encoding默认值: &#39;utf8&#39;。 withFileTypes默认值: false。 返回: 错误处理代码： try { let dirs = fs.readdirSync(&#39;./node.js&#39;); //异步 } catch (err) { console.log(&#39;粗ucol&#39;); console.log(err) } 因为同步函数没有异步那样的处理错误机制，因此需要配合try catch才能捕获错误的同时又不暂停下面的代码运行。 1.2 mkdir和mkdirSync 创建文件mkdir文档 1.3 rename 重命名 和 rmdir删除文件rename rmdir 1.4 writeFile 覆盖写入 和appendFile添加写入文件1.5 readFile 读取文件内容(二进制数据流)fs.readFile(&#39;name.txt&#39;,(err,data)=&gt;{ console.log(data.toString(&#39;UTF-8&#39;)) }) 可以用toString(‘UTF-8’)的方法将文字提取出来； 或者直接在配置项中 fs.readFile(&#39;name.txt&#39;, &#39;UTF-8&#39;, (err, data) =&gt; { console.log(data) }) 1.6 fs.stat(path[, options], callback)fs.stat 2. url内置模块 2.1 url.parse()和url.format()url.parse()将其解析成一个url对象，从而可以从url中获取href中的各种值 1570865560878 url.format()将对象再拼起来 let url = require(&quot;url&quot;); let urlStirng = &#39;https://code.choerodon.com.cn/choerodon-framework?page=2&#39; let urlObj = url.parse(urlStirng); console.log(urlObj); let string = url.format(urlObj); console.log(string) 3. querystring内置模块querystring 3.1 stringfy()对象转成字符串，parse()根据符号解析querystring3.2 escape()和unescape()编码与解码let qs = require(&#39;querystring&#39;) // let string = &#39;name=weng&amp;pass=12121&amp;sex=0&amp;hello=111&#39; // let obj = qs.parse(string); // console.log(obj) let string = &#39;w=你好&amp;boo=21&#39;; let code = qs.escape(string); console.log(code); let parseCode = qs.unescape(code); console.log(parseCode); 4. nodemailer 第三方模块基本的发送邮箱代码： &#39;use strict&#39;; const nodemailer = require(&#39;nodemailer&#39;); // 创建发送邮件的请求对象 let transporter = nodemailer.createTransport({ host: &#39;smtp.qq.com&#39;, //发送方用的邮箱 port: 465, //端口号 secure: true, // true for 465, false for other ports auth: { user: &#39;736653759@qq.com&#39;, // 发生方邮箱地址 pass: &#39;hebnhkaruvzlbfdg&#39; // mtp验证码 } }); // send mail with defined transport object let mailObj = { from: &#39;&quot;Fred Foo 👻&quot; &lt;736653759@qq.com&gt;&#39;, to: &#39;736653759@qq.com&#39;, subject: &#39;Hello test nodemailer ✔&#39;, // Subject line text: &#39;Hello world of node.js?&#39;, // plain text body html: &#39;&lt;b&gt;Hello world?&lt;/b&gt;&#39; // html body }; // main().catch(console.error); setTimeout(() =&gt; { transporter.sendMail(mailObj, (err, data) =&gt; { console.log(data) }) }, 2000) 5. error对象错误对象本身没有终止代码执行，所以你需要throw抛出异常 let err = new Error(&#39;发生错误&#39;); throw err; 6. 爬虫案例 （方法2待补充） 获取目标网站 分析网站内容 cheerio 可以用jquery中的选择器进行网页内容分析 cheerio中文文档 const cheerio = require(&#39;cheerio&#39;); let $ = cheerio.load(&#39;&lt;div&gt;&lt;p&gt;hello&lt;/p&gt;&lt;img src = &quot;http://www.baidu.com&quot;/&gt;&#39;); const img = $(&#39;div img&#39;).attr(&#39;src&#39;); console.log(img) 将一组html转化为类dom,可以通过cheerio实现jq中的$选择器，从而实现一些dom获取的操作。 获取有效信息，下载或者其他操作 http https 根据不同的请求选择不同的协议。 *爬图片的代码 方法1：downLoad.js文件 const fs = require(&#39;fs&#39;); const path = require(&#39;path&#39;); const request = require(&#39;request&#39;); var dirPath = path.join(__dirname, &quot;MarvelImages&quot;); //__dirname当前路径，加上要创建的文件名 function downloadfile(downloadUrl, index) { // 创建文件夹 if (!fs.existsSync(dirPath)) { // 同步查询文件夹是否存在 fs.mkdirSync(dirPath); // 同步创建文件夹 console.log(dirPath + &#39;文件创建成功&#39;); } let imgUrlArray = downloadUrl.split(&#39;/&#39;); //分割Url let imgUrl = imgUrlArray[imgUrlArray.length - 1]; //获取文件名 let filename = imgUrl; let stream = fs.createWriteStream(path.join(dirPath, filename)); if (downloadUrl.indexOf(&#39;http&#39;) !== -1) { request(downloadUrl).pipe(stream).on(&#39;error&#39;, (err) =&gt; { console.log(err); }).on(&#39;close&#39;, () =&gt; { console.log(`文件【${filename}】下载完`); // callback(null, dest); }) } else { console.log(`${downloadUrl}文件找不到`); } } module.exports = downloadfile; splider.js const http = require(&#39;http&#39;); const cheerio = require(&#39;cheerio&#39;); let downLoad = require(&#39;./downLoad&#39;); let mavelUrl = &#39;http://marvel.mtime.com/&#39; http.get(mavelUrl, (res) =&gt; { const { statusCode } = res; //状态码 const contentType = res.headers[&#39;content-type&#39;]; //请求到的文件类型 console.log(`请求到的文件类型` + contentType); // 做安全判断 let error; if (statusCode !== 200) { error = new Error(&#39;请求失败.&#39; + `Status Code: ${statusCode}错误`); } else if (!/^text\\/html/.test(contentType)) { error = new Error(&#39;Invalid content-type.\\n&#39; + `Expected text/html but received ${contentType}`) } if (error) { //如果出错的话直接来到这一行 console.error(error.message); res.resume(); //重置缓存 return false; } // 数据是分段的,每一次接受到一段数据都会触发data事件，chunk就是数据片段 // 所以必须用一个string来当总chunk，每一次请求一个拼接一个 let rawData = &#39;&#39;; res.on(&#39;data&#39;, (chunk) =&gt; { rawData += chunk.toString(&#39;UTF-8&#39;); }); res.on(&#39;end&#39;, () =&gt; { let $ = cheerio.load(rawData); $(&#39;img&#39;).each((index, ele) =&gt; { let imgSrc = $(ele).attr(&#39;src&#39;); downLoad(&#39;http://marvel.mtime.com/&#39; + imgSrc, index); }) }) }).on(&#39;error&#39;, (err) =&gt; { console.log(&#39;请求错误&#39;); }) 方法2：7. express框架（写api）express中文文档 7.1.简要用法先明确一点，接口的构成要素有啥 ip port pathname method (get post put delete) 写一个get接口 const express = require(&#39;express&#39;); const app = express() //express实例化 // 监听3000端口 app.listen(3000, () =&gt; { console.log(&#39;server start at localhost://3000&#39;); }) // 写一个get接口 app.get(&#39;/user/login&#39;, (req, res) =&gt; { console.log(req.query); //接受到的值 console.log(&#39;你好&#39;); res.send({ status: &#39;success&#39; }); }) // 协议 http https 地址栏中输入http://localhost:3000/user/login?username=wengkaimin&amp;ps=123456 控制台中就能接受到传过来的数据，通过req.query接受get方法传过来的参数 写一个post接口 express不提供解析消息体的功能，所以req.body是拿不到主体的，这边提供了一个第三方插件 body-parser body-parser npm const express = require(&#39;express&#39;); const app = express() //express实例化 const bp = require(&#39;body-parser&#39;); // express中app.use表示使用一个中间件 // parse application/x-www-form-urlencoded解析表单格式数据 app.use(bp.urlencoded({ extended: false })) // parse application/json app.use(bp.json()); // 监听3000端口 app.listen(3000, () =&gt; { console.log(&#39;server start at localhost://3000&#39;); }) // 写一个get接口 app.get(&#39;/user/login&#39;, (request, res) =&gt; { console.log(request.query); console.log(&#39;你好&#39;); let { username, ps } = request.query; if (username === &#39;weng&#39; &amp;&amp; ps === &#39;1234&#39;) { res.send({ status: &#39;success&#39; }); } else { res.send(&#39;登陆失败&#39;) } }); // 写一个post接口 app.post(&#39;/user/reg&#39;, (request, result) =&gt; { // request.body获取数据，消息体，请求体 // let { us, ps } = request.body; console.log(request.body); // express不能直接解析消息体 // 需要第三方插件 body-parser result.send({ status: 1 }) }) // 协议 http https 7.2 中间件 middlewear 内置中间件 static 自定义中间件（全局）（局部） 第三方中间件（body-parse) (拦截器) const express = require(&#39;express&#39;); const app = express(); // 中间件 // 全局中间件,所有请求发送之前都要走这一步 app.use(&#39;/&#39;, (req, res, next) =&gt; { let { token } = req.query; if (token) { res.send(&quot;OK&quot;); next(); //是否继续往下执行 } else { res.send(&#39;缺少token&#39;); } }) app.get(&#39;/test1&#39;, (requst, result) =&gt; { console.log(&#39;test1&#39;) console.log(requst.query) }) app.get(&#39;/test2&#39;, (requst, result) =&gt; { console.log(&#39;test2&#39;) }) app.listen(3000, () =&gt; { console.log(&#39;server start at localhost://3000&#39;) }) 7.3 静态资源目录 static 指定一个目录，可以被访问 像apache的www一样 部署静态资源文件 const express = require(&#39;express&#39;); const path = require(&#39;path&#39;); const app = express(); const dirPath = path.join(__dirname, &#39;/static&#39;); console.log(dirPath); app.use(express.static(dirPath)); //可以从这个路径直接获取到资源 app.listen(3000, () =&gt; { console.log(&#39;server start at localhost://3000&#39;) }) 7.4 路由 server.js const express = require(&#39;express&#39;); const app = express(); let userRouter = require(&#39;./router/userRouter&#39;); let foodRouter = require(&#39;./router/foodRouter&#39;); app.use(&#39;/user&#39;, userRouter); app.use(&#39;/food&#39;, foodRouter) app.listen(3000, () =&gt; { console.log(&quot;server start localhost:3000&quot;); }) userRouter.js const express = require(&#39;express&#39;); const router = express.Router(); router.get(&#39;/add&#39;, (req, res) =&gt; { res.send(&#39;user add&#39;) }) router.get(&#39;/del&#39;, () =&gt; { console.log(&#39;user delete&#39;) }) module.exports = router 8. MongoDB 非关系型数据库8.1 指令基本 mongodb 数据库名 mongod 命令行启动数据库命令 mongo 命令行操作数据库指令 mongoose node 操作数据库插件 中文文档 show dbs show collections","tags":[{"name":"nodeJS","slug":"nodeJS","permalink":"https://github.com/NollieLeo/tags/nodeJS/"}]},{"title":"flex3个属性详解","date":"2020-03-16T05:18:33.000Z","path":"2020/03/16/flex3个属性详解/","text":"Flex 3个属性详解 flex属性 flex:(flex-grow)(flex-shrink)(flex-basis) flex-grow 一个数字，规定项目将相对于其他灵活的项目进行扩展的量（放大属性） flex-shrink 一个数字，规定项目将相对于其他灵活的项目进行收缩的量（缩小属性） flex-basis 项目的长度。合法值：”auto”、”inherit” 或一个后跟 “%”、”px”、”em” 或任何其他长度单位的数字。（基本宽度） 1. flex: none等同于 （flex: 0 0 auto） 这时候容器完全不再灵活。即不能放大也不能缩小。 除了它不允许 flex-shrink 属性（不能缩小），即使元素可能会溢出。 2. flex:initial(flex: 0 1 auto )等同于（0 auto） flex-grow为0，则存在剩余空间也不放大 flex-shrink为1，则空间不足该项目缩小 z flex-basis为auto，则该项目本来的大小 ,长度等于灵活项目的长度。如果该项目未指定长度，则长度将根据内容决定。 .parent { display: flex; width: 600px; border: 1px solid #000; } .parent&gt;div { height: 100px; } .item1 { width: 100px; background-color: #666; } .item2 { width: 100px; background: blue; } .item3 { width: 100px; background: lightblue; } &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;item1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 此时，当容器剩余一些空闲空间时，该属性使灵活的项目变得不灵活，因为其不能自由拉伸放大。 但是当容器没有足够的空间时，该属性允许其缩小到项目的最小值。 设置前面两个元素为flex: none, width:100px 全是initial，width分别设置为：100px ，100px ，700px，此时已经超出了容器的宽度，这时候里头的3个元素自动收缩 baseWidth: flex-basis ? flex-basis : width (flex-basis的优先级比width高); allWidth: flex元素的flex-basis和，或者width和其的和，看优先级; overflowWidth: allwidth - 父容器width 每个flex元素缩小值计算： $$(baseWidth/allWidth) * overflowWidth$$ 所以这次情况是：div1宽度为100px - 100/900 * 300 = 66.66…. 3. flex: auto相当于 flex: 1 1 auto 这个时候，该属性使3个item完全灵活，它们能够吸收主轴上额外的空间。既可以自由放大也可以自由缩小。 4. flex:&lt; positive-number &gt; &lt;意为 正数&gt;等同于 flex: &lt; positive-number &gt; 1 0px 当 flex 取值为一个非负数字，则该数字为 flex-grow 的值，flex-shrink 取 1，flex-basis 取 0%。 这个时候，该属性使弹性项目变得灵活，flex元素在主轴方向上的初始大小flex-basis为零。 项目将根据容器的大小按照自身的比例自由伸缩。 根据他们flex-grow来计算他们分配到的宽度 :$$flexGrow * flexWidth$$ $$flexWidth = (600-allFlexBasisWidth)/(1+1+2) = (600 - 0)/4 =150px$$由于flex:1 ,其中的flex-basis是为0px的，所以说,要根据自己div的宽度来决定元素的基础宽度，如果div没设置宽度那就根据内部元素的宽度撑开的宽度，例如： 如果这时候一个元素的flex-basis设置为auto 这时候就需要根据这个设置了auto元素的宽度来进行计算，因为item2没有设置width所以得根据他的内容宽度来计算分配到的宽度。 当他没有设置flex属性的时候，内容宽度为99.08px 所以算他在成为flex元素时候分配到的宽度为： (600-99.08)/4=125.23 5. flex:&lt; positive-number &gt; xxpx ||%xx该属性和上边的CSS案例一致，即 当 flex 取值为一个非负数字和一个长度（px）或百分比（%）， 则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 默认取 1 例题： &lt;style type=&quot;text/css&quot;&gt; .parent { display: flex; width: 600px; border: 1px solid #000; } .parent&gt;div { height: 100px; } .item1 { background-color: #666; flex: 2 1 30%; } .item2 { width:100px; background: blue; flex: 2 1 auto; } .item3 { flex: 1 1 200px; background: lightblue; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;item1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 计算出3个item的宽度 先判断他们几个的basisWidth和是否超出了容器的宽度: 600*30% +200 + 0 = 380px &lt;600px，故，剩余的宽度用于flex元素的宽度扩展 计算伸展因子：(600 - 380)/ (2+2+1) = 44 px 因此他们所分配到的宽度各为：2 * 44+180 ，2 * 44，1 * 44+200 6. 归纳每次去计算一个flexbox的元素宽度 flex-grow 不为0 的时候并且flex-basis宽度加起来不超出容器宽，以flex-basis为基准算伸展因子，当flex-grow为0时，flex-basis最大，width第二。 flex-grow 不为0的时候并且flex-basis为auto的时候，虽然有width值，但计算收缩因子时候这一块的flex-basis也只能算是0.","tags":[{"name":"flex","slug":"flex","permalink":"https://github.com/NollieLeo/tags/flex/"}]}]